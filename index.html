<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>El Susurro de la Inocente</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700;900&family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=UnifrakturMaguntia&display=swap');

    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --blood-red: #8b0000;
      --deep-red: #5c0000;
      --crimson: #dc143c;
      --dark-bg: #050505;
      --darker-bg: #020202;
      --panel-bg: rgba(5, 0, 0, 0.92);
      --panel-border: rgba(139, 0, 0, 0.6);
      --text-primary: #c9a87c;
      --text-dim: #6b5a47;
      --text-white: #e8ddd0;
      --fog-color: rgba(20, 5, 5, 0.85);
      --green-sanity: #00c853;
      --yellow-sanity: #ffd600;
      --orange-sanity: #ff6d00;
      --red-sanity: #d50000;
      --stamina-color: #1565c0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--dark-bg);
      color: var(--text-primary);
      font-family: 'Crimson Text', serif;
      cursor: default;
      user-select: none;
    }

    /* ========== SCROLLBAR ========== */
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: var(--darker-bg); }
    ::-webkit-scrollbar-thumb { background: var(--blood-red); }

    /* ========== UTILITY ========== */
    .screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: none;
      z-index: 10;
    }

    .screen.active {
      display: flex;
    }

    /* ========== NOISE OVERLAY ========== */
    .noise-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 9999;
      opacity: 0.035;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
      background-size: 150px 150px;
      animation: noiseAnim 0.08s steps(2) infinite;
    }

    @keyframes noiseAnim {
      0% { transform: translate(0,0); }
      25% { transform: translate(-2px, 1px); }
      50% { transform: translate(1px, -2px); }
      75% { transform: translate(2px, 1px); }
      100% { transform: translate(-1px, 2px); }
    }

    /* ========== VIGNETTE ========== */
    .vignette {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 9998;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.92) 100%);
    }

    /* ========== MAIN MENU ========== */
    #main-menu {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--darker-bg);
      overflow: hidden;
    }

    .menu-bg {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background:
        radial-gradient(ellipse at 50% 30%, rgba(90, 0, 0, 0.18) 0%, transparent 70%),
        radial-gradient(ellipse at 20% 80%, rgba(60, 0, 0, 0.12) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 60%, rgba(80, 0, 0, 0.1) 0%, transparent 50%),
        linear-gradient(180deg, #020002 0%, #050004 40%, #060002 100%);
      animation: bgBreath 8s ease-in-out infinite;
    }

    @keyframes bgBreath {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }

    .menu-fog {
      position: absolute;
      bottom: 0; left: 0;
      width: 100%; height: 45%;
      background: linear-gradient(0deg, rgba(8,0,0,0.95) 0%, rgba(12,2,2,0.6) 40%, transparent 100%);
      animation: fogDrift 12s ease-in-out infinite alternate;
    }

    @keyframes fogDrift {
      0% { transform: translateX(-3%) scaleY(1); opacity: 0.8; }
      100% { transform: translateX(3%) scaleY(1.08); opacity: 1; }
    }

    .menu-particles {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }

    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: var(--blood-red);
      border-radius: 50%;
      opacity: 0;
      animation: particleFall linear infinite;
    }

    @keyframes particleFall {
      0% { transform: translateY(-10px) translateX(0); opacity: 0; }
      10% { opacity: 0.6; }
      90% { opacity: 0.3; }
      100% { transform: translateY(100vh) translateX(20px); opacity: 0; }
    }

    .menu-cross {
      position: absolute;
      font-size: 14vw;
      color: rgba(80, 0, 0, 0.06);
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) rotate(15deg);
      pointer-events: none;
      animation: crossPulse 6s ease-in-out infinite;
      font-family: 'UnifrakturMaguntia', cursive;
      white-space: nowrap;
    }

    @keyframes crossPulse {
      0%, 100% { opacity: 0.4; transform: translate(-50%, -50%) rotate(15deg) scale(1); }
      50% { opacity: 0.7; transform: translate(-50%, -50%) rotate(15deg) scale(1.03); }
    }

    .menu-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
      padding: 20px;
      max-width: 600px;
      width: 100%;
    }

    .game-title-wrap {
      text-align: center;
      margin-bottom: 8px;
    }

    .game-title-pre {
      font-family: 'Crimson Text', serif;
      font-style: italic;
      font-size: clamp(0.7rem, 2vw, 0.95rem);
      color: var(--text-dim);
      letter-spacing: 0.4em;
      text-transform: uppercase;
      margin-bottom: 6px;
      display: block;
      animation: flicker 4s ease-in-out infinite;
    }

    @keyframes flicker {
      0%, 95%, 100% { opacity: 1; }
      96% { opacity: 0.3; }
      97% { opacity: 1; }
      98% { opacity: 0.2; }
      99% { opacity: 1; }
    }

    .game-title {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(1.6rem, 5.5vw, 3.2rem);
      font-weight: 900;
      color: var(--text-primary);
      text-shadow:
        0 0 20px rgba(139, 0, 0, 0.8),
        0 0 40px rgba(139, 0, 0, 0.4),
        0 0 80px rgba(139, 0, 0, 0.2),
        2px 2px 4px rgba(0,0,0,0.9);
      letter-spacing: 0.05em;
      line-height: 1.1;
      animation: titleGlow 3s ease-in-out infinite;
    }

    @keyframes titleGlow {
      0%, 100% { text-shadow: 0 0 20px rgba(139,0,0,0.8), 0 0 40px rgba(139,0,0,0.4), 0 0 80px rgba(139,0,0,0.2), 2px 2px 4px rgba(0,0,0,0.9); }
      50% { text-shadow: 0 0 30px rgba(180,0,0,1), 0 0 60px rgba(139,0,0,0.6), 0 0 100px rgba(100,0,0,0.3), 2px 2px 4px rgba(0,0,0,0.9); }
    }

    .game-subtitle {
      font-family: 'Crimson Text', serif;
      font-style: italic;
      font-size: clamp(0.85rem, 2.5vw, 1.15rem);
      color: var(--crimson);
      margin-top: 10px;
      letter-spacing: 0.15em;
      animation: subtitlePulse 5s ease-in-out infinite;
      text-shadow: 0 0 10px rgba(220, 20, 60, 0.5);
    }

    @keyframes subtitlePulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    .menu-divider {
      width: 80%;
      max-width: 300px;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--blood-red), transparent);
      margin: 20px 0;
      position: relative;
      animation: dividerGlow 3s ease-in-out infinite;
    }

    .menu-divider::before {
      content: 'â';
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: var(--blood-red);
      font-size: 0.9rem;
      background: var(--darker-bg);
      padding: 0 8px;
    }

    @keyframes dividerGlow {
      0%, 100% { box-shadow: 0 0 6px rgba(139,0,0,0.3); }
      50% { box-shadow: 0 0 12px rgba(139,0,0,0.7); }
    }

    .player-name-row {
      width: 100%;
      max-width: 300px;
      margin-bottom: 16px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .input-label {
      font-family: 'Crimson Text', serif;
      font-size: 0.75rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.2em;
    }

    .horror-input {
      width: 100%;
      background: rgba(10, 0, 0, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.5);
      border-bottom: 2px solid var(--blood-red);
      color: var(--text-primary);
      font-family: 'Crimson Text', serif;
      font-size: 1rem;
      padding: 10px 14px;
      outline: none;
      transition: all 0.3s;
      letter-spacing: 0.05em;
    }

    .horror-input:focus {
      border-color: var(--crimson);
      background: rgba(20, 0, 0, 0.9);
      box-shadow: 0 0 15px rgba(139, 0, 0, 0.3), inset 0 0 10px rgba(50,0,0,0.2);
    }

    .horror-input::placeholder {
      color: var(--text-dim);
      opacity: 0.6;
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      max-width: 300px;
      align-items: center;
    }

    .btn-horror {
      width: 100%;
      padding: 14px 28px;
      background: linear-gradient(135deg, rgba(30,0,0,0.95) 0%, rgba(10,0,0,0.98) 100%);
      border: 1px solid rgba(139, 0, 0, 0.5);
      border-bottom: 2px solid var(--blood-red);
      color: var(--text-primary);
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(0.65rem, 1.8vw, 0.85rem);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.25s ease;
      position: relative;
      overflow: hidden;
      text-shadow: 0 0 8px rgba(139, 0, 0, 0.4);
      outline: none;
    }

    .btn-horror::before {
      content: '';
      position: absolute;
      top: 0; left: -100%;
      width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(139,0,0,0.15), transparent);
      transition: left 0.4s ease;
    }

    .btn-horror:hover::before {
      left: 100%;
    }

    .btn-horror:hover {
      background: linear-gradient(135deg, rgba(60,0,0,0.95) 0%, rgba(25,0,0,0.98) 100%);
      border-color: var(--crimson);
      color: #e8c8a0;
      box-shadow: 0 0 20px rgba(139, 0, 0, 0.4), inset 0 0 10px rgba(80,0,0,0.2);
      transform: translateY(-1px);
    }

    .btn-horror:active {
      transform: translateY(1px);
      box-shadow: 0 0 8px rgba(139, 0, 0, 0.3);
    }

    .btn-horror.secondary {
      border-color: rgba(80,60,40,0.5);
      border-bottom-color: rgba(120,90,60,0.7);
      font-size: clamp(0.6rem, 1.5vw, 0.75rem);
      padding: 10px 20px;
      color: var(--text-dim);
    }

    .btn-horror.secondary:hover {
      border-color: var(--text-dim);
      color: var(--text-primary);
      box-shadow: 0 0 12px rgba(100,80,50,0.2);
    }

    .btn-horror.danger {
      border-color: rgba(180, 0, 0, 0.7);
      border-bottom-color: var(--crimson);
      color: #ff8080;
    }

    .btn-horror.danger:hover {
      background: linear-gradient(135deg, rgba(80,0,0,0.95) 0%, rgba(40,0,0,0.98) 100%);
      box-shadow: 0 0 25px rgba(220, 20, 60, 0.5);
      color: #ffaaaa;
    }

    .menu-version {
      position: absolute;
      bottom: 12px;
      right: 16px;
      font-size: 0.65rem;
      color: rgba(80,60,40,0.4);
      letter-spacing: 0.1em;
    }

    /* ========== LOADING SCREEN ========== */
    #loading-screen {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--darker-bg);
      z-index: 100;
    }

    .loading-bg {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background:
        radial-gradient(ellipse at 50% 50%, rgba(50,0,0,0.15) 0%, transparent 70%),
        linear-gradient(180deg, #020002 0%, #030003 100%);
      animation: bgBreath 4s ease-in-out infinite;
    }

    .loading-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
      padding: 20px;
      text-align: center;
      max-width: 500px;
      width: 100%;
    }

    .loading-symbol {
      font-family: 'UnifrakturMaguntia', cursive;
      font-size: clamp(3rem, 10vw, 5rem);
      color: var(--blood-red);
      text-shadow: 0 0 20px rgba(139,0,0,0.8), 0 0 40px rgba(139,0,0,0.4);
      animation: symbolRotate 8s linear infinite;
      display: block;
      line-height: 1;
    }

    @keyframes symbolRotate {
      0% { transform: rotate(0deg); filter: brightness(0.8); }
      25% { filter: brightness(1.3); }
      50% { transform: rotate(180deg); filter: brightness(0.8); }
      75% { filter: brightness(1.5); }
      100% { transform: rotate(360deg); filter: brightness(0.8); }
    }

    .loading-title {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(1rem, 3vw, 1.4rem);
      color: var(--text-primary);
      letter-spacing: 0.1em;
      text-shadow: 0 0 15px rgba(139,0,0,0.5);
    }

    .loading-bar-wrap {
      width: 100%;
      max-width: 360px;
      height: 3px;
      background: rgba(30,0,0,0.8);
      border: 1px solid rgba(80,0,0,0.5);
      position: relative;
      overflow: hidden;
    }

    .loading-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--deep-red), var(--crimson), var(--blood-red));
      box-shadow: 0 0 10px rgba(220,20,60,0.6);
      transition: width 0.3s ease;
      position: relative;
    }

    .loading-bar-fill::after {
      content: '';
      position: absolute;
      top: 0; right: 0;
      width: 20px; height: 100%;
      background: rgba(255,255,255,0.3);
      animation: loadingShine 1s ease-in-out infinite;
    }

    @keyframes loadingShine {
      0%, 100% { opacity: 0; }
      50% { opacity: 1; }
    }

    .loading-message {
      font-family: 'Crimson Text', serif;
      font-style: italic;
      font-size: clamp(0.85rem, 2.5vw, 1rem);
      color: var(--text-dim);
      letter-spacing: 0.1em;
      min-height: 1.5em;
      animation: textFade 2s ease-in-out infinite;
    }

    @keyframes textFade {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .loading-percent {
      font-family: 'Cinzel Decorative', serif;
      font-size: 0.7rem;
      color: var(--blood-red);
      letter-spacing: 0.2em;
    }

    /* ========== LOBBY SCREEN ========== */
    #lobby-screen {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--darker-bg);
    }

    .lobby-bg {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(ellipse at 50% 50%, rgba(40,0,0,0.12) 0%, transparent 70%),
        linear-gradient(180deg, #020002 0%, #040003 100%);
    }

    .lobby-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 20px;
      width: 100%;
      max-width: 480px;
    }

    .lobby-title {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(0.9rem, 3vw, 1.3rem);
      color: var(--text-primary);
      letter-spacing: 0.15em;
      text-align: center;
      text-shadow: 0 0 15px rgba(139,0,0,0.5);
    }

    .lobby-panel {
      width: 100%;
      background: rgba(8, 0, 0, 0.9);
      border: 1px solid rgba(80,0,0,0.5);
      border-top: 2px solid var(--blood-red);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .room-code-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .room-code-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.25em;
      color: var(--text-dim);
    }

    #room-code-display {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(1.2rem, 4vw, 1.8rem);
      color: var(--crimson);
      letter-spacing: 0.4em;
      text-shadow: 0 0 15px rgba(220,20,60,0.6);
      text-align: center;
      min-height: 2rem;
      animation: codeGlow 2s ease-in-out infinite;
    }

    @keyframes codeGlow {
      0%, 100% { text-shadow: 0 0 10px rgba(220,20,60,0.5); }
      50% { text-shadow: 0 0 25px rgba(220,20,60,0.9), 0 0 40px rgba(180,0,0,0.4); }
    }

    .join-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
    }

    .join-row .horror-input {
      flex: 1;
      text-transform: uppercase;
      letter-spacing: 0.3em;
      text-align: center;
    }

    .join-row .btn-horror {
      flex: 0 0 auto;
      width: auto;
      padding: 10px 16px;
      font-size: 0.6rem;
    }

    .players-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .players-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.25em;
      color: var(--text-dim);
      border-bottom: 1px solid rgba(80,0,0,0.4);
      padding-bottom: 6px;
    }

    #player-list {
      min-height: 80px;
      max-height: 180px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .player-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(15,0,0,0.6);
      border-left: 2px solid var(--blood-red);
      font-size: 0.9rem;
      color: var(--text-primary);
    }

    .player-item .dot {
      width: 6px; height: 6px;
      border-radius: 50%;
      background: var(--green-sanity);
      box-shadow: 0 0 6px rgba(0,200,83,0.6);
      flex-shrink: 0;
    }

    .player-item.host::after {
      content: 'ANFITRIÃN';
      margin-left: auto;
      font-size: 0.6rem;
      color: var(--blood-red);
      letter-spacing: 0.15em;
    }

    .lobby-empty {
      font-style: italic;
      color: var(--text-dim);
      font-size: 0.85rem;
      text-align: center;
      padding: 20px;
    }

    .lobby-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    }

    /* ========== SETTINGS SCREEN ========== */
    #settings-screen {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--darker-bg);
    }

    .settings-bg {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(ellipse at 50% 50%, rgba(30,0,0,0.1) 0%, transparent 70%),
        linear-gradient(180deg, #020002 0%, #040003 100%);
    }

    .settings-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 20px;
      width: 100%;
      max-width: 440px;
    }

    .settings-title {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(0.9rem, 3vw, 1.3rem);
      color: var(--text-primary);
      letter-spacing: 0.15em;
      text-align: center;
      text-shadow: 0 0 15px rgba(139,0,0,0.5);
    }

    .settings-panel {
      width: 100%;
      background: rgba(8, 0, 0, 0.9);
      border: 1px solid rgba(80,0,0,0.5);
      border-top: 2px solid var(--blood-red);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .setting-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .setting-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .setting-label span:first-child {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--text-dim);
    }

    .setting-label .setting-val {
      font-family: 'Cinzel Decorative', serif;
      font-size: 0.7rem;
      color: var(--blood-red);
      letter-spacing: 0.1em;
    }

    .horror-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 3px;
      background: rgba(40,0,0,0.8);
      border: none;
      outline: none;
      cursor: pointer;
    }

    .horror-slider::-webkit-slider-track {
      height: 3px;
      background: linear-gradient(90deg, var(--blood-red), rgba(40,0,0,0.8));
      border-radius: 0;
    }

    .horror-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px; height: 14px;
      background: var(--blood-red);
      border: 1px solid var(--crimson);
      border-radius: 0;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(220,20,60,0.4);
      transition: box-shadow 0.2s;
    }

    .horror-slider::-webkit-slider-thumb:hover {
      box-shadow: 0 0 16px rgba(220,20,60,0.8);
    }

    .horror-slider::-moz-range-thumb {
      width: 14px; height: 14px;
      background: var(--blood-red);
      border: 1px solid var(--crimson);
      border-radius: 0;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(220,20,60,0.4);
    }

    .setting-checkbox-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .setting-checkbox-row label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--text-dim);
      cursor: pointer;
    }

    .horror-toggle {
      position: relative;
      width: 44px; height: 22px;
      cursor: pointer;
    }

    .horror-toggle input {
      opacity: 0;
      width: 0; height: 0;
    }

    .toggle-slider {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(20,0,0,0.8);
      border: 1px solid rgba(80,0,0,0.6);
      transition: 0.3s;
    }

    .toggle-slider::before {
      content: '';
      position: absolute;
      height: 14px; width: 14px;
      left: 3px; bottom: 3px;
      background: var(--text-dim);
      transition: 0.3s;
    }

    .horror-toggle input:checked + .toggle-slider {
      background: rgba(60,0,0,0.9);
      border-color: var(--blood-red);
    }

    .horror-toggle input:checked + .toggle-slider::before {
      transform: translateX(22px);
      background: var(--crimson);
      box-shadow: 0 0 6px rgba(220,20,60,0.6);
    }

    /* ========== PAUSE MENU ========== */
    #pause-menu {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      z-index: 50;
      backdrop-filter: blur(3px);
    }

    .pause-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 30px;
      background: rgba(5,0,0,0.95);
      border: 1px solid rgba(80,0,0,0.6);
      border-top: 3px solid var(--blood-red);
      box-shadow: 0 0 40px rgba(0,0,0,0.8), 0 0 20px rgba(80,0,0,0.2);
      width: 100%;
      max-width: 320px;
    }

    .pause-title {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(1rem, 3vw, 1.3rem);
      color: var(--text-primary);
      letter-spacing: 0.2em;
      text-shadow: 0 0 15px rgba(139,0,0,0.6);
    }

    .pause-divider {
      width: 100%;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--blood-red), transparent);
    }

    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
    }

    /* ========== DEATH SCREEN ========== */
    #death-screen {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0);
      z-index: 60;
      animation: deathFadeIn 2s ease-in forwards;
    }

    @keyframes deathFadeIn {
      0% { background: rgba(0,0,0,0); }
      100% { background: rgba(5,0,0,0.96); }
    }

    .death-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 40px 30px;
      text-align: center;
      animation: deathContentIn 2.5s ease-in forwards;
    }

    @keyframes deathContentIn {
      0%, 40% { opacity: 0; transform: scale(0.95); }
      100% { opacity: 1; transform: scale(1); }
    }

    .death-symbol {
      font-family: 'UnifrakturMaguntia', cursive;
      font-size: clamp(3rem, 12vw, 6rem);
      color: var(--blood-red);
      text-shadow:
        0 0 20px rgba(139,0,0,0.9),
        0 0 40px rgba(139,0,0,0.5),
        0 0 80px rgba(80,0,0,0.3);
      animation: deathSymbolPulse 2s ease-in-out infinite;
      display: block;
      line-height: 1;
    }

    @keyframes deathSymbolPulse {
      0%, 100% { transform: scale(1); filter: brightness(0.8); }
      50% { transform: scale(1.05); filter: brightness(1.4); }
    }

    .death-title {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(1.5rem, 5vw, 2.5rem);
      color: var(--crimson);
      letter-spacing: 0.15em;
      text-shadow: 0 0 20px rgba(220,20,60,0.7), 0 0 40px rgba(139,0,0,0.4);
      font-weight: 900;
    }

    .death-message {
      font-family: 'Crimson Text', serif;
      font-style: italic;
      font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      color: var(--text-dim);
      max-width: 360px;
      line-height: 1.6;
      letter-spacing: 0.05em;
    }

    .death-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      max-width: 280px;
      margin-top: 10px;
    }

    /* ========== GAME CONTAINER ========== */
    #game-container {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
      background: #000;
      display: none;
    }

    #game-container canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }

    /* ========== HUD OVERLAY ========== */
    #hud-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 20;
      pointer-events: none;
      display: none;
    }

    /* Sanity Panel */
    .hud-sanity {
      position: absolute;
      top: 16px; left: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: clamp(120px, 20vw, 180px);
    }

    .hud-bar-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .hud-bar-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .hud-bar-name {
      font-size: clamp(0.55rem, 1.5vw, 0.65rem);
      text-transform: uppercase;
      letter-spacing: 0.25em;
      color: rgba(140,110,80,0.7);
      font-family: 'Crimson Text', serif;
    }

    .hud-bar-val {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(0.55rem, 1.3vw, 0.65rem);
      color: rgba(180,140,100,0.8);
    }

    .hud-bar-track {
      width: 100%;
      height: 4px;
      background: rgba(10,0,0,0.7);
      border: 1px solid rgba(50,0,0,0.5);
      position: relative;
      overflow: hidden;
    }

    #sanity-bar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, var(--green-sanity), #00e676);
      box-shadow: 0 0 6px rgba(0,200,83,0.5);
      transition: width 0.5s ease, background 0.5s ease, box-shadow 0.5s ease;
      position: relative;
    }

    #sanity-bar::after {
      content: '';
      position: absolute;
      top: 0; right: 0;
      width: 4px; height: 100%;
      background: rgba(255,255,255,0.4);
      animation: barShimmer 1.5s ease-in-out infinite;
    }

    @keyframes barShimmer {
      0%, 100% { opacity: 0; }
      50% { opacity: 1; }
    }

    #stamina-bar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #1565c0, #42a5f5);
      box-shadow: 0 0 6px rgba(21,101,192,0.5);
      transition: width 0.2s ease;
      position: relative;
    }

    /* Crosshair */
    .hud-crosshair {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 20px; height: 20px;
      pointer-events: none;
    }

    .crosshair-h, .crosshair-v {
      position: absolute;
      background: rgba(255,255,255,0.6);
    }

    .crosshair-h {
      width: 14px; height: 1px;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
    }

    .crosshair-v {
      width: 1px; height: 14px;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
    }

    .crosshair-dot {
      position: absolute;
      width: 2px; height: 2px;
      background: rgba(255,255,255,0.9);
      border-radius: 50%;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
    }

    /* Objective */
    .hud-objective {
      position: absolute;
      top: 16px; right: 16px;
      max-width: clamp(140px, 30vw, 240px);
      background: rgba(4,0,0,0.7);
      border-left: 2px solid var(--blood-red);
      padding: 8px 12px;
      backdrop-filter: blur(2px);
    }

    .obj-label {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.25em;
      color: var(--blood-red);
      margin-bottom: 4px;
      display: block;
    }

    #objective-text {
      font-family: 'Crimson Text', serif;
      font-size: clamp(0.75rem, 2vw, 0.85rem);
      color: var(--text-primary);
      line-height: 1.4;
      letter-spacing: 0.02em;
    }

    /* Inventory */
    .hud-inventory {
      position: absolute;
      bottom: 80px; left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
    }

    #item-slots {
      display: flex;
      gap: 6px;
    }

    .item-slot {
      width: clamp(36px, 6vw, 48px);
      height: clamp(36px, 6vw, 48px);
      background: rgba(5,0,0,0.8);
      border: 1px solid rgba(60,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(0.9rem, 2vw, 1.2rem);
      color: var(--text-dim);
      transition: all 0.2s;
      position: relative;
    }

    .item-slot.active {
      border-color: var(--blood-red);
      box-shadow: 0 0 10px rgba(139,0,0,0.4);
    }

    .item-slot.filled {
      border-color: rgba(139,0,0,0.6);
      background: rgba(20,0,0,0.9);
    }

    /* Interaction Prompt */
    #interaction-prompt {
      position: absolute;
      bottom: 28%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(4,0,0,0.85);
      border: 1px solid rgba(139,0,0,0.6);
      padding: 8px 18px;
      font-family: 'Crimson Text', serif;
      font-size: clamp(0.75rem, 2vw, 0.9rem);
      color: var(--text-primary);
      letter-spacing: 0.1em;
      text-align: center;
      display: none;
      animation: promptPulse 1.5s ease-in-out infinite;
      white-space: nowrap;
      pointer-events: none;
      backdrop-filter: blur(2px);
    }

    @keyframes promptPulse {
      0%, 100% { border-color: rgba(139,0,0,0.5); box-shadow: none; }
      50% { border-color: rgba(220,20,60,0.8); box-shadow: 0 0 10px rgba(139,0,0,0.3); }
    }

    #interaction-prompt .key-hint {
      font-family: 'Cinzel Decorative', serif;
      font-size: 0.65rem;
      color: var(--blood-red);
      margin-right: 6px;
      border: 1px solid var(--blood-red);
      padding: 1px 5px;
    }

    /* Subtitles */
    #subtitle-text {
      position: absolute;
      bottom: 12%;
      left: 50%;
      transform: translateX(-50%);
      max-width: 70%;
      background: rgba(0,0,0,0.75);
      padding: 8px 16px;
      font-family: 'Crimson Text', serif;
      font-style: italic;
      font-size: clamp(0.8rem, 2.2vw, 1rem);
      color: #d4c4aa;
      text-align: center;
      line-height: 1.5;
      display: none;
      letter-spacing: 0.03em;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
      pointer-events: none;
    }

    /* Sanity vignette effect */
    .hud-sanity-vignette {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      border-radius: 0;
      opacity: 0;
      transition: opacity 1s ease;
      background: radial-gradient(ellipse at center, transparent 50%, rgba(80,0,0,0.6) 100%);
    }

    /* ========== MOBILE CONTROLS ========== */
    #mobile-controls {
      position: fixed;
      bottom: 0; left: 0;
      width: 100%; height: 200px;
      z-index: 25;
      pointer-events: none;
      display: none;
    }

    #joystick-zone {
      position: absolute;
      bottom: 20px; left: 20px;
      width: 120px; height: 120px;
      background: rgba(5,0,0,0.5);
      border: 2px solid rgba(80,0,0,0.5);
      border-radius: 50%;
      pointer-events: auto;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .joystick-inner {
      width: 50px; height: 50px;
      background: rgba(139,0,0,0.7);
      border: 2px solid var(--blood-red);
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(139,0,0,0.4);
      transition: transform 0.05s;
      pointer-events: none;
    }

    .mobile-btn-group {
      position: absolute;
      bottom: 20px; right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-end;
    }

    .mobile-btn-row {
      display: flex;
      gap: 10px;
    }

    .btn-mobile {
      width: 54px; height: 54px;
      background: rgba(5,0,0,0.75);
      border: 2px solid rgba(100,0,0,0.7);
      border-radius: 50%;
      color: var(--text-primary);
      font-size: 0.6rem;
      font-family: 'Cinzel Decorative', serif;
      letter-spacing: 0.05em;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      touch-action: none;
      cursor: pointer;
      transition: all 0.15s;
      flex-direction: column;
      gap: 2px;
      line-height: 1.1;
    }

    .btn-mobile:active {
      background: rgba(30,0,0,0.9);
      border-color: var(--crimson);
      box-shadow: 0 0 12px rgba(139,0,0,0.5);
      transform: scale(0.95);
    }

    .btn-mobile .mobile-icon {
      font-size: 1.1rem;
      line-height: 1;
    }

    .btn-mobile .mobile-label {
      font-size: 0.45rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* ========== BLOOD DRIP EFFECT ========== */
    .blood-drip {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 60px;
      pointer-events: none;
      z-index: 9997;
      overflow: hidden;
      display: none;
    }

    .drip {
      position: absolute;
      top: -10px;
      width: 3px;
      background: linear-gradient(180deg, var(--blood-red), var(--crimson));
      border-radius: 0 0 50% 50%;
      transform-origin: top center;
      animation: dripDown 3s ease-in infinite;
      opacity: 0;
    }

    @keyframes dripDown {
      0% { height: 0; opacity: 0; top: 0; }
      20% { opacity: 0.8; }
      80% { opacity: 0.6; }
      100% { height: 60px; opacity: 0; top: 0; }
    }

    /* ========== HALLUCINATION OVERLAY ========== */
    .hallucination-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 30;
      opacity: 0;
      background: radial-gradient(ellipse at 50% 50%, rgba(100,0,0,0.08) 0%, transparent 70%);
      transition: opacity 2s ease;
      mix-blend-mode: overlay;
    }

    /* ========== AMBIENT FLICKER ========== */
    .screen-flicker {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 9996;
      background: rgba(255,255,255,0);
      animation: screenFlicker 0.08s steps(1) infinite;
      opacity: 0;
    }

    @keyframes screenFlicker {
      0%, 97%, 100% { opacity: 0; }
      98% { opacity: 0.015; background: rgba(200,180,150,0.015); }
      99% { opacity: 0; }
    }

    /* ========== RESPONSIVE ========== */
    @media (max-width: 480px) {
      .menu-content {
        padding: 16px;
        gap: 0;
      }

      .btn-horror {
        padding: 12px 20px;
      }

      .lobby-content,
      .settings-content {
        padding: 12px;
        gap: 12px;
      }

      .settings-panel,
      .lobby-panel {
        padding: 14px;
      }

      .pause-content {
        padding: 20px;
        margin: 0 16px;
      }
    }

    @media (max-height: 600px) {
      .menu-content {
        gap: 4px;
      }

      .menu-divider {
        margin: 10px 0;
      }

      .menu-buttons {
        gap: 8px;
      }
    }

    @media (hover: none) and (pointer: coarse) {
      #mobile-controls {
        display: block;
        pointer-events: auto;
      }

      .hud-inventory {
        bottom: 210px;
      }
    }

    /* ========== TRANSITIONS ========== */
    .screen-transition {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: var(--darker-bg);
      z-index: 9995;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .screen-transition.active {
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- Ambient overlays -->
  <div class="noise-overlay"></div>
  <div class="vignette"></div>
  <div class="screen-flicker"></div>
  <div class="hallucination-overlay" id="hallucination-layer"></div>
  <div class="blood-drip" id="blood-drip-container"></div>
  <div class="screen-transition" id="screen-transition"></div>

  <!-- ========== LOADING SCREEN ========== -->
  <div id="loading-screen" class="screen active">
    <div class="loading-bg"></div>
    <div class="loading-content">
      <span class="loading-symbol">â©</span>
      <div class="game-title-wrap">
        <span class="game-title-pre">Cargando</span>
        <h1 class="game-title">El Susurro<br>de la Inocente</h1>
      </div>
      <div class="loading-bar-wrap">
        <div class="loading-bar-fill" id="loading-bar"></div>
      </div>
      <p class="loading-percent" id="loading-percent">0%</p>
      <p class="loading-message" id="loading-message">Preparando las sombras...</p>
    </div>
  </div>

  <!-- ========== MAIN MENU ========== -->
  <div id="main-menu" class="screen">
    <div class="menu-bg"></div>
    <div class="menu-fog"></div>
    <div class="menu-cross">â </div>
    <div class="menu-particles" id="menu-particles"></div>
    <div class="menu-content">
      <div class="game-title-wrap">
        <span class="game-title-pre">Orfanato Valdecasa â 1987</span>
        <h1 class="game-title">El Susurro<br>de la Inocente</h1>
        <p class="game-subtitle">"Ella sabe lo que hiciste"</p>
      </div>
      <div class="menu-divider"></div>
      <div class="player-name-row">
        <label class="input-label" for="input-player-name">Nombre del explorador</label>
        <input
          type="text"
          id="input-player-name"
          class="horror-input"
          placeholder="AnÃ³nimo..."
          maxlength="20"
          autocomplete="off"
          spellcheck="false"
        >
      </div>
      <div class="menu-buttons">
        <button id="btn-solo" class="btn-horror">â Explorar Solo</button>
        <button id="btn-multiplayer" class="btn-horror">â© Cooperativo</button>
        <button id="btn-settings" class="btn-horror secondary">â Ajustes</button>
      </div>
    </div>
    <span class="menu-version">v1.0.0 â ANIMA</span>
  </div>

  <!-- ========== LOBBY SCREEN ========== -->
  <div id="lobby-screen" class="screen">
    <div class="lobby-bg"></div>
    <div class="lobby-content">
      <h2 class="lobby-title">â© Sala de InvocaciÃ³n</h2>
      <div class="lobby-panel">
        <div class="room-code-section">
          <span class="room-code-label">CÃ³digo de la sala</span>
          <div id="room-code-display">â â â â</div>
        </div>
        <div class="join-row">
          <input
            type="text"
            id="input-room-code"
            class="horror-input"
            placeholder="CÃDIGO"
            maxlength="6"
            autocomplete="off"
            spellcheck="false"
          >
          <button id="btn-join-room" class="btn-horror">Unirse</button>
        </div>
        <button id="btn-create-room" class="btn-horror">Crear Sala</button>
      </div>
      <div class="lobby-panel players-section">
        <span class="players-label">Almas presentes</span>
        <div id="player-list">
          <p class="lobby-empty">Esperando en las sombras...</p>
        </div>
      </div>
      <div class="lobby-buttons">
        <button id="btn-start-game" class="btn-horror danger" style="display:none;">â Iniciar Ritual</button>
        <button id="btn-back-lobby" class="btn-horror secondary">â Volver</button>
      </div>
    </div>
  </div>

  <!-- ========== SETTINGS SCREEN ========== -->
  <div id="settings-screen" class="screen">
    <div class="settings-bg"></div>
    <div class="settings-content">
      <h2 class="settings-title">â Ajustes</h2>
      <div class="settings-panel">
        <div class="setting-row">
          <div class="setting-label">
            <span>Volumen</span>
            <span class="setting-val" id="vol-val">80%</span>
          </div>
          <input
            type="range"
            id="slider-volume"
            class="horror-slider"
            min="0" max="100" value="80"
          >
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <span>Sensibilidad</span>
            <span class="setting-val" id="sens-val">50%</span>
          </div>
          <input
            type="range"
            id="slider-sensitivity"
            class="horror-slider"
            min="1" max="100" value="50"
          >
        </div>
        <div class="setting-row">
          <div class="setting-label">
            <span>Brillo</span>
            <span class="setting-val" id="bright-val">50%</span>
          </div>
          <input
            type="range"
            id="slider-brightness"
            class="horror-slider"
            min="0" max="100" value="50"
          >
        </div>
        <div class="setting-checkbox-row">
          <label for="toggle-fullscreen">Pantalla Completa</label>
          <label class="horror-toggle">
            <input type="checkbox" id="toggle-fullscreen">
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>
      <button id="btn-back-settings" class="btn-horror secondary" style="width:100%; max-width:400px;">â Volver</button>
    </div>
  </div>

  <!-- ========== PAUSE MENU ========== -->
  <div id="pause-menu" class="screen">
    <div class="pause-content">
      <h2 class="pause-title">â Pausa â</h2>
      <div class="pause-divider"></div>
      <div class="pause-buttons">
        <button id="btn-resume" class="btn-horror">â¶ Continuar</button>
        <button id="btn-quit" class="btn-horror secondary">â MenÃº Principal</button>
      </div>
    </div>
  </div>

  <!-- ========== DEATH SCREEN ========== -->
  <div id="death-screen" class="screen">
    <div class="death-content">
      <span class="death-symbol">â©</span>
      <h2 class="death-title">Has Perecido</h2>
      <p class="death-message" id="death-message">
        ANIMA te ha encontrado. La inocente ahora conoce tu nombre.
      </p>
      <div class="death-buttons">
        <button id="btn-retry" class="btn-horror danger">âº Intentar de Nuevo</button>
        <button id="btn-quit-death" class="btn-horror secondary">â MenÃº Principal</button>
      </div>
    </div>
  </div>

  <!-- ========== GAME CONTAINER ========== -->
  <div id="game-container"></div>

  <!-- ========== HUD OVERLAY ========== -->
  <div id="hud-overlay">
    <!-- Sanity & Stamina -->
    <div class="hud-sanity">
      <div class="hud-bar-group">
        <div class="hud-bar-label">
          <span class="hud-bar-name">Cordura</span>
          <span class="hud-bar-val" id="sanity-value">100%</span>
        </div>
        <div class="hud-bar-track">
          <div id="sanity-bar"></div>
        </div>
      </div>
      <div class="hud-bar-group">
        <div class="hud-bar-label">
          <span class="hud-bar-name">Stamina</span>
        </div>
        <div class="hud-bar-track">
          <div id="stamina-bar"></div>
        </div>
      </div>
    </div>

    <!-- Objective -->
    <div class="hud-objective">
      <span class="obj-label">Objetivo</span>
      <div id="objective-text">Explora el orfanato</div>
    </div>

    <!-- Crosshair -->
    <div class="hud-crosshair">
      <div class="crosshair-h"></div>
      <div class="crosshair-v"></div>
      <div class="crosshair-dot"></div>
    </div>

    <!-- Inventory -->
    <div class="hud-inventory">
      <div id="item-slots">
        <div class="item-slot active" data-slot="0">Â·</div>
        <div class="item-slot" data-slot="1">Â·</div>
        <div class="item-slot" data-slot="2">Â·</div>
        <div class="item-slot" data-slot="3">Â·</div>
      </div>
    </div>

    <!-- Interaction Prompt -->
    <div id="interaction-prompt">
      <span class="key-hint">E</span>
      <span id="interaction-text">Examinar</span>
    </div>

    <!-- Subtitles -->
    <div id="subtitle-text"></div>

    <!-- Sanity vignette -->
    <div class="hud-sanity-vignette" id="sanity-vignette"></div>
  </div>

  <!-- ========== MOBILE CONTROLS ========== -->
  <div id="mobile-controls">
    <div id="joystick-zone">
      <div class="joystick-inner" id="joystick-thumb"></div>
    </div>
    <div class="mobile-btn-group">
      <div class="mobile-btn-row">
        <button id="btn-mobile-flashlight" class="btn-mobile">
          <span class="mobile-icon">ð¦</span>
          <span class="mobile-label">Linterna</span>
        </button>
        <button id="btn-mobile-sprint" class="btn-mobile">
          <span class="mobile-icon">â¡</span>
          <span class="mobile-label">Correr</span>
        </button>
      </div>
      <div class="mobile-btn-row">
        <button id="btn-mobile-interact" class="btn-mobile">
          <span class="mobile-icon">ð</span>
          <span class="mobile-label">Interactuar</span>
        </button>
      </div>
    </div>
  </div>


    <!-- Sanity visual effects -->
    <div id="sanity-aberration" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:50;display:none;"></div>
    <div id="sanity-hallucination" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:51;display:none;"></div>
    
    <!-- Chat log in lobby -->
    <div id="chat-log" style="position:absolute;bottom:60px;left:50%;transform:translateX(-50%);width:400px;max-height:150px;overflow-y:auto;background:rgba(0,0,0,0.7);border:1px solid rgba(139,0,0,0.4);border-radius:4px;padding:8px;font-size:12px;color:#c9a87c;display:none;"></div>

    
<script>
// ============================================================
// SECTION 2: GAME ENGINE (Three.js)
// ============================================================
try {
window.GameEngine = (function() {
    'use strict';

    // Internal state
    var scene, camera, renderer, clock, player, flashlight, animationId;
    var flickeringLights = [];
    var rooms = {};
    var collisionWalls = [];
    var isPointerLocked = false;
    var yaw = 0, pitch = 0;
    var velocity = new THREE.Vector3();
    var onGround = false;
    var gravity = -20;
    var jumpForce = 8;
    var playerHeight = 1.7;
    var flashlightOn = true;
    var lastFKey = false;

    // Procedural texture generators
    function createWoodTexture() {
        try {
            var canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = '#2a1a0e';
            ctx.fillRect(0, 0, 256, 256);
            for (var i = 0; i < 20; i++) {
                var y = (i / 20) * 256;
                ctx.strokeStyle = 'rgba(' + (Math.floor(Math.random()*30)+20) + ',' + (Math.floor(Math.random()*15)+8) + ',4,0.6)';
                ctx.lineWidth = 3 + Math.random() * 5;
                ctx.beginPath();
                ctx.moveTo(0, y + Math.random() * 10);
                ctx.lineTo(256, y + Math.random() * 10);
                ctx.stroke();
            }
            for (var j = 0; j < 300; j++) {
                ctx.fillStyle = 'rgba(' + (Math.floor(Math.random()*20)) + ',' + (Math.floor(Math.random()*10)) + ',0,' + (0.1 + Math.random() * 0.3) + ')';
                ctx.fillRect(Math.random()*256, Math.random()*256, 2+Math.random()*4, 1+Math.random()*2);
            }
            var tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(3, 3);
            return tex;
        } catch(e) { console.error('createWoodTexture error:', e); return null; }
    }

    function createStoneTexture() {
        try {
            var canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 256, 256);
            for (var i = 0; i < 40; i++) {
                var x = Math.random() * 256;
                var y = Math.random() * 256;
                var w = 20 + Math.random() * 60;
                var h = 15 + Math.random() * 30;
                var gray = Math.floor(20 + Math.random() * 35);
                ctx.fillStyle = 'rgb('+gray+','+gray+','+Math.floor(gray*0.9)+')';
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = '#0a0a0a';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, w, h);
            }
            for (var j = 0; j < 500; j++) {
                var gray2 = Math.floor(Math.random()*15);
                ctx.fillStyle = 'rgba('+gray2+','+gray2+','+gray2+',0.4)';
                ctx.fillRect(Math.random()*256, Math.random()*256, 1+Math.random()*3, 1+Math.random()*3);
            }
            var tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(4, 4);
            return tex;
        } catch(e) { console.error('createStoneTexture error:', e); return null; }
    }

    function createPlasterTexture() {
        try {
            var canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1c1a18';
            ctx.fillRect(0, 0, 256, 256);
            for (var i = 0; i < 200; i++) {
                var x = Math.random() * 256;
                var y = Math.random() * 256;
                var v = Math.floor(18 + Math.random() * 20);
                ctx.fillStyle = 'rgba('+v+','+Math.floor(v*0.95)+','+Math.floor(v*0.85)+',0.5)';
                ctx.fillRect(x, y, 2+Math.random()*8, 1+Math.random()*4);
            }
            // crack lines
            for (var j = 0; j < 8; j++) {
                ctx.strokeStyle = 'rgba(5,5,5,0.8)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                var sx = Math.random()*256, sy = Math.random()*256;
                ctx.moveTo(sx, sy);
                for (var k = 0; k < 5; k++) {
                    sx += (Math.random()-0.5)*40;
                    sy += (Math.random()-0.5)*40;
                    ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
            var tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(4, 2);
            return tex;
        } catch(e) { console.error('createPlasterTexture error:', e); return null; }
    }

    function createFloorTexture() {
        try {
            var canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = '#111008';
            ctx.fillRect(0, 0, 256, 256);
            // tiles
            for (var row = 0; row < 8; row++) {
                for (var col = 0; col < 8; col++) {
                    var v = Math.floor(12 + Math.random() * 18);
                    ctx.fillStyle = 'rgb('+v+','+(Math.floor(v*0.95))+','+(Math.floor(v*0.7))+')';
                    ctx.fillRect(col*32+1, row*32+1, 30, 30);
                }
            }
            ctx.strokeStyle = '#080806';
            ctx.lineWidth = 2;
            for (var i = 0; i <= 8; i++) {
                ctx.beginPath(); ctx.moveTo(i*32,0); ctx.lineTo(i*32,256); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,i*32); ctx.lineTo(256,i*32); ctx.stroke();
            }
            var tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(4, 4);
            return tex;
        } catch(e) { console.error('createFloorTexture error:', e); return null; }
    }

    // Cache textures
    var textures = {};
    function getTextures() {
        try {
            textures.wood = createWoodTexture();
            textures.stone = createStoneTexture();
            textures.plaster = createPlasterTexture();
            textures.floor = createFloorTexture();
        } catch(e) { console.error('getTextures error:', e); }
    }

    function makeMat(type, color) {
        try {
            var tex = textures[type] || null;
            return new THREE.MeshLambertMaterial({
                map: tex,
                color: color || 0xffffff
            });
        } catch(e) { return new THREE.MeshLambertMaterial({ color: 0x333333 }); }
    }

    // Build a room segment
    // roomDef: { id, x, z, w, d, h, doors: [{side:'north'|south|east|west, offset}] }
    function buildRoom(roomDef) {
        try {
            var x = roomDef.x, z = roomDef.z;
            var w = roomDef.w || 10, d = roomDef.d || 10, h = roomDef.h || 3.5;
            var doors = roomDef.doors || [];
            var group = new THREE.Group();
            group.name = roomDef.id;

            var floorMat = makeMat('floor');
            var ceilMat = makeMat('plaster', 0x111111);
            var wallMat = makeMat('plaster');
            var stoneMat = makeMat('stone');

            // Floor
            var floorGeo = new THREE.PlaneGeometry(w, d);
            var floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0, 0);
            floor.receiveShadow = true;
            group.add(floor);

            // Ceiling
            var ceilGeo = new THREE.PlaneGeometry(w, d);
            var ceil = new THREE.Mesh(ceilGeo, ceilMat);
            ceil.rotation.x = Math.PI / 2;
            ceil.position.set(0, h, 0);
            ceil.receiveShadow = true;
            group.add(ceil);

            // Door opening size
            var doorW = 1.5, doorH = 2.4;

            // Helper: build wall with optional door cutout
            function buildWall(side) {
                try {
                    var doorDef = null;
                    for (var i = 0; i < doors.length; i++) {
                        if (doors[i].side === side) { doorDef = doors[i]; break; }
                    }
                    var isNS = (side === 'north' || side === 'south');
                    var wallLength = isNS ? w : d;
                    var wallZ = isNS ? (side === 'north' ? -d/2 : d/2) : 0;
                    var wallX = !isNS ? (side === 'west' ? -w/2 : w/2) : 0;
                    var rotY = isNS ? 0 : Math.PI/2;

                    if (!doorDef) {
                        // Solid wall
                        var geo = new THREE.BoxGeometry(wallLength, h, 0.15);
                        var mat = (side === 'west' || side === 'east') ? stoneMat : wallMat;
                        var mesh = new THREE.Mesh(geo, mat);
                        mesh.position.set(wallX, h/2, wallZ);
                        mesh.rotation.y = rotY;
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        group.add(mesh);

                        // Register collision
                        var worldX = x + wallX * Math.cos(rotY) - wallZ * Math.sin(rotY);
                        var worldZ = z + wallX * Math.sin(rotY) + wallZ * Math.cos(rotY);
                        collisionWalls.push({
                            minX: x + (isNS ? -w/2 : (side==='west'?-w/2-0.15:-0.15)),
                            maxX: x + (isNS ? w/2 : (side==='west'?-w/2+0.15:w/2+0.15)),
                            minZ: z + (!isNS ? -d/2 : (side==='north'?-d/2-0.15:-0.15)),
                            maxZ: z + (!isNS ? d/2 : (side==='north'?-d/2+0.15:d/2+0.15))
                        });
                    } else {
                        // Wall with door: 3 segments (left, right, top)
                        var offset = doorDef.offset || 0;
                        var leftW = (wallLength/2 - doorW/2) + offset;
                        var rightW = (wallLength/2 - doorW/2) - offset;
                        var doorCenterLocal = offset;

                        if (leftW > 0.05) {
                            var lGeo = new THREE.BoxGeometry(leftW, h, 0.15);
                            var lMesh = new THREE.Mesh(lGeo, wallMat);
                            var lOffset = -wallLength/2 + leftW/2;
                            if (isNS) lMesh.position.set(lOffset, h/2, wallZ);
                            else lMesh.position.set(wallX, h/2, -wallLength/2 + leftW/2);
                            lMesh.rotation.y = rotY;
                            lMesh.castShadow = true; lMesh.receiveShadow = true;
                            group.add(lMesh);
                        }
                        if (rightW > 0.05) {
                            var rGeo = new THREE.BoxGeometry(rightW, h, 0.15);
                            var rMesh = new THREE.Mesh(rGeo, wallMat);
                            var rOffset = wallLength/2 - rightW/2;
                            if (isNS) rMesh.position.set(rOffset, h/2, wallZ);
                            else rMesh.position.set(wallX, h/2, wallLength/2 - rightW/2);
                            rMesh.rotation.y = rotY;
                            rMesh.castShadow = true; rMesh.receiveShadow = true;
                            group.add(rMesh);
                        }
                        // Top piece above door
                        var topH = h - doorH;
                        if (topH > 0.05) {
                            var tGeo = new THREE.BoxGeometry(doorW, topH, 0.15);
                            var tMesh = new THREE.Mesh(tGeo, wallMat);
                            if (isNS) tMesh.position.set(doorCenterLocal, doorH + topH/2, wallZ);
                            else tMesh.position.set(wallX, doorH + topH/2, doorCenterLocal);
                            tMesh.rotation.y = rotY;
                            tMesh.castShadow = true; tMesh.receiveShadow = true;
                            group.add(tMesh);
                        }
                    }
                } catch(e) { console.error('buildWall error:', e); }
            }

            buildWall('north');
            buildWall('south');
            buildWall('east');
            buildWall('west');

            group.position.set(x, 0, z);
            scene.add(group);
            rooms[roomDef.id] = { group: group, x: x, z: z, w: w, d: d, h: h };
            return group;
        } catch(e) { console.error('buildRoom error:', e); }
    }

    function addFlickeringLight(x, y, z, color, intensity, roomGroup) {
        try {
            var light = new THREE.PointLight(color || 0xffaa44, intensity || 0.8, 8);
            light.position.set(x, y, z);
            light.castShadow = false;
            var baseIntensity = intensity || 0.8;
            var flickerData = {
                light: light,
                base: baseIntensity,
                time: Math.random() * 100
            };
            flickeringLights.push(flickerData);
            if (roomGroup) roomGroup.add(light);
            else scene.add(light);

            // Candle mesh
            var candleGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.3, 6);
            var candleMat = new THREE.MeshLambertMaterial({ color: 0xf0e0c0 });
            var candle = new THREE.Mesh(candleGeo, candleMat);
            candle.position.set(x, y - 0.3, z);
            if (roomGroup) roomGroup.add(candle);
            return light;
        } catch(e) { console.error('addFlickeringLight error:', e); }
    }

    function addProp_Table(group, x, y, z, rotY) {
        try {
            var mat = makeMat('wood', 0x3a2010);
            // Table top
            var topGeo = new THREE.BoxGeometry(1.2, 0.08, 0.7);
            var top = new THREE.Mesh(topGeo, mat);
            top.position.set(x, y + 0.72, z);
            top.castShadow = true; top.receiveShadow = true;
            if (rotY) top.rotation.y = rotY;
            group.add(top);
            // Legs
            var legGeo = new THREE.BoxGeometry(0.07, 0.72, 0.07);
            var offsets = [[-0.5,0,-0.3],[0.5,0,-0.3],[-0.5,0,0.3],[0.5,0,0.3]];
            offsets.forEach(function(o) {
                var leg = new THREE.Mesh(legGeo, mat);
                var lx = x + o[0], lz = z + o[2];
                if (rotY) {
                    var cos = Math.cos(rotY), sin = Math.sin(rotY);
                    lx = x + o[0]*cos - o[2]*sin;
                    lz = z + o[0]*sin + o[2]*cos;
                }
                leg.position.set(lx, y + 0.36, lz);
                leg.castShadow = true; leg.receiveShadow = true;
                group.add(leg);
            });
        } catch(e) { console.error('addProp_Table error:', e); }
    }

    function addProp_Chair(group, x, y, z, rotY) {
        try {
            var mat = makeMat('wood', 0x2a1808);
            // Seat
            var seatGeo = new THREE.BoxGeometry(0.5, 0.06, 0.5);
            var seat = new THREE.Mesh(seatGeo, mat);
            seat.position.set(x, y + 0.45, z);
            seat.castShadow = true; seat.receiveShadow = true;
            group.add(seat);
            // Back
            var backGeo = new THREE.BoxGeometry(0.5, 0.6, 0.06);
            var back = new THREE.Mesh(backGeo, mat);
            var backZ = z - 0.22;
            back.position.set(x, y + 0.75, backZ);
            if (rotY) { back.rotation.y = rotY; }
            back.castShadow = true;
            group.add(back);
            // Legs
            var legGeo = new THREE.BoxGeometry(0.06, 0.45, 0.06);
            [[-0.2,z-0.2],[0.2,z-0.2],[-0.2,z+0.2],[0.2,z+0.2]].forEach(function(o) {
                var leg = new THREE.Mesh(legGeo, mat);
                leg.position.set(x+o[0], y+0.225, o[1]);
                leg.castShadow = true;
                group.add(leg);
            });
        } catch(e) { console.error('addProp_Chair error:', e); }
    }

    function addProp_Bed(group, x, y, z, rotY) {
        try {
            var frameMat = makeMat('wood', 0x2a1510);
            var mattressMat = new THREE.MeshLambertMaterial({ color: 0x1a1410 });
            // Frame
            var frameGeo = new THREE.BoxGeometry(0.9, 0.3, 2.0);
            var frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.set(x, y + 0.15, z);
            if (rotY) frame.rotation.y = rotY;
            frame.castShadow = true; frame.receiveShadow = true;
            group.add(frame);
            // Mattress
            var mattGeo = new THREE.BoxGeometry(0.82, 0.18, 1.85);
            var matt = new THREE.Mesh(mattGeo, mattressMat);
            matt.position.set(x, y + 0.39, z);
            if (rotY) matt.rotation.y = rotY;
            matt.castShadow = true; matt.receiveShadow = true;
            group.add(matt);
            // Headboard
            var headGeo = new THREE.BoxGeometry(0.9, 0.7, 0.1);
            var head = new THREE.Mesh(headGeo, frameMat);
            var headOffset = rotY ? new THREE.Vector3(0,0,-1.0).applyEuler(new THREE.Euler(0,rotY,0)) : new THREE.Vector3(0,0,-1.0);
            head.position.set(x + headOffset.x, y + 0.55, z + headOffset.z);
            if (rotY) head.rotation.y = rotY;
            head.castShadow = true;
            group.add(head);
        } catch(e) { console.error('addProp_Bed error:', e); }
    }

    function addProp_Shelf(group, x, y, z, rotY) {
        try {
            var mat = makeMat('wood', 0x2a1a0a);
            // Back panel
            var backGeo = new THREE.BoxGeometry(1.5, 2.0, 0.1);
            var backPanel = new THREE.Mesh(backGeo, mat);
            backPanel.position.set(x, y + 1.0, z);
            if (rotY) backPanel.rotation.y = rotY;
            backPanel.castShadow = true; backPanel.receiveShadow = true;
            group.add(backPanel);
            // Shelves
            var shelfGeo = new THREE.BoxGeometry(1.5, 0.05, 0.3);
            [0.3, 0.8, 1.3, 1.8].forEach(function(sh) {
                var shelf = new THREE.Mesh(shelfGeo, mat);
                shelf.position.set(x, y + sh, z + 0.1);
                if (rotY) shelf.rotation.y = rotY;
                shelf.castShadow = true;
                group.add(shelf);
            });
        } catch(e) { console.error('addProp_Shelf error:', e); }
    }

    function addProp_LockerRow(group, x, y, z) {
        try {
            var mat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            for (var i = 0; i < 4; i++) {
                var geo = new THREE.BoxGeometry(0.5, 1.8, 0.5);
                var locker = new THREE.Mesh(geo, mat);
                locker.position.set(x + i*0.52, y + 0.9, z);
                locker.castShadow = true; locker.receiveShadow = true;
                group.add(locker);
            }
        } catch(e) { console.error('addProp_LockerRow error:', e); }
    }

    function createLevel() {
        try {
            getTextures();

            // Room layout (world positions):
            // entrance_hall: (0, 0)
            // corridor_main: (0, -12) (north of entrance)
            // dormitory_a: (-12, -12) (west of corridor)
            // dormitory_b: (12, -12) (east of corridor)
            // kitchen: (0, -24) (north of corridor)
            // chapel: (-12, -24) (northwest)
            // basement_stairs: (-12, -36) (north of chapel)
            // basement: (-12, -48) (below basement_stairs, same level for simplicity)
            // director_office: (12, -24) (east of kitchen)
            // ritual_room: (12, -36) (south of director_office)

            // entrance_hall
            buildRoom({
                id: 'entrance_hall',
                x: 0, z: 0,
                w: 10, d: 10, h: 4,
                doors: [
                    { side: 'north', offset: 0 },
                    { side: 'south', offset: 0 }
                ]
            });

            // corridor_main
            buildRoom({
                id: 'corridor_main',
                x: 0, z: -12,
                w: 10, d: 10, h: 3.5,
                doors: [
                    { side: 'south', offset: 0 },
                    { side: 'north', offset: 0 },
                    { side: 'west', offset: 0 },
                    { side: 'east', offset: 0 }
                ]
            });

            // dormitory_a
            buildRoom({
                id: 'dormitory_a',
                x: -12, z: -12,
                w: 10, d: 10, h: 3.5,
                doors: [
                    { side: 'east', offset: 0 }
                ]
            });

            // dormitory_b
            buildRoom({
                id: 'dormitory_b',
                x: 12, z: -12,
                w: 10, d: 10, h: 3.5,
                doors: [
                    { side: 'west', offset: 0 }
                ]
            });

            // kitchen
            buildRoom({
                id: 'kitchen',
                x: 0, z: -24,
                w: 10, d: 10, h: 3.5,
                doors: [
                    { side: 'south', offset: 0 },
                    { side: 'west', offset: 0 },
                    { side: 'east', offset: 0 }
                ]
            });

            // chapel
            buildRoom({
                id: 'chapel',
                x: -12, z: -24,
                w: 10, d: 10, h: 5,
                doors: [
                    { side: 'east', offset: 0 },
                    { side: 'north', offset: 0 }
                ]
            });

            // basement_stairs
            buildRoom({
                id: 'basement_stairs',
                x: -12, z: -36,
                w: 10, d: 10, h: 3.5,
                doors: [
                    { side: 'south', offset: 0 },
                    { side: 'north', offset: 0 }
                ]
            });

            // basement
            buildRoom({
                id: 'basement',
                x: -12, z: -48,
                w: 12, d: 12, h: 3,
                doors: [
                    { side: 'south', offset: 0 }
                ]
            });

            // director_office
            buildRoom({
                id: 'director_office',
                x: 12, z: -24,
                w: 10, d: 10, h: 3.5,
                doors: [
                    { side: 'west', offset: 0 },
                    { side: 'north', offset: 0 }
                ]
            });

            // ritual_room
            buildRoom({
                id: 'ritual_room',
                x: 12, z: -36,
                w: 10, d: 10, h: 3.5,
                doors: [
                    { side: 'south', offset: 0 }
                ]
            });

            // --- PROPS ---

            // entrance_hall: a table and chairs
            var ehGroup = rooms['entrance_hall'].group;
            addProp_Table(ehGroup, 0, 0, 1, 0);
            addProp_Chair(ehGroup, -0.8, 0, 1.5, 0);
            addProp_Chair(ehGroup, 0.8, 0, 1.5, 0);
            addFlickeringLight(0, 3.0, 0, 0xffcc66, 0.5, ehGroup);

            // corridor_main: long corridor feel, some debris
            var cmGroup = rooms['corridor_main'].group;
            addProp_Shelf(cmGroup, -4, 0, -3, 0);
            addFlickeringLight(-3, 2.5, -2, 0xffaa33, 0.4, cmGroup);
            addFlickeringLight(3, 2.5, 2, 0xffaa33, 0.3, cmGroup);

            // dormitory_a: beds and lockers
            var daGroup = rooms['dormitory_a'].group;
            addProp_Bed(daGroup, -3, 0, -2, 0);
            addProp_Bed(daGroup, -3, 0, 2, 0);
            addProp_Bed(daGroup, 1, 0, -2, 0);
            addProp_Bed(daGroup, 1, 0, 2, 0);
            addProp_LockerRow(daGroup, -4, 0, -4);
            addFlickeringLight(0, 2.5, 0, 0xffbb44, 0.35, daGroup);

            // dormitory_b: same layout mirrored
            var dbGroup = rooms['dormitory_b'].group;
            addProp_Bed(dbGroup, -3, 0, -2, 0);
            addProp_Bed(dbGroup, -3, 0, 2, 0);
            addProp_Bed(dbGroup, 2, 0, -2, 0);
            addProp_Bed(dbGroup, 2, 0, 2, 0);
            addProp_LockerRow(dbGroup, 0, 0, -4);
            addFlickeringLight(0, 2.5, 0, 0xffbb44, 0.35, dbGroup);

            // kitchen: tables
            var kitGroup = rooms['kitchen'].group;
            addProp_Table(kitGroup, -2, 0, 0, 0);
            addProp_Table(kitGroup, 2, 0, 0, 0);
            addProp_Chair(kitGroup, -2, 0, 1, 0);
            addProp_Chair(kitGroup, 2, 0, 1, 0);
            addFlickeringLight(0, 2.8, -2, 0xffcc55, 0.4, kitGroup);
            addFlickeringLight(0, 2.8, 2, 0xff9922, 0.3, kitGroup);

            // chapel: pews and altar
            var chapGroup = rooms['chapel'].group;
            // Pews
            for (var p = 0; p < 3; p++) {
                var pewGeo = new THREE.BoxGeometry(3.0, 0.4, 0.6);
                var pewMat = makeMat('wood', 0x1a0e05);
                var pew = new THREE.Mesh(pewGeo, pewMat);
                pew.position.set(0, 0.2, -1 + p * 2);
                pew.castShadow = true; pew.receiveShadow = true;
                chapGroup.add(pew);
            }
            // Altar
            var altarGeo = new THREE.BoxGeometry(2.5, 1.0, 0.8);
            var altarMat = makeMat('stone', 0x0d0d0d);
            var altar = new THREE.Mesh(altarGeo, altarMat);
            altar.position.set(0, 0.5, -4.5);
            altar.castShadow = true; altar.receiveShadow = true;
            chapGroup.add(altar);
            // Chapel cross
            var crossVGeo = new THREE.BoxGeometry(0.15, 1.5, 0.1);
            var crossHGeo = new THREE.BoxGeometry(0.8, 0.15, 0.1);
            var crossMat = new THREE.MeshLambertMaterial({ color: 0x050505 });
            var crossV = new THREE.Mesh(crossVGeo, crossMat);
            crossV.position.set(0, 3.5, -4.9);
            chapGroup.add(crossV);
            var crossH = new THREE.Mesh(crossHGeo, crossMat);
            crossH.position.set(0, 4.0, -4.9);
            chapGroup.add(crossH);
            // Chapel candles
            addFlickeringLight(-2, 1.2, -4.5, 0xffcc44, 0.6, chapGroup);
            addFlickeringLight(2, 1.2, -4.5, 0xffcc44, 0.6, chapGroup);
            addFlickeringLight(0, 3.5, 0, 0xffaa22, 0.2, chapGroup);

            // basement_stairs: ramp/stair visual
            var bsGroup = rooms['basement_stairs'].group;
            for (var s = 0; s < 6; s++) {
                var stepGeo = new THREE.BoxGeometry(3.0, 0.15, 0.6);
                var stepMat = makeMat('stone', 0x111111);
                var step = new THREE.Mesh(stepGeo, stepMat);
                step.position.set(0, s * 0.15, -2.0 + s * 0.6);
                step.castShadow = true; step.receiveShadow = true;
                bsGroup.add(step);
            }
            addFlickeringLight(0, 2.0, 0, 0xff8800, 0.3, bsGroup);

            // basement: dark and ominous
            var basGroup = rooms['basement'].group;
            // Ritual circle on floor
            var circleGeo = new THREE.CircleGeometry(3.0, 32);
            var circleMat = new THREE.MeshLambertMaterial({ color: 0x3a0000 });
            var circle = new THREE.Mesh(circleGeo, circleMat);
            circle.rotation.x = -Math.PI/2;
            circle.position.set(0, 0.01, 0);
            basGroup.add(circle);
            addFlickeringLight(-3, 0.5, -3, 0xff2200, 0.4, basGroup);
            addFlickeringLight(3, 0.5, -3, 0xff2200, 0.4, basGroup);
            addFlickeringLight(0, 0.5, 3, 0xff2200, 0.4, basGroup);
            // Some crates
            for (var c = 0; c < 5; c++) {
                var crateGeo = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                var crateMat = makeMat('wood', 0x1a1005);
                var crate = new THREE.Mesh(crateGeo, crateMat);
                crate.position.set(-4 + c * 0.8, 0.35, 4);
                crate.castShadow = true; crate.receiveShadow = true;
                basGroup.add(crate);
            }

            // director_office: desk, chair, shelf
            var doGroup = rooms['director_office'].group;
            addProp_Table(doGroup, 1, 0, -2, 0);
            addProp_Chair(doGroup, 1, 0, -1, 0);
            addProp_Shelf(doGroup, -4, 0, -3, 0);
            addProp_Shelf(doGroup, -4, 0, 1, 0);
            addFlickeringLight(0, 2.5, 0, 0xffdd88, 0.5, doGroup);

            // ritual_room: dark, ritual symbols
            var rrGroup = rooms['ritual_room'].group;
            var rCircleGeo = new THREE.CircleGeometry(3.5, 6);
            var rCircleMat = new THREE.MeshLambertMaterial({ color: 0x2a0000 });
            var rCircle = new THREE.Mesh(rCircleGeo, rCircleMat);
            rCircle.rotation.x = -Math.PI/2;
            rCircle.position.set(0, 0.01, 0);
            rrGroup.add(rCircle);
            // Candles around ritual circle
            for (var rc = 0; rc < 6; rc++) {
                var angle = (rc / 6) * Math.PI * 2;
                var cx = Math.cos(angle) * 3.5;
                var cz = Math.sin(angle) * 3.5;
                addFlickeringLight(cx, 0.6, cz, 0xff1100, 0.5, rrGroup);
            }

            // Add connecting corridor geometry between rooms (floors)
            // entrance to corridor
            addCorridor(0, 0, -5, 0, -10, 10, 2.5, 4);
            // corridor to dormitory_a
            addCorridor(-5, -7, -12, -10, -7, 2.5, 10, 3.5);
            // corridor to dormitory_b
            addCorridor(7, -7, -12, 5, 10, 2.5, 10, 3.5);
            // corridor to kitchen
            addCorridor(0, -17, -24, 0, -10, 2.5, 10, 3.5);
            // kitchen to chapel
            addCorridor(-5, -19, -24, -10, -14, 2.5, 10, 3.5);
            // chapel to basement_stairs
            addCorridor(-12, -29, -36, -12, -30, 2.5, 3, 3.5);
            // basement_stairs to basement
            addCorridor(-12, -41, -48, -12, -42, 2.5, 3, 3);
            // kitchen to director_office
            addCorridor(7, -19, -24, 5, 10, 2.5, 10, 3.5);
            // director_office to ritual_room
            addCorridor(12, -29, -36, -12, -30, 2.5, 3, 3.5);

        } catch(e) { console.error('createLevel error:', e); }
    }

    function addCorridor(x, z, targetZ, targetX, length, width, depth, height) {
        // Simple floor/ceiling for connecting hallways
        try {
            // Actually we'll skip explicit corridors since rooms share walls with door openings
            // The rooms are positioned 12 units apart (10 unit room + 2 unit gap)
            // We need short corridors between them
            // Simple approach: just add floor and ceiling planes
            var floorMat = makeMat('floor');
            var ceilMat = makeMat('plaster', 0x0d0d0d);

            // This function signature is a bit loose, let's just skip for now
            // The rooms already have floor/ceiling. The door openings create walkable space.
        } catch(e) { console.error('addCorridor error:', e); }
    }

    // Player setup
    function setupPlayer() {
        try {
            player = new THREE.Object3D();
            player.position.set(0, playerHeight, 3); // Start in entrance_hall
            player.userData.velocity = new THREE.Vector3();
            player.userData.onGround = true;
            scene.add(player);

            camera.position.set(0, 0, 0);
            player.add(camera);
        } catch(e) { console.error('setupPlayer error:', e); }
    }

    // Flashlight setup
    function setupFlashlight() {
        try {
            flashlight = new THREE.SpotLight(0xfff5e0, 2);
            flashlight.angle = 0.5;
            flashlight.penumbra = 0.3;
            flashlight.distance = 15;
            flashlight.castShadow = false;
            flashlight.position.set(0.2, -0.1, 0);

            var flashTarget = new THREE.Object3D();
            flashTarget.position.set(0, 0, -10);
            camera.add(flashTarget);
            flashlight.target = flashTarget;
            camera.add(flashlight);
        } catch(e) { console.error('setupFlashlight error:', e); }
    }

    // Pointer lock
    function setupPointerLock() {
        try {
            var container = document.getElementById('game-container');
            if (!container) return;

            container.addEventListener('click', function() {
                try {
                    if (window.GameState && window.GameState.isRunning && !window.GameState.isPaused) {
                        container.requestPointerLock();
                    }
                } catch(e) { console.error('requestPointerLock error:', e); }
            });

            document.addEventListener('pointerlockchange', function() {
                try {
                    isPointerLocked = (document.pointerLockElement === container);
                } catch(e) { console.error('pointerlockchange error:', e); }
            });

            document.addEventListener('mousemove', function(e) {
                try {
                    if (!isPointerLocked) return;
                    if (window.GameState && window.GameState.isPaused) return;
                    var sens = 0.002;
                    if (window.InputManager && window.InputManager.mouse) {
                        // sensitivity from settings if available
                    }
                    yaw -= e.movementX * sens;
                    pitch -= e.movementY * sens;
                    pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
                    if (player) {
                        player.rotation.y = yaw;
                    }
                    camera.rotation.x = pitch;
                } catch(e) { console.error('mousemove error:', e); }
            });
        } catch(e) { console.error('setupPointerLock error:', e); }
    }

    // Simple AABB room boundary collision
    function getPlayerRoomBounds() {
        try {
            var px = player.position.x;
            var pz = player.position.z;
            // Find which room the player is in
            for (var id in rooms) {
                var r = rooms[id];
                var hw = r.w / 2 + 0.3;
                var hd = r.d / 2 + 0.3;
                if (px >= r.x - hw && px <= r.x + hw && pz >= r.z - hd && pz <= r.z + hd) {
                    return r;
                }
            }
            return null;
        } catch(e) { console.error('getPlayerRoomBounds error:', e); return null; }
    }

    function checkCollision(newX, newZ) {
        try {
            var px = newX;
            var pz = newZ;
            var margin = 0.4;
            // Check all room boundaries
            var inRoom = false;
            for (var id in rooms) {
                var r = rooms[id];
                // Check if inside room bounds (with margin)
                if (px > r.x - r.w/2 + margin && px < r.x + r.w/2 - margin &&
                    pz > r.z - r.d/2 + margin && pz < r.z + r.d/2 - margin) {
                    inRoom = true;
                    break;
                }
                // Check if in doorway between rooms
                // Allow movement if close to door center
            }
            // Also check against corridor connections by allowing passage near door offsets
            // Simplified: allow if within 1.0 of any room center axis
            if (!inRoom) {
                // Check doorway passages
                var doorMargin = 0.8;
                // Vertical connections (north/south - varying x, fixed z band)
                var passages = [
                    // entrance_hall <-> corridor_main (x=0, z between -5 and -7)
                    { axis:'z', fixed:'x', fixedVal:0, fixedRange:doorMargin, zMin:-7, zMax:-5 },
                    // corridor_main <-> kitchen (x=0, z between -17 and -19)
                    { axis:'z', fixed:'x', fixedVal:0, fixedRange:doorMargin, zMin:-19, zMax:-17 },
                    // kitchen <-> chapel (x between -5 and -7, z=-24)
                    { axis:'x', fixed:'z', fixedVal:-24, fixedRange:doorMargin, xMin:-7, xMax:-5 },
                    // corridor_main <-> dormitory_a (z=-12, x between -7 and -5)
                    { axis:'x', fixed:'z', fixedVal:-12, fixedRange:doorMargin, xMin:-7, xMax:-5 },
                    // corridor_main <-> dormitory_b (z=-12, x between 5 and 7)
                    { axis:'x', fixed:'z', fixedVal:-12, fixedRange:doorMargin, xMin:5, xMax:7 },
                    // chapel <-> basement_stairs (x=-12, z between -29 and -31)
                    { axis:'z', fixed:'x', fixedVal:-12, fixedRange:doorMargin, zMin:-31, zMax:-29 },
                    // basement_stairs <-> basement (x=-12, z between -41 and -43)
                    { axis:'z', fixed:'x', fixedVal:-12, fixedRange:doorMargin, zMin:-43, zMax:-41 },
                    // kitchen <-> director_office (x between 5 and 7, z=-24)
                    { axis:'x', fixed:'z', fixedVal:-24, fixedRange:doorMargin, xMin:5, xMax:7 },
                    // director_office <-> ritual_room (x=12, z between -29 and -31)
                    { axis:'z', fixed:'x', fixedVal:12, fixedRange:doorMargin, zMin:-31, zMax:-29 }
                ];
                for (var pi = 0; pi < passages.length; pi++) {
                    var pass = passages[pi];
                    if (pass.axis === 'z') {
                        if (Math.abs(px - pass.fixedVal) < pass.fixedRange && pz >= pass.zMin && pz <= pass.zMax) {
                            inRoom = true; break;
                        }
                    } else {
                        if (Math.abs(pz - pass.fixedVal) < pass.fixedRange && px >= pass.xMin && px <= pass.xMax) {
                            inRoom = true; break;
                        }
                    }
                }
            }
            return !inRoom; // returns true if collision (can't move there)
        } catch(e) { console.error('checkCollision error:', e); return false; }
    }

    function updatePlayer(delta) {
        try {
            if (!player || !window.GameState || !window.GameState.isRunning || window.GameState.isPaused) return;

            var keys = window.InputManager ? window.InputManager.keys : {};
            var speed = 5.0;
            var isSprinting = keys['ShiftLeft'] || keys['ShiftRight'] || keys['Shift'];

            // Stamina
            if (isSprinting && window.GameState.stamina > 0) {
                speed *= 1.8;
                window.GameState.stamina = Math.max(0, window.GameState.stamina - delta * 15);
                if (window.GameState.stamina <= 0) isSprinting = false;
            } else if (!isSprinting) {
                window.GameState.stamina = Math.min(100, window.GameState.stamina + delta * 8);
            }

            // Movement direction in camera space
            var moveX = 0, moveZ = 0;
            if (keys['KeyW'] || keys['ArrowUp']) moveZ -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) moveZ += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) moveX -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) moveX += 1;

            // Mobile joystick
            if (window.InputManager && window.InputManager.joystickDelta) {
                var jd = window.InputManager.joystickDelta;
                moveX += jd.x;
                moveZ += jd.y;
            }

            // Normalize
            var len = Math.sqrt(moveX*moveX + moveZ*moveZ);
            if (len > 1) { moveX /= len; moveZ /= len; }

            // Convert to world direction based on yaw
            var cosY = Math.cos(yaw), sinY = Math.sin(yaw);
            var worldX = moveX * cosY - moveZ * sinY;
            var worldZ = moveX * sinY + moveZ * cosY;

            // Vertical (jump/gravity)
            var vel = player.userData.velocity;
            if (!vel) { player.userData.velocity = new THREE.Vector3(); vel = player.userData.velocity; }

            vel.y += gravity * delta;

            if ((keys['Space']) && player.userData.onGround) {
                vel.y = jumpForce;
                player.userData.onGround = false;
            }

            // New position candidates
            var newX = player.position.x + worldX * speed * delta + vel.x * delta;
            var newZ = player.position.z + worldZ * speed * delta + vel.z * delta;
            var newY = player.position.y + vel.y * delta;

            // Floor check
            if (newY <= playerHeight) {
                newY = playerHeight;
                vel.y = 0;
                player.userData.onGround = true;
            } else {
                player.userData.onGround = false;
            }

            // Ceiling check
            var currentRoom = null;
            for (var id in rooms) {
                var r = rooms[id];
                if (player.position.x >= r.x - r.w/2 && player.position.x <= r.x + r.w/2 &&
                    player.position.z >= r.z - r.d/2 && player.position.z <= r.z + r.d/2) {
                    currentRoom = r;
                    break;
                }
            }
            if (currentRoom && newY > currentRoom.h - 0.3) {
                newY = currentRoom.h - 0.3;
                vel.y = 0;
            }

            // Collision check X
            if (!checkCollision(newX, player.position.z)) {
                player.position.x = newX;
            } else {
                vel.x = 0;
            }
            // Collision check Z
            if (!checkCollision(player.position.x, newZ)) {
                player.position.z = newZ;
            } else {
                vel.z = 0;
            }

            player.position.y = newY;

            // Dampen horizontal velocity
            vel.x *= 0.8;
            vel.z *= 0.8;

            // Flashlight toggle
            var fPressed = keys['KeyF'] || keys['f'] || keys['F'];
            if (fPressed && !lastFKey) {
                flashlightOn = !flashlightOn;
                if (flashlight) flashlight.intensity = flashlightOn ? 2 : 0;
            }
            lastFKey = fPressed;

            // Footstep bob
            if ((Math.abs(worldX) > 0.1 || Math.abs(worldZ) > 0.1) && player.userData.onGround) {
                var bobSpeed = isSprinting ? 12 : 8;
                var bobAmt = isSprinting ? 0.04 : 0.025;
                var bobTime = (window.GameEngine && window.GameEngine.clock) ? window.GameEngine.clock.getElapsedTime() : 0;
                camera.position.y = Math.sin(bobTime * bobSpeed) * bobAmt;
                camera.position.x = Math.sin(bobTime * bobSpeed * 0.5) * bobAmt * 0.5;
            } else {
                camera.position.y += (0 - camera.position.y) * 0.1;
                camera.position.x += (0 - camera.position.x) * 0.1;
            }

        } catch(e) { console.error('updatePlayer error:', e); }
    }

    function updateFlickeringLights(elapsed) {
        try {
            for (var i = 0; i < flickeringLights.length; i++) {
                var fd = flickeringLights[i];
                fd.time += 0.016;
                // Perlin-like flicker using multiple sine waves
                var flicker = fd.base *
                    (0.85 + 0.1 * Math.sin(fd.time * 7.3 + i) +
                     0.05 * Math.sin(fd.time * 17.1 + i * 2.1) +
                     0.05 * Math.sin(fd.time * 31.7 + i * 0.7));
                // Occasional dramatic flicker
                if (Math.random() < 0.005) {
                    flicker *= 0.1 + Math.random() * 0.3;
                }
                fd.light.intensity = Math.max(0, flicker);
            }
        } catch(e) { console.error('updateFlickeringLights error:', e); }
    }

    function animate() {
        try {
            animationId = requestAnimationFrame(animate);
            var delta = Math.min(clock.getDelta(), 0.05); // cap delta
            var elapsed = clock.getElapsedTime();

            updatePlayer(delta);
            updateFlickeringLights(elapsed);

            // Update HUD
            if (window.UIManager && window.GameState && window.GameState.isRunning) {
                window.UIManager.updateHUD();
            }

            // Audio sanity update
            if (window.AudioManager && window.GameState) {
                window.AudioManager.updateSanityAudio(window.GameState.sanity);
            }

            renderer.render(scene, camera);
        } catch(e) { console.error('animate error:', e); }
    }

    function init() {
        try {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);
            scene.fog = new THREE.Fog(0x0a0a0f, 1, 30);

            // Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);

            // Renderer
            var container = document.getElementById('game-container');
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding || 3001;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 0.5;

            if (container) {
                container.innerHTML = '';
                container.appendChild(renderer.domElement);
                renderer.domElement.style.display = 'block';
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
            }

            // Clock
            clock = new THREE.Clock();

            // Ambient light (very dim)
            var ambient = new THREE.AmbientLight(0x111118, 0.3);
            scene.add(ambient);

            // Hemisphere light for subtle sky
            var hemi = new THREE.HemisphereLight(0x0a0a15, 0x050508, 0.15);
            scene.add(hemi);

            // Player
            setupPlayer();

            // Flashlight
            setupFlashlight();

            // Controls
            setupPointerLock();

            // Level
            createLevel();

            // Window resize
            window.addEventListener('resize', function() {
                try {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                } catch(e) { console.error('resize error:', e); }
            });

            console.log('GameEngine initialized successfully');
        } catch(e) { console.error('GameEngine.init error:', e); }
    }

    return {
        get scene() { return scene; },
        get camera() { return camera; },
        get renderer() { return renderer; },
        get clock() { return clock; },
        get player() { return player; },
        get flashlight() { return flashlight; },
        init: init,
        animate: animate,
        createLevel: createLevel,
        getRooms: function() { return rooms; },
        getYaw: function() { return yaw; },
        setYaw: function(v) { yaw = v; },
        stopAnimation: function() {
            try { if (animationId) { cancelAnimationFrame(animationId); animationId = null; } } catch(e) {}
        }
    };
})();
} catch(e) { console.error('GameEngine init error:', e); }
</script>

<script>
// ============================================================
// SECTION 3: AUDIO MANAGER (Web Audio API)
// ============================================================
try {
window.AudioManager = (function() {
    var ctx = null;
    var masterGain = null;
    var reverbNode = null;
    var reverbGain = null;
    var dryGain = null;
    var ambientNodes = [];
    var windNodes = [];
    var whisperTimeout = null;
    var creakTimeout = null;
    var heartbeatInterval = null;
    var isAmbientPlaying = false;
    var currentSanity = 100;
    var sanityOscillators = [];
    var sanityGain = null;
    var footstepLastTime = 0;
    var initialized = false;

    function createContext() {
        if (ctx) return;
        try {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            setupMasterChain();
            initialized = true;
        } catch(e) {
            console.error('AudioContext creation failed:', e);
        }
    }

    function generateImpulseResponse(duration, decay) {
        try {
            var sampleRate = ctx.sampleRate;
            var length = sampleRate * duration;
            var impulse = ctx.createBuffer(2, length, sampleRate);
            for (var ch = 0; ch < 2; ch++) {
                var channelData = impulse.getChannelData(ch);
                for (var i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                }
            }
            return impulse;
        } catch(e) {
            console.error('Impulse response error:', e);
            return null;
        }
    }

    function setupMasterChain() {
        try {
            masterGain = ctx.createGain();
            masterGain.gain.value = 0.7;

            reverbNode = ctx.createConvolver();
            var impulse = generateImpulseResponse(4.0, 3.0);
            if (impulse) reverbNode.buffer = impulse;

            reverbGain = ctx.createGain();
            reverbGain.gain.value = 0.35;

            dryGain = ctx.createGain();
            dryGain.gain.value = 0.65;

            var masterCompressor = ctx.createDynamicsCompressor();
            masterCompressor.threshold.value = -18;
            masterCompressor.knee.value = 6;
            masterCompressor.ratio.value = 4;
            masterCompressor.attack.value = 0.003;
            masterCompressor.release.value = 0.25;

            masterGain.connect(dryGain);
            masterGain.connect(reverbNode);
            reverbNode.connect(reverbGain);
            dryGain.connect(masterCompressor);
            reverbGain.connect(masterCompressor);
            masterCompressor.connect(ctx.destination);
        } catch(e) {
            console.error('Master chain setup error:', e);
        }
    }

    function createNoiseBuffer(duration) {
        try {
            var sampleRate = ctx.sampleRate;
            var frameCount = Math.floor(sampleRate * duration);
            var buffer = ctx.createBuffer(1, frameCount, sampleRate);
            var data = buffer.getChannelData(0);
            for (var i = 0; i < frameCount; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            return buffer;
        } catch(e) {
            console.error('Noise buffer error:', e);
            return null;
        }
    }

    function createDroneOscillator(freq, type, gainVal) {
        try {
            var osc = ctx.createOscillator();
            osc.type = type || 'sine';
            osc.frequency.value = freq;

            var lfo = ctx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.05 + Math.random() * 0.1;

            var lfoGain = ctx.createGain();
            lfoGain.gain.value = freq * 0.03;

            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);

            var g = ctx.createGain();
            g.gain.value = 0;
            g.gain.linearRampToValueAtTime(gainVal, ctx.currentTime + 3.0);

            var filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 300;
            filter.Q.value = 2.0;

            osc.connect(filter);
            filter.connect(g);
            g.connect(masterGain);

            osc.start();
            lfo.start();

            return { osc: osc, lfo: lfo, gain: g, filter: filter };
        } catch(e) {
            console.error('Drone oscillator error:', e);
            return null;
        }
    }

    function startAmbientDrone() {
        try {
            var freqs = [41.2, 55.0, 61.7, 82.4, 110.0];
            var gains = [0.18, 0.12, 0.08, 0.06, 0.04];
            var types = ['sine', 'sine', 'triangle', 'sine', 'triangle'];

            freqs.forEach(function(freq, i) {
                var node = createDroneOscillator(freq, types[i], gains[i]);
                if (node) ambientNodes.push(node);
            });

            var detuned = ctx.createOscillator();
            detuned.type = 'sawtooth';
            detuned.frequency.value = 55.3;
            var detunedGain = ctx.createGain();
            detunedGain.gain.value = 0.03;
            var detunedFilter = ctx.createBiquadFilter();
            detunedFilter.type = 'lowpass';
            detunedFilter.frequency.value = 200;
            detuned.connect(detunedFilter);
            detunedFilter.connect(detunedGain);
            detunedGain.connect(masterGain);
            detuned.start();
            ambientNodes.push({ osc: detuned, lfo: null, gain: detunedGain, filter: detunedFilter });
        } catch(e) {
            console.error('Ambient drone error:', e);
        }
    }

    function startWind() {
        try {
            var noiseBuffer = createNoiseBuffer(4.0);
            if (!noiseBuffer) return;

            var noiseSource = ctx.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            noiseSource.loop = true;

            var bandpass = ctx.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.value = 400;
            bandpass.Q.value = 0.8;

            var lowpass = ctx.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 800;

            var windGain = ctx.createGain();
            windGain.gain.value = 0.04;

            var lfo = ctx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.03;
            var lfoGain = ctx.createGain();
            lfoGain.gain.value = 300;
            lfo.connect(lfoGain);
            lfoGain.connect(bandpass.frequency);

            var lfo2 = ctx.createOscillator();
            lfo2.type = 'sine';
            lfo2.frequency.value = 0.07;
            var lfoGain2 = ctx.createGain();
            lfoGain2.gain.value = 0.02;
            lfo2.connect(lfoGain2);
            lfoGain2.connect(windGain.gain);

            noiseSource.connect(bandpass);
            bandpass.connect(lowpass);
            lowpass.connect(windGain);
            windGain.connect(masterGain);

            noiseSource.start();
            lfo.start();
            lfo2.start();

            windNodes.push({ source: noiseSource, gain: windGain, lfo: lfo, lfo2: lfo2 });
        } catch(e) {
            console.error('Wind error:', e);
        }
    }

    function playWhisper() {
        try {
            if (!ctx || !masterGain) return;
            if (ctx.state === 'suspended') ctx.resume();

            var noiseBuffer = createNoiseBuffer(1.5);
            if (!noiseBuffer) return;

            var source = ctx.createBufferSource();
            source.buffer = noiseBuffer;

            var formant1 = ctx.createBiquadFilter();
            formant1.type = 'bandpass';
            formant1.frequency.value = 800 + Math.random() * 400;
            formant1.Q.value = 8;

            var formant2 = ctx.createBiquadFilter();
            formant2.type = 'bandpass';
            formant2.frequency.value = 1200 + Math.random() * 600;
            formant2.Q.value = 10;

            var formant3 = ctx.createBiquadFilter();
            formant3.type = 'bandpass';
            formant3.frequency.value = 2400 + Math.random() * 800;
            formant3.Q.value = 12;

            var gainNode = ctx.createGain();
            gainNode.gain.setValueAtTime(0, ctx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.12, ctx.currentTime + 0.3);
            gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.4);

            var panner = ctx.createStereoPanner();
            panner.pan.value = (Math.random() * 2 - 1);

            source.connect(formant1);
            source.connect(formant2);
            source.connect(formant3);
            formant1.connect(gainNode);
            formant2.connect(gainNode);
            formant3.connect(gainNode);
            gainNode.connect(panner);
            panner.connect(masterGain);

            source.start();
            source.stop(ctx.currentTime + 1.5);
        } catch(e) {
            console.error('Whisper error:', e);
        }
    }

    function scheduleWhispers() {
        try {
            var sanityFactor = Math.max(0, currentSanity) / 100;
            var minDelay = 5000 + sanityFactor * 5000;
            var maxDelay = 15000 + sanityFactor * 15000;
            var delay = minDelay + Math.random() * (maxDelay - minDelay);

            whisperTimeout = setTimeout(function() {
                try {
                    if (!isAmbientPlaying) return;
                    playWhisper();
                    scheduleWhispers();
                } catch(e) { console.error(e); }
            }, delay);
        } catch(e) {
            console.error('Schedule whispers error:', e);
        }
    }

    function playCreak() {
        try {
            if (!ctx || !masterGain) return;
            if (ctx.state === 'suspended') ctx.resume();

            var noiseBuffer = createNoiseBuffer(0.8);
            if (!noiseBuffer) return;

            var source = ctx.createBufferSource();
            source.buffer = noiseBuffer;

            var resonant = ctx.createBiquadFilter();
            resonant.type = 'bandpass';
            resonant.frequency.value = 200 + Math.random() * 300;
            resonant.Q.value = 15 + Math.random() * 10;

            var gainNode = ctx.createGain();
            gainNode.gain.setValueAtTime(0, ctx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.25, ctx.currentTime + 0.02);
            gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.7);

            var panner = ctx.createStereoPanner();
            panner.pan.value = (Math.random() * 2 - 1) * 0.7;

            source.connect(resonant);
            resonant.connect(gainNode);
            gainNode.connect(panner);
            panner.connect(masterGain);

            source.start();
            source.stop(ctx.currentTime + 0.8);
        } catch(e) {
            console.error('Creak error:', e);
        }
    }

    function scheduleCreaks() {
        try {
            var delay = 8000 + Math.random() * 20000;
            creakTimeout = setTimeout(function() {
                try {
                    if (!isAmbientPlaying) return;
                    playCreak();
                    scheduleCreaks();
                } catch(e) { console.error(e); }
            }, delay);
        } catch(e) {
            console.error('Schedule creaks error:', e);
        }
    }

    function playFootstep() {
        try {
            if (!ctx || !masterGain) return;
            if (ctx.state === 'suspended') ctx.resume();

            var now = ctx.currentTime;
            if (now - footstepLastTime < 0.3) return;
            footstepLastTime = now;

            var noiseBuffer = createNoiseBuffer(0.12);
            if (!noiseBuffer) return;

            var source = ctx.createBufferSource();
            source.buffer = noiseBuffer;

            var filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 300 + Math.random() * 200;
            filter.Q.value = 1.5;

            var gainNode = ctx.createGain();
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(masterGain);

            source.start();
            source.stop(now + 0.15);
        } catch(e) {
            console.error('Footstep error:', e);
        }
    }

    function playHeartbeat(rate) {
        try {
            if (!ctx || !masterGain) return;
            if (ctx.state === 'suspended') ctx.resume();

            var now = ctx.currentTime;

            function thud(time, gainVal) {
                try {
                    var osc = ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(80, time);
                    osc.frequency.exponentialRampToValueAtTime(30, time + 0.15);

                    var noiseBuffer = createNoiseBuffer(0.15);
                    if (!noiseBuffer) return;
                    var noise = ctx.createBufferSource();
                    noise.buffer = noiseBuffer;
                    var noiseFilter = ctx.createBiquadFilter();
                    noiseFilter.type = 'lowpass';
                    noiseFilter.frequency.value = 150;
                    var noiseGain = ctx.createGain();
                    noiseGain.gain.setValueAtTime(0, time);
                    noiseGain.gain.linearRampToValueAtTime(gainVal * 0.3, time + 0.01);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, time + 0.14);
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(masterGain);
                    noise.start(time);
                    noise.stop(time + 0.15);

                    var g = ctx.createGain();
                    g.gain.setValueAtTime(0, time);
                    g.gain.linearRampToValueAtTime(gainVal, time + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.001, time + 0.15);

                    osc.connect(g);
                    g.connect(masterGain);
                    osc.start(time);
                    osc.stop(time + 0.18);
                } catch(e) { console.error(e); }
            }

            var interval = 60 / rate;
            thud(now, 0.4);
            thud(now + 0.12, 0.25);
        } catch(e) {
            console.error('Heartbeat error:', e);
        }
    }

    function startHeartbeat() {
        try {
            stopHeartbeat();
            var bpm = 60 + ((100 - currentSanity) / 100) * 80;
            var interval = (60 / bpm) * 1000;

            playHeartbeat(bpm);

            heartbeatInterval = setInterval(function() {
                try {
                    if (!isAmbientPlaying) return;
                    var bpm = 60 + ((100 - currentSanity) / 100) * 80;
                    playHeartbeat(bpm);
                    var newInterval = (60 / bpm) * 1000;
                    clearInterval(heartbeatInterval);
                    heartbeatInterval = setInterval(arguments.callee, newInterval);
                } catch(e) { console.error(e); }
            }, interval);
        } catch(e) {
            console.error('Start heartbeat error:', e);
        }
    }

    function stopHeartbeat() {
        try {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        } catch(e) { console.error(e); }
    }

    function playDoorSound() {
        try {
            if (!ctx || !masterGain) return;
            if (ctx.state === 'suspended') ctx.resume();

            var now = ctx.currentTime;

            var thudOsc = ctx.createOscillator();
            thudOsc.type = 'sine';
            thudOsc.frequency.setValueAtTime(120, now);
            thudOsc.frequency.exponentialRampToValueAtTime(40, now + 0.2);

            var thudGain = ctx.createGain();
            thudGain.gain.setValueAtTime(0.5, now);
            thudGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

            thudOsc.connect(thudGain);
            thudGain.connect(masterGain);
            thudOsc.start(now);
            thudOsc.stop(now + 0.3);

            var noiseBuffer = createNoiseBuffer(0.6);
            if (noiseBuffer) {
                var noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                var resonant = ctx.createBiquadFilter();
                resonant.type = 'bandpass';
                resonant.frequency.value = 250;
                resonant.Q.value = 12;
                var noiseGain = ctx.createGain();
                noiseGain.gain.setValueAtTime(0, now + 0.05);
                noiseGain.gain.linearRampToValueAtTime(0.2, now + 0.1);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                noise.connect(resonant);
                resonant.connect(noiseGain);
                noiseGain.connect(masterGain);
                noise.start(now + 0.05);
                noise.stop(now + 0.65);
            }
        } catch(e) {
            console.error('Door sound error:', e);
        }
    }

    function playJumpscare() {
        try {
            if (!ctx || !masterGain) return;
            if (ctx.state === 'suspended') ctx.resume();

            var now = ctx.currentTime;
            var dissonantFreqs = [220, 233.08, 261.63, 277.18, 311.13, 369.99, 415.30];

            dissonantFreqs.forEach(function(freq) {
                try {
                    var osc = ctx.createOscillator();
                    osc.type = Math.random() > 0.5 ? 'sawtooth' : 'square';
                    osc.frequency.value = freq + (Math.random() * 10 - 5);

                    var g = ctx.createGain();
                    g.gain.setValueAtTime(0.15, now);
                    g.gain.exponentialRampToValueAtTime(0.001, now + 1.2);

                    var distortion = ctx.createWaveShaper();
                    var curve = new Float32Array(256);
                    for (var i = 0; i < 256; i++) {
                        var x = (i * 2) / 256 - 1;
                        curve[i] = (3 + 50) * x / (Math.PI + 50 * Math.abs(x));
                    }
                    distortion.curve = curve;

                    osc.connect(distortion);
                    distortion.connect(g);
                    g.connect(masterGain);
                    osc.start(now);
                    osc.stop(now + 1.3);
                } catch(e) { console.error(e); }
            });

            var noiseBuffer = createNoiseBuffer(0.5);
            if (noiseBuffer) {
                var noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                var noiseGain = ctx.createGain();
                noiseGain.gain.setValueAtTime(0.6, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                noise.connect(noiseGain);
                noiseGain.connect(masterGain);
                noise.start(now);
                noise.stop(now + 0.5);
            }
        } catch(e) {
            console.error('Jumpscare error:', e);
        }
    }

    function playPickup() {
        try {
            if (!ctx || !masterGain) return;
            if (ctx.state === 'suspended') ctx.resume();

            var now = ctx.currentTime;
            var freqs = [523.25, 659.25, 783.99];

            freqs.forEach(function(freq, i) {
                try {
                    var osc = ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    var g = ctx.createGain();
                    g.gain.setValueAtTime(0, now + i * 0.06);
                    g.gain.linearRampToValueAtTime(0.1, now + i * 0.06 + 0.02);
                    g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.06 + 0.3);

                    osc.connect(g);
                    g.connect(masterGain);
                    osc.start(now + i * 0.06);
                    osc.stop(now + i * 0.06 + 0.35);
                } catch(e) { console.error(e); }
            });
        } catch(e) {
            console.error('Pickup error:', e);
        }
    }

    function applySanityEffects(sanityLevel) {
        try {
            if (!ctx || !masterGain) return;

            sanityOscillators.forEach(function(node) {
                try {
                    if (node.gain) {
                        node.gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.0);
                    }
                    if (node.osc) setTimeout(function() { try { node.osc.stop(); } catch(e) {} }, 1200);
                } catch(e) { console.error(e); }
            });
            sanityOscillators = [];

            if (sanityLevel <= 69 && sanityLevel >= 40) {
                var dissonantFreq = 110 + (69 - sanityLevel) * 2;
                var osc = ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = dissonantFreq;
                var lfo = ctx.createOscillator();
                lfo.frequency.value = 0.2;
                var lfoG = ctx.createGain();
                lfoG.gain.value = 5;
                lfo.connect(lfoG);
                lfoG.connect(osc.frequency);
                var g = ctx.createGain();
                g.gain.value = 0;
                g.gain.linearRampToValueAtTime(0.04, ctx.currentTime + 2);
                osc.connect(g);
                g.connect(masterGain);
                osc.start(); lfo.start();
                sanityOscillators.push({ osc: osc, lfo: lfo, gain: g });

                ambientNodes.forEach(function(node) {
                    try {
                        if (node.osc) {
                            var detune = (69 - sanityLevel) * 3;
                            node.osc.detune.linearRampToValueAtTime(detune, ctx.currentTime + 2);
                        }
                    } catch(e) { console.error(e); }
                });

            } else if (sanityLevel <= 39 && sanityLevel >= 10) {
                var factor = (39 - sanityLevel) / 29;

                [80, 121, 162, 203].forEach(function(freq) {
                    try {
                        var osc = ctx.createOscillator();
                        osc.type = 'sawtooth';
                        osc.frequency.value = freq + Math.random() * 10;
                        var detuneLFO = ctx.createOscillator();
                        detuneLFO.frequency.value = 0.5 + factor * 2;
                        var detuneLFOG = ctx.createGain();
                        detuneLFOG.gain.value = 30 * factor;
                        detuneLFO.connect(detuneLFOG);
                        detuneLFOG.connect(osc.frequency);
                        var distortion = ctx.createWaveShaper();
                        var curve = new Float32Array(256);
                        var amount = factor * 80;
                        for (var i = 0; i < 256; i++) {
                            var x = (i * 2) / 256 - 1;
                            curve[i] = (Math.PI + amount) * x / (Math.PI + amount * Math.abs(x));
                        }
                        distortion.curve = curve;
                        var g = ctx.createGain();
                        g.gain.value = 0;
                        g.gain.linearRampToValueAtTime(0.05 * factor, ctx.currentTime + 2);
                        osc.connect(distortion);
                        distortion.connect(g);
                        g.connect(masterGain);
                        osc.start();
                        detuneLFO.start();
                        sanityOscillators.push({ osc: osc, lfo: detuneLFO, gain: g });
                    } catch(e) { console.error(e); }
                });

            } else if (sanityLevel < 10) {
                var freqs = [55, 73.4, 92.5, 110.0, 123.5, 146.8, 185.0, 220.0];
                freqs.forEach(function(freq) {
                    try {
                        var osc = ctx.createOscillator();
                        osc.type = Math.random() > 0.5 ? 'sawtooth' : 'square';
                        osc.frequency.value = freq;
                        var amLFO = ctx.createOscillator();
                        amLFO.frequency.value = 2 + Math.random() * 8;
                        var amLFOG = ctx.createGain();
                        amLFOG.gain.value = 0.08;
                        amLFO.connect(amLFOG);
                        var distortion = ctx.createWaveShaper();
                        var curve = new Float32Array(256);
                        for (var i = 0; i < 256; i++) {
                            var x = (i * 2) / 256 - 1;
                            curve[i] = Math.tanh(x * 5);
                        }
                        distortion.curve = curve;
                        var g = ctx.createGain();
                        g.gain.value = 0;
                        g.gain.linearRampToValueAtTime(0.08, ctx.currentTime + 1.5);
                        amLFOG.connect(g.gain);
                        osc.connect(distortion);
                        distortion.connect(g);
                        g.connect(masterGain);
                        osc.start();
                        amLFO.start();
                        sanityOscillators.push({ osc: osc, lfo: amLFO, gain: g });
                    } catch(e) { console.error(e); }
                });

                var screamNoise = createNoiseBuffer(2.0);
                if (screamNoise) {
                    var screamSource = ctx.createBufferSource();
                    screamSource.buffer = screamNoise;
                    screamSource.loop = true;
                    var screamFilter = ctx.createBiquadFilter();
                    screamFilter.type = 'bandpass';
                    screamFilter.frequency.value = 1500;
                    screamFilter.Q.value = 0.5;
                    var screamGain = ctx.createGain();
                    screamGain.gain.value = 0;
                    screamGain.gain.linearRampToValueAtTime(0.06, ctx.currentTime + 2);
                    screamSource.connect(screamFilter);
                    screamFilter.connect(screamGain);
                    screamGain.connect(masterGain);
                    screamSource.start();
                    sanityOscillators.push({ osc: null, source: screamSource, gain: screamGain });
                }
            } else {
                ambientNodes.forEach(function(node) {
                    try {
                        if (node.osc) node.osc.detune.linearRampToValueAtTime(0, ctx.currentTime + 2);
                    } catch(e) { console.error(e); }
                });
            }
        } catch(e) {
            console.error('Sanity effects error:', e);
        }
    }

    function stopAllNodes(nodes) {
        try {
            nodes.forEach(function(node) {
                try {
                    if (node.gain) {
                        node.gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
                    }
                    if (node.osc) setTimeout(function() { try { node.osc.stop(); } catch(e) {} }, 600);
                    if (node.lfo) setTimeout(function() { try { node.lfo.stop(); } catch(e) {} }, 600);
                    if (node.lfo2) setTimeout(function() { try { node.lfo2.stop(); } catch(e) {} }, 600);
                    if (node.source) setTimeout(function() { try { node.source.stop(); } catch(e) {} }, 600);
                } catch(e) { console.error(e); }
            });
        } catch(e) { console.error(e); }
    }

    var interactionInitialized = false;
    function ensureContext() {
        if (!interactionInitialized) {
            interactionInitialized = true;
            document.addEventListener('click', function onFirstClick() {
                try {
                    createContext();
                    if (ctx && ctx.state === 'suspended') ctx.resume();
                    document.removeEventListener('click', onFirstClick);
                } catch(e) { console.error(e); }
            }, { once: false });
            document.addEventListener('touchstart', function onFirstTouch() {
                try {
                    createContext();
                    if (ctx && ctx.state === 'suspended') ctx.resume();
                    document.removeEventListener('touchstart', onFirstTouch);
                } catch(e) { console.error(e); }
            }, { once: false });
        }
    }

    return {
        ctx: null,

        init: function() {
            try {
                ensureContext();
                createContext();
                this.ctx = ctx;
                if (ctx && ctx.state === 'suspended') ctx.resume();
            } catch(e) {
                console.error('AudioManager.init error:', e);
            }
        },

        playAmbient: function() {
            try {
                if (!ctx) { createContext(); }
                if (!ctx) return;
                if (ctx.state === 'suspended') ctx.resume();
                if (isAmbientPlaying) return;

                isAmbientPlaying = true;
                startAmbientDrone();
                startWind();
                scheduleWhispers();
                scheduleCreaks();

                if (currentSanity < 50) {
                    startHeartbeat();
                }
            } catch(e) {
                console.error('playAmbient error:', e);
            }
        },

        playEffect: function(name) {
            try {
                if (!ctx) { createContext(); }
                if (!ctx) return;
                if (ctx.state === 'suspended') ctx.resume();

                switch(name) {
                    case 'footstep': playFootstep(); break;
                    case 'heartbeat': playHeartbeat(60 + ((100 - currentSanity) / 100) * 80); break;
                    case 'door': playDoorSound(); break;
                    case 'jumpscare': playJumpscare(); break;
                    case 'whisper': playWhisper(); break;
                    case 'creak': playCreak(); break;
                    case 'pickup': playPickup(); break;
                    default: console.warn('Unknown effect:', name); break;
                }
            } catch(e) {
                console.error('playEffect error:', e);
            }
        },

        updateSanityAudio: function(sanityLevel) {
            try {
                if (!ctx) return;
                if (ctx.state === 'suspended') ctx.resume();

                var previousSanity = currentSanity;
                currentSanity = sanityLevel;

                applySanityEffects(sanityLevel);

                var prevThreshold = previousSanity >= 50;
                var currThreshold = sanityLevel < 50;
                if (!prevThreshold && currThreshold && isAmbientPlaying) {
                    startHeartbeat();
                } else if (sanityLevel >= 50) {
                    stopHeartbeat();
                }

                if (masterGain) {
                    if (sanityLevel < 10) {
                        masterGain.gain.linearRampToValueAtTime(0.85, ctx.currentTime + 1.0);
                    } else if (sanityLevel < 40) {
                        masterGain.gain.linearRampToValueAtTime(0.75, ctx.currentTime + 1.0);
                    } else {
                        masterGain.gain.linearRampToValueAtTime(0.7, ctx.currentTime + 1.0);
                    }
                }

                if (reverbGain) {
                    var reverbAmount = 0.35 + ((100 - sanityLevel) / 100) * 0.35;
                    reverbGain.gain.linearRampToValueAtTime(reverbAmount, ctx.currentTime + 2.0);
                }
            } catch(e) {
                console.error('updateSanityAudio error:', e);
            }
        },

        stopAll: function() {
            try {
                isAmbientPlaying = false;

                if (whisperTimeout) { clearTimeout(whisperTimeout); whisperTimeout = null; }
                if (creakTimeout) { clearTimeout(creakTimeout); creakTimeout = null; }
                stopHeartbeat();

                if (ctx) {
                    stopAllNodes(ambientNodes);
                    stopAllNodes(windNodes);
                    stopAllNodes(sanityOscillators);
                }

                ambientNodes = [];
                windNodes = [];
                sanityOscillators = [];

                if (ctx && masterGain) {
                    masterGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.0);
                    setTimeout(function() {
                        try {
                            if (masterGain) masterGain.gain.value = 0.7;
                        } catch(e) { console.error(e); }
                    }, 1200);
                }
            } catch(e) {
                console.error('stopAll error:', e);
            }
        }
    };
})();
} catch(e) { console.error('AudioManager init error:', e); }
</script>

<script>
// ============================================================
// SECTION 4: GAME STATE & LOGIC
// ============================================================
try {
window.GameState = (function() {

  var state = {
    sanity: 100,
    stamina: 100,
    isRunning: false,
    isPaused: false,
    currentObjective: '',
    inventory: [],
    playerName: 'Investigador',
    isHost: false,
    alisaPhase: 1,
    gameTime: 0,
    isAlisaActive: false,
    alisaPosition: null,
    _flashlightOn: true,
    _nearbyPlayers: 0,
    _nearCandles: false,
    _roomsExplored: new Set(),
    _objectiveIndex: 0,
    _objectiveComplete: [false, false, false, false, false],
    _alisaHuntTimer: 0,
    _alisaHuntDuration: 0,
    _alisaIsHunting: false,
    _alisaPatrolTimer: 0,
    _alisaPatrolTarget: null,
    _jumpscareActive: false,
    _jumpscareTimer: 0,
    _phase3TeleportTimer: 0,
    _altarInteracted: false,
    _gameWon: false,
    _nextHuntDelay: 0,
    _shakeTimer: 0,
    _flickerTimer: 0,
    _hallucinationTimer: 0,
    _shadowFigures: [],

    items: [
      {
        id: 'fragment_doll',
        name: 'MuÃ±eca Rota',
        description: 'Una muÃ±eca de porcelana con los ojos arrancados. Emana una energÃ­a oscura.',
        room: 'dormitory_a',
        position: { x: 3, y: 0.5, z: 3 },
        collected: false,
        mesh: null
      },
      {
        id: 'fragment_knife',
        name: 'Cuchillo Ritual',
        description: 'Un cuchillo con sÃ­mbolos grabados en la hoja. La sangre nunca se ha secado.',
        room: 'kitchen',
        position: { x: -2, y: 0.5, z: -3 },
        collected: false,
        mesh: null
      },
      {
        id: 'fragment_crucifix',
        name: 'Crucifijo Invertido',
        description: 'Un crucifijo que fue forzado a la posiciÃ³n inversa. Susurra cuando nadie mira.',
        room: 'chapel',
        position: { x: 0, y: 0.5, z: 4 },
        collected: false,
        mesh: null
      },
      {
        id: 'fragment_book',
        name: 'Libro de Nith\'arak',
        description: 'Un libro encuadernado en piel humana. Las pÃ¡ginas se reescriben solas.',
        room: 'basement',
        position: { x: 2, y: 0.5, z: -2 },
        collected: false,
        mesh: null
      },
      {
        id: 'fragment_photo',
        name: 'FotografÃ­a Maldita',
        description: 'Una foto de Alisa. Ella siempre mira directamente a la cÃ¡mara, sin importar el Ã¡ngulo.',
        room: 'director_office',
        position: { x: -3, y: 0.5, z: 1 },
        collected: false,
        mesh: null
      }
    ],

    objectives: [
      {
        id: 'explore',
        text: 'Explora el orfanato (0/3 habitaciones)',
        detail: 'Investiga el orfanato abandonado. Algo te espera en la oscuridad.',
        complete: false
      },
      {
        id: 'collect',
        text: 'Encuentra los fragmentos del ritual (0/3)',
        detail: 'Recoge al menos 3 fragmentos rituales dispersos por el orfanato.',
        complete: false
      },
      {
        id: 'goto_ritual',
        text: 'DirÃ­gete a la sala del ritual',
        detail: 'Lleva los fragmentos a la sala del ritual en el sÃ³tano.',
        complete: false
      },
      {
        id: 'ritual',
        text: 'Completa el ritual',
        detail: 'Usa el altar con los fragmentos para sellar a ÃNIMA para siempre.',
        complete: false
      },
      {
        id: 'escape',
        text: 'Escapa del orfanato',
        detail: 'Â¡Sal del orfanato por la entrada principal antes de que sea demasiado tarde!',
        complete: false
      }
    ],

    _roomPositions: {
      entrance_hall:   { x: 0,   z: 0   },
      corridor_main:   { x: 0,   z: -12 },
      dormitory_a:     { x: 12,  z: -12 },
      dormitory_b:     { x: -12, z: -12 },
      chapel:          { x: 0,   z: -24 },
      kitchen:         { x: 12,  z: -24 },
      basement_stairs: { x: -12, z: -24 },
      basement:        { x: -12, z: -36 },
      director_office: { x: 12,  z: -36 },
      ritual_room:     { x: 0,   z: -36 }
    },

    _patrolRoute: ['entrance_hall','corridor_main','dormitory_a','chapel','kitchen','director_office','ritual_room','basement','basement_stairs','dormitory_b'],
    _patrolIndex: 0,

    init: function() {
      try {
        state.sanity = 100;
        state.stamina = 100;
        state.isRunning = false;
        state.isPaused = false;
        state.inventory = [];
        state.isHost = false;
        state.alisaPhase = 1;
        state.gameTime = 0;
        state.isAlisaActive = false;
        state._roomsExplored = new Set();
        state._objectiveIndex = 0;
        state._objectiveComplete = [false, false, false, false, false];
        state._alisaHuntTimer = 0;
        state._alisaHuntDuration = 0;
        state._alisaIsHunting = false;
        state._alisaPatrolTimer = 0;
        state._jumpscareActive = false;
        state._jumpscareTimer = 0;
        state._phase3TeleportTimer = 0;
        state._altarInteracted = false;
        state._gameWon = false;
        state._shakeTimer = 0;
        state._flickerTimer = 0;
        state._hallucinationTimer = 0;
        state._shadowFigures = [];
        state._nextHuntDelay = 60 + Math.random() * 60;
        state._flashlightOn = true;
        state._nearbyPlayers = 0;
        state._nearCandles = false;

        for (var i = 0; i < state.items.length; i++) {
          state.items[i].collected = false;
          state.items[i].mesh = null;
        }
        for (var j = 0; j < state.objectives.length; j++) {
          state.objectives[j].complete = false;
        }

        var startRoom = state._roomPositions['entrance_hall'];
        state.alisaPosition = { x: startRoom.x, y: 0, z: startRoom.z - 5 };
        state.isAlisaActive = true;
        state._roomsExplored.add('entrance_hall');
        state._updateObjective();
      } catch(e) { console.error('GameState.init error:', e); }
    },

    _updateObjective: function() {
      try {
        if (state._objectiveIndex === 0) {
          var explored = state._roomsExplored.size;
          state.objectives[0].text = 'Explora el orfanato (' + Math.min(explored,3) + '/3 habitaciones)';
          if (explored >= 3) {
            state._completeObjective(0);
          }
        } else if (state._objectiveIndex === 1) {
          var count = state.inventory.length;
          state.objectives[1].text = 'Encuentra los fragmentos del ritual (' + Math.min(count,3) + '/3)';
          if (count >= 3) {
            state._completeObjective(1);
          }
        } else if (state._objectiveIndex === 2) {
          // check if in ritual room
        } else if (state._objectiveIndex === 3) {
          // check altar
        } else if (state._objectiveIndex === 4) {
          // check entrance
        }

        if (state._objectiveIndex < state.objectives.length) {
          state.currentObjective = state.objectives[state._objectiveIndex].text;
        }

        if (window.UIManager) {
          try { UIManager.updateHUD(); } catch(e){}
        }
      } catch(e) { console.error('GameState._updateObjective error:', e); }
    },

    _completeObjective: function(index) {
      try {
        if (state._objectiveComplete[index]) return;
        state._objectiveComplete[index] = true;
        state.objectives[index].complete = true;
        state._objectiveIndex = index + 1;

        var msgs = [
          'Â¡Objetivo completado! Ahora busca los fragmentos del ritual.',
          'Â¡Bien hecho! Ahora dirÃ­gete a la sala del ritual.',
          'Has llegado a la sala del ritual. Â¡Completa el ritual!',
          'Â¡Ritual completado! Â¡Escapa del orfanato ahora!',
          'Â¡HAS ESCAPADO! El alma de Alisa descansa en paz...'
        ];

        if (window.UIManager && msgs[index]) {
          try { UIManager.showSubtitle(msgs[index], 4000); } catch(e){}
        }

        if (index === 4) {
          state._gameWon = true;
          state.isAlisaActive = false;
          setTimeout(function(){
            try {
              if (window.UIManager) UIManager.showScreen('death-screen');
              var el = document.getElementById('death-screen');
              if (el) {
                el.style.background = 'linear-gradient(rgba(0,50,0,0.95), rgba(0,20,0,0.95))';
                var title = el.querySelector('h1');
                if (title) { title.textContent = '\u00a1ESCAPASTE!'; title.style.color = '#00ff88'; }
                var sub = el.querySelector('p');
                if (sub) sub.textContent = 'El alma de Alisa descansa. El orfanato calla por fin.';
              }
            } catch(e){}
          }, 2000);
        }

        if (state._objectiveIndex < state.objectives.length) {
          state.currentObjective = state.objectives[state._objectiveIndex].text;
        }
      } catch(e) { console.error('GameState._completeObjective error:', e); }
    },

    markRoomEntered: function(roomId) {
      try {
        if (!state._roomsExplored.has(roomId)) {
          state._roomsExplored.add(roomId);
          if (window.UIManager) {
            try { UIManager.showSubtitle('Entrando en: ' + state._getRoomName(roomId), 2000); } catch(e){}
          }
        }
        if (state._objectiveIndex === 0) state._updateObjective();
        if (roomId === 'ritual_room' && state._objectiveIndex === 2) {
          state._completeObjective(2);
        }
        if (roomId === 'entrance_hall' && state._objectiveIndex === 4) {
          state._completeObjective(4);
        }
      } catch(e) { console.error('GameState.markRoomEntered error:', e); }
    },

    _getRoomName: function(roomId) {
      var names = {
        entrance_hall: 'VestÃ­bulo Principal',
        corridor_main: 'Pasillo Principal',
        dormitory_a: 'Dormitorio A',
        dormitory_b: 'Dormitorio B',
        chapel: 'Capilla',
        kitchen: 'Cocina',
        basement_stairs: 'Escaleras al SÃ³tano',
        basement: 'SÃ³tano',
        director_office: 'Despacho del Director',
        ritual_room: 'Sala del Ritual'
      };
      return names[roomId] || roomId;
    },

    tryPickupItem: function(itemId) {
      try {
        for (var i = 0; i < state.items.length; i++) {
          var item = state.items[i];
          if (item.id === itemId && !item.collected) {
            item.collected = true;
            state.inventory.push(item);
            if (window.UIManager) {
              try {
                UIManager.showSubtitle('Has recogido: ' + item.name + '. ' + item.description, 4000);
                UIManager.updateHUD();
              } catch(e){}
            }
            if (window.AudioManager) {
              try { AudioManager.playEffect('pickup'); } catch(e){}
            }
            if (state._objectiveIndex === 1) state._updateObjective();
            return true;
          }
        }
        return false;
      } catch(e) { console.error('GameState.tryPickupItem error:', e); return false; }
    },

    tryInteractAltar: function() {
      try {
        if (state._objectiveIndex === 3 && state.inventory.length >= 3 && !state._altarInteracted) {
          state._altarInteracted = true;
          if (window.UIManager) {
            try { UIManager.showSubtitle('Â¡El ritual ha comenzado! Los fragmentos arden con fuego espiritual...', 5000); } catch(e){}
          }
          if (window.AudioManager) {
            try { AudioManager.playEffect('ritual'); } catch(e){}
          }
          setTimeout(function(){
            try { state._completeObjective(3); } catch(e){}
          }, 4000);
          return true;
        }
        if (state._objectiveIndex === 3 && state.inventory.length < 3) {
          if (window.UIManager) {
            try { UIManager.showSubtitle('Necesitas al menos 3 fragmentos del ritual. Tienes ' + state.inventory.length + '.', 3000); } catch(e){}
          }
        }
        return false;
      } catch(e) { console.error('GameState.tryInteractAltar error:', e); return false; }
    },

    _updateAlisa: function(dt) {
      try {
        if (!state.isAlisaActive || !state.alisaPosition) return;

        var playerPos = { x: 0, y: 0, z: 0 };
        if (window.GameEngine && GameEngine.player) {
          playerPos.x = GameEngine.player.position.x;
          playerPos.y = GameEngine.player.position.y;
          playerPos.z = GameEngine.player.position.z;
        }

        var speed = 2.0;
        if (state.alisaPhase === 2) speed = 3.0;
        if (state.alisaPhase === 3) speed = 4.5;

        // Hunt mode
        if (state._alisaIsHunting) {
          state._alisaHuntTimer -= dt;
          var huntSpeed = (state.alisaPhase >= 2) ? 5.0 : 4.0;
          var dx = playerPos.x - state.alisaPosition.x;
          var dz = playerPos.z - state.alisaPosition.z;
          var dist = Math.sqrt(dx*dx + dz*dz);
          if (dist > 0.1) {
            state.alisaPosition.x += (dx/dist) * huntSpeed * dt;
            state.alisaPosition.z += (dz/dist) * huntSpeed * dt;
          }
          if (state._alisaHuntTimer <= 0) {
            state._alisaIsHunting = false;
            state._nextHuntDelay = 60 + Math.random() * 60;
            if (state.alisaPhase === 2) state._nextHuntDelay = 30 + Math.random() * 40;
            if (state.alisaPhase === 3) state._nextHuntDelay = 15 + Math.random() * 20;
            state._teleportAlisaAway();
          }
        } else {
          // Patrol mode
          state._nextHuntDelay -= dt;
          if (state._nextHuntDelay <= 0 && state.alisaPhase >= 1) {
            state._alisaIsHunting = true;
            state._alisaHuntTimer = 20;
            if (window.AudioManager) { try { AudioManager.playEffect('chase'); } catch(e){} }
            if (window.UIManager) { try { UIManager.showSubtitle('Â¡Algo se acerca!', 2000); } catch(e){} }
          }

          state._alisaPatrolTimer -= dt;
          if (state._alisaPatrolTimer <= 0 || !state._alisaPatrolTarget) {
            state._patrolIndex = (state._patrolIndex + 1) % state._patrolRoute.length;
            var targetRoom = state._patrolRoute[state._patrolIndex];
            var rp = state._roomPositions[targetRoom];
            state._alisaPatrolTarget = {
              x: rp.x + (Math.random()-0.5)*4,
              z: rp.z + (Math.random()-0.5)*4
            };
            state._alisaPatrolTimer = 8 + Math.random() * 6;
          }

          if (state._alisaPatrolTarget) {
            var pdx = state._alisaPatrolTarget.x - state.alisaPosition.x;
            var pdz = state._alisaPatrolTarget.z - state.alisaPosition.z;
            var pd = Math.sqrt(pdx*pdx + pdz*pdz);
            if (pd > 0.5) {
              state.alisaPosition.x += (pdx/pd) * speed * dt;
              state.alisaPosition.z += (pdz/pd) * speed * dt;
            }
          }
        }

        // Phase 3 teleport
        if (state.alisaPhase === 3) {
          state._phase3TeleportTimer -= dt;
          if (state._phase3TeleportTimer <= 0) {
            state._phase3TeleportTimer = 20 + Math.random() * 20;
            var angle = Math.random() * Math.PI * 2;
            var rad = 3 + Math.random() * 4;
            state.alisaPosition.x = playerPos.x + Math.cos(angle) * rad;
            state.alisaPosition.z = playerPos.z + Math.sin(angle) * rad;
            if (window.UIManager) { try { UIManager.showSubtitle('Siento su presencia...', 2000); } catch(e){} }
            if (window.AudioManager) { try { AudioManager.playEffect('whisper'); } catch(e){} }
          }
        }

        // Check proximity to player
        var cx = playerPos.x - state.alisaPosition.x;
        var cz = playerPos.z - state.alisaPosition.z;
        var closeDist = Math.sqrt(cx*cx + cz*cz);

        if (closeDist < 2 && !state._jumpscareActive) {
          state._triggerJumpscare();
        }

        if (window.GameEngine && GameEngine.alisaMesh) {
          try {
            GameEngine.alisaMesh.position.x = state.alisaPosition.x;
            GameEngine.alisaMesh.position.z = state.alisaPosition.z;
          } catch(e){}
        }
      } catch(e) { console.error('GameState._updateAlisa error:', e); }
    },

    _teleportAlisaAway: function() {
      try {
        var rooms = Object.values(state._roomPositions);
        var r = rooms[Math.floor(Math.random() * rooms.length)];
        state.alisaPosition = {
          x: r.x + (Math.random()-0.5)*6,
          y: 0,
          z: r.z + (Math.random()-0.5)*6
        };
      } catch(e) { console.error('GameState._teleportAlisaAway error:', e); }
    },

    _triggerJumpscare: function() {
      try {
        state._jumpscareActive = true;
        state._jumpscareTimer = 2.0;
        state.sanity = Math.max(0, state.sanity - 30);

        if (window.AudioManager) { try { AudioManager.playEffect('jumpscare'); } catch(e){} }
        if (window.UIManager) { try { UIManager.showSubtitle('Â¡ÃNIMA! Â¡Corre!', 2000); } catch(e){} }

        // Flash the screen
        var flash = document.createElement('div');
        flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:white;z-index:9999;pointer-events:none;opacity:1;transition:opacity 0.5s;';
        document.body.appendChild(flash);
        setTimeout(function(){
          try { flash.style.opacity = '0'; setTimeout(function(){ try { document.body.removeChild(flash); } catch(e){} }, 600); } catch(e){}
        }, 50);

        state._teleportAlisaAway();
        state._alisaIsHunting = false;
        state._nextHuntDelay = 30 + Math.random() * 30;

        setTimeout(function(){
          try { state._jumpscareActive = false; } catch(e){}
        }, 2000);
      } catch(e) { console.error('GameState._triggerJumpscare error:', e); }
    },

    _updateSanity: function(dt) {
      try {
        var delta = 0;

        // Base drain over time (-0.5/min = -0.5/60 per second)
        delta -= (0.5 / 60) * dt;

        // Darkness penalty
        var flashlightActive = state._flashlightOn;
        if (window.GameEngine && GameEngine.flashlight) {
          try { flashlightActive = GameEngine.flashlight.visible; } catch(e){}
        }
        if (!flashlightActive) {
          delta -= (1.0 / 60) * dt;
        }

        // Near ANIMA
        if (state.isAlisaActive && state.alisaPosition && window.GameEngine && GameEngine.player) {
          try {
            var ax = GameEngine.player.position.x - state.alisaPosition.x;
            var az = GameEngine.player.position.z - state.alisaPosition.z;
            var aDist = Math.sqrt(ax*ax + az*az);
            if (aDist < 10) {
              delta -= (5.0 / 60) * dt;
            }
          } catch(e){}
        }

        // Near candles
        if (state._nearCandles) {
          delta += (2.0 / 60) * dt;
        }

        // Nearby players
        if (state._nearbyPlayers > 0) {
          delta += (state._nearbyPlayers * 1.0 / 60) * dt;
        }

        state.sanity = Math.max(0, Math.min(100, state.sanity + delta));

        if (window.AudioManager) {
          try { AudioManager.updateSanityAudio(state.sanity); } catch(e){}
        }
      } catch(e) { console.error('GameState._updateSanity error:', e); }
    },

    _updateStamina: function(dt) {
      try {
        var isSprinting = state.isRunning;
        if (window.InputManager) {
          try { isSprinting = InputManager.isPressed('ShiftLeft') || InputManager.isPressed('ShiftRight') || state.isRunning; } catch(e){}
        }
        if (isSprinting && state.stamina > 0) {
          state.stamina = Math.max(0, state.stamina - 20 * dt);
        } else if (!isSprinting && state.stamina < 100) {
          state.stamina = Math.min(100, state.stamina + 10 * dt);
        }
        if (state.stamina <= 0) {
          state.isRunning = false;
        }
      } catch(e) { console.error('GameState._updateStamina error:', e); }
    },

    _updatePhase: function() {
      try {
        var minutes = state.gameTime / 60;
        if (minutes >= 20 && state.alisaPhase < 3) {
          state.alisaPhase = 3;
          if (window.UIManager) { try { UIManager.showSubtitle('ÃNIMA ha despertado completamente. No hay escapatoria...', 5000); } catch(e){} }
          if (window.AudioManager) { try { AudioManager.playEffect('phase3'); } catch(e){} }
          state._phase3TeleportTimer = 20;
        } else if (minutes >= 10 && state.alisaPhase < 2) {
          state.alisaPhase = 2;
          if (window.UIManager) { try { UIManager.showSubtitle('ÃNIMA se vuelve mÃ¡s agresiva...', 4000); } catch(e){} }
          if (window.AudioManager) { try { AudioManager.playEffect('phase2'); } catch(e){} }
        }
      } catch(e) { console.error('GameState._updatePhase error:', e); }
    },

    applySanityEffects: function() {
      try {
        var s = state.sanity;
        var renderer = null;
        if (window.GameEngine) { try { renderer = GameEngine.renderer; } catch(e){} }
        var container = document.getElementById('game-container');
        var canvas = container ? container.querySelector('canvas') : null;

        // Remove previous effects
        var existingVignette = document.getElementById('sanity-vignette');
        var existingAberration = document.getElementById('sanity-aberration');
        var existingHallucination = document.getElementById('sanity-hallucination');

        if (s >= 70) {
          // Normal
          if (existingVignette) existingVignette.style.opacity = '0';
          if (existingAberration) existingAberration.style.display = 'none';
          if (existingHallucination) existingHallucination.style.display = 'none';
          if (canvas) { canvas.style.filter = ''; canvas.style.transform = ''; }
        } else if (s >= 40) {
          // Slight vignette, occasional shake
          var v = state._getOrCreateEffect('sanity-vignette');
          var alpha = (70 - s) / 60;
          v.style.opacity = String(alpha);
          v.style.background = 'radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,' + (alpha * 0.8) + ') 100%)';
          v.style.display = 'block';
          if (existingAberration) existingAberration.style.display = 'none';
          if (existingHallucination) existingHallucination.style.display = 'none';

          // Occasional shake
          if (Math.random() < 0.005) {
            state._shakeTimer = 0.3;
          }
          if (state._shakeTimer > 0 && canvas) {
            var shakeX = (Math.random()-0.5)*4;
            var shakeY = (Math.random()-0.5)*4;
            canvas.style.transform = 'translate(' + shakeX + 'px,' + shakeY + 'px)';
          } else if (canvas) {
            canvas.style.transform = '';
          }
        } else if (s >= 10) {
          // Strong vignette, chromatic aberration, flicker
          var v2 = state._getOrCreateEffect('sanity-vignette');
          var alpha2 = 0.6 + (40 - s) / 100;
          v2.style.opacity = String(Math.min(1, alpha2));
          v2.style.background = 'radial-gradient(ellipse at center, transparent 20%, rgba(50,0,0,' + alpha2 + ') 100%)';
          v2.style.display = 'block';

          // Chromatic aberration via filter
          if (canvas) {
            var aberr = (40 - s) / 10;
            canvas.style.filter = 'contrast(' + (1 + aberr*0.05) + ') saturate(' + (1 + aberr*0.1) + ')';
            var shakeX2 = (Math.random()-0.5)*aberr*2;
            var shakeY2 = (Math.random()-0.5)*aberr*1;
            canvas.style.transform = 'translate(' + shakeX2 + 'px,' + shakeY2 + 'px)';
          }

          // Flicker
          state._flickerTimer -= 0.016;
          if (state._flickerTimer <= 0) {
            state._flickerTimer = 0.5 + Math.random() * 2;
            if (renderer) {
              try {
                var origColor = renderer.getClearColor(new THREE.Color());
                renderer.setClearColor(0x1a0000);
                setTimeout(function(){
                  try { if (renderer) renderer.setClearColor(0x000000); } catch(e){}
                }, 100);
              } catch(e){}
            }
          }

          if (existingHallucination) existingHallucination.style.display = 'none';
        } else {
          // Heavy distortion, inverted flashes, shadow figures
          var v3 = state._getOrCreateEffect('sanity-vignette');
          v3.style.opacity = '1';
          v3.style.background = 'radial-gradient(ellipse at center, rgba(100,0,0,0.3) 0%, rgba(0,0,0,0.9) 100%)';
          v3.style.display = 'block';

          if (canvas) {
            var t = Date.now() * 0.001;
            var intensity = (10 - s) / 10;
            var skewX = Math.sin(t * 3) * intensity * 3;
            canvas.style.filter = 'contrast(' + (1 + intensity) + ') hue-rotate(' + (Math.sin(t)*30*intensity) + 'deg) saturate(' + (1 + intensity * 2) + ')';
            canvas.style.transform = 'translate(' + (Math.random()-0.5)*8*intensity + 'px,' + (Math.random()-0.5)*6*intensity + 'px) skewX(' + skewX + 'deg)';
          }

          // Random inverted flash
          if (Math.random() < 0.003) {
            var h = state._getOrCreateEffect('sanity-hallucination');
            h.style.display = 'block';
            h.style.background = 'rgba(255,0,0,0.15)';
            h.style.animation = 'none';
            setTimeout(function(){
              try {
                if (h) { h.style.background = 'rgba(255,255,255,0.6)'; }
                setTimeout(function(){
                  try { if (h) h.style.display = 'none'; } catch(e){}
                }, 80);
              } catch(e){}
            }, 50);
          } else if (existingHallucination) {
            existingHallucination.style.display = 'none';
          }

          // Whispers
          if (Math.random() < 0.002 && window.AudioManager) {
            try { AudioManager.playEffect('hallucination'); } catch(e){}
          }
        }

        // Update sanity UI
        var sanityBar = document.getElementById('sanity-bar');
        var sanityVal = document.getElementById('sanity-value');
        if (sanityBar) {
          sanityBar.style.width = s + '%';
          if (s >= 70) sanityBar.style.backgroundColor = '#00ff44';
          else if (s >= 40) sanityBar.style.backgroundColor = '#ffcc00';
          else if (s >= 10) sanityBar.style.backgroundColor = '#ff6600';
          else sanityBar.style.backgroundColor = '#ff0000';
        }
        if (sanityVal) sanityVal.textContent = Math.floor(s) + '%';

        var staminaBar = document.getElementById('stamina-bar');
        if (staminaBar) {
          staminaBar.style.width = state.stamina + '%';
        }
      } catch(e) { console.error('GameState.applySanityEffects error:', e); }
    },

    _getOrCreateEffect: function(id) {
      try {
        var el = document.getElementById(id);
        if (!el) {
          el = document.createElement('div');
          el.id = id;
          el.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:500;transition:opacity 0.3s;';
          document.body.appendChild(el);
        }
        return el;
      } catch(e) { return document.createElement('div'); }
    },

    _checkItemProximity: function() {
      try {
        if (!window.GameEngine || !GameEngine.player) return;
        var px = GameEngine.player.position.x;
        var py = GameEngine.player.position.y;
        var pz = GameEngine.player.position.z;

        var nearest = null;
        var nearestDist = Infinity;

        for (var i = 0; i < state.items.length; i++) {
          var item = state.items[i];
          if (item.collected) continue;
          var ip = state._getItemWorldPos(item);
          var dx = px - ip.x;
          var dy = py - ip.y;
          var dz = pz - ip.z;
          var dist = Math.sqrt(dx*dx + dz*dz);
          if (dist < 2.5 && dist < nearestDist) {
            nearestDist = dist;
            nearest = item;
          }
        }

        // Check altar
        if (state._objectiveIndex === 3 && !state._altarInteracted) {
          var altarPos = state._roomPositions['ritual_room'];
          if (altarPos) {
            var adx = px - altarPos.x;
            var adz = pz - altarPos.z;
            var altarDist = Math.sqrt(adx*adx + adz*adz);
            if (altarDist < 3) {
              if (window.UIManager) { try { UIManager.showInteraction('Presiona E para completar el ritual'); } catch(e){} }
              window._nearAltar = true;
              if (!nearest) return;
            }
          }
        } else {
          window._nearAltar = false;
        }

        if (nearest) {
          if (window.UIManager) { try { UIManager.showInteraction('Presiona E para recoger: ' + nearest.name); } catch(e){} }
          window._nearestItem = nearest.id;
        } else if (!window._nearAltar) {
          if (window.UIManager) { try { UIManager.hideInteraction(); } catch(e){} }
          window._nearestItem = null;
        }
      } catch(e) { console.error('GameState._checkItemProximity error:', e); }
    },

    _getItemWorldPos: function(item) {
      try {
        if (item.mesh) {
          return { x: item.mesh.position.x, y: item.mesh.position.y, z: item.mesh.position.z };
        }
        var roomPos = state._roomPositions[item.room];
        if (roomPos) {
          return { x: roomPos.x + item.position.x, y: item.position.y, z: roomPos.z + item.position.z };
        }
        return { x: item.position.x, y: item.position.y, z: item.position.z };
      } catch(e) { return { x: 0, y: 0, z: 0 }; }
    },

    handleInteract: function() {
      try {
        if (window._nearestItem) {
          state.tryPickupItem(window._nearestItem);
        } else if (window._nearAltar) {
          state.tryInteractAltar();
        }
      } catch(e) { console.error('GameState.handleInteract error:', e); }
    },

    _getCurrentRoom: function() {
      try {
        if (!window.GameEngine || !GameEngine.player) return null;
        var px = GameEngine.player.position.x;
        var pz = GameEngine.player.position.z;
        var minDist = Infinity;
        var closestRoom = null;
        for (var r in state._roomPositions) {
          var rp = state._roomPositions[r];
          var dx = px - rp.x;
          var dz = pz - rp.z;
          var d = Math.sqrt(dx*dx + dz*dz);
          if (d < minDist) {
            minDist = d;
            closestRoom = r;
          }
        }
        if (minDist < 7) return closestRoom;
        return null;
      } catch(e) { return null; }
    },

    update: function(dt) {
      try {
        if (state.isPaused || state._gameWon) return;

        state.gameTime += dt;
        state._updatePhase();
        state._updateSanity(dt);
        state._updateStamina(dt);
        state._updateAlisa(dt);
        state._checkItemProximity();
        state.applySanityEffects();

        // Shake timer
        if (state._shakeTimer > 0) state._shakeTimer -= dt;

        // Room tracking
        var currentRoom = state._getCurrentRoom();
        if (currentRoom) {
          state.markRoomEntered(currentRoom);
        }

        // Sanity death check
        if (state.sanity <= 0) {
          state._triggerSanityDeath();
        }

        // Update HUD
        if (window.UIManager) {
          try { UIManager.updateHUD(); } catch(e){}
        }
      } catch(e) { console.error('GameState.update error:', e); }
    },

    _triggerSanityDeath: function() {
      try {
        if (state._gameWon) return;
        state.isAlisaActive = false;
        state.sanity = 0;
        if (window.AudioManager) { try { AudioManager.stopAll(); } catch(e){} }
        if (window.UIManager) {
          try { UIManager.showScreen('death-screen'); } catch(e){}
        }
        var canvas = document.getElementById('game-container');
        if (canvas) canvas.style.display = 'none';
        var hud = document.getElementById('hud-overlay');
        if (hud) hud.style.display = 'none';
      } catch(e) { console.error('GameState._triggerSanityDeath error:', e); }
    },

    setFlashlightState: function(on) {
      try {
        state._flashlightOn = on;
      } catch(e){}
    },

    setNearbyPlayers: function(count) {
      try {
        state._nearbyPlayers = count;
      } catch(e){}
    },

    setNearCandles: function(near) {
      try {
        state._nearCandles = near;
      } catch(e){}
    },

    reset: function() {
      try {
        state.init();
      } catch(e) { console.error('GameState.reset error:', e); }
    }
  };

  return state;

})();
} catch(e) { console.error('GameState init error:', e); }
</script>

<script>
// ============================================================
// SECTION 5: MULTIPLAYER MANAGER (PeerJS)
// ============================================================
try {
window.MultiplayerManager = (function() {
  'use strict';

  var _peer = null;
  var _connections = [];
  var _roomCode = '';
  var _isHost = false;
  var _players = new Map();
  var _myId = '';
  var _dataCallback = null;
  var _positionInterval = null;
  var _playerMeshes = new Map();
  var _reconnectAttempts = 0;
  var MAX_RECONNECT = 3;
  var MAX_PLAYERS = 4;

  function _generateRoomCode() {
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    var code = '';
    for (var i = 0; i < 6; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }

  function _createPlayerMesh(playerId, playerName) {
    try {
      if (!window.GameEngine || !window.GameEngine.scene) return null;
      if (typeof THREE === 'undefined') return null;

      var group = new THREE.Group();

      var bodyGeo = new THREE.CapsuleGeometry(0.3, 1.0, 4, 8);
      var bodyMat = new THREE.MeshStandardMaterial({
        color: 0x00ffaa,
        emissive: 0x004422,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.8
      });
      var bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
      bodyMesh.position.y = 0.9;
      group.add(bodyMesh);

      var headGeo = new THREE.SphereGeometry(0.25, 8, 8);
      var headMat = new THREE.MeshStandardMaterial({
        color: 0x00ffaa,
        emissive: 0x004422,
        emissiveIntensity: 0.8,
        transparent: true,
        opacity: 0.9
      });
      var headMesh = new THREE.Mesh(headGeo, headMat);
      headMesh.position.y = 1.8;
      group.add(headMesh);

      var pointLight = new THREE.PointLight(0x00ffaa, 0.5, 3);
      pointLight.position.y = 1.0;
      group.add(pointLight);

      var canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
      var ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0, 0, 256, 64);
      ctx.font = 'bold 20px Arial';
      ctx.fillStyle = '#00ffaa';
      ctx.textAlign = 'center';
      ctx.fillText(playerName || playerId.substring(0, 8), 128, 40);

      var nameTex = new THREE.CanvasTexture(canvas);
      var nameGeo = new THREE.PlaneGeometry(1.5, 0.4);
      var nameMat = new THREE.MeshBasicMaterial({
        map: nameTex,
        transparent: true,
        depthWrite: false,
        side: THREE.DoubleSide
      });
      var namePlane = new THREE.Mesh(nameGeo, nameMat);
      namePlane.position.y = 2.3;
      namePlane.userData.isNameTag = true;
      group.add(namePlane);

      group.userData.playerId = playerId;
      group.userData.playerName = playerName;
      group.userData.nameTag = namePlane;

      window.GameEngine.scene.add(group);
      _playerMeshes.set(playerId, group);
      return group;
    } catch(e) {
      console.error('Error creating player mesh:', e);
      return null;
    }
  }

  function _removePlayerMesh(playerId) {
    try {
      if (_playerMeshes.has(playerId)) {
        var mesh = _playerMeshes.get(playerId);
        if (window.GameEngine && window.GameEngine.scene) {
          window.GameEngine.scene.remove(mesh);
        }
        mesh.traverse(function(child) {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(function(m) { m.dispose(); });
            } else {
              child.material.dispose();
            }
          }
        });
        _playerMeshes.delete(playerId);
      }
    } catch(e) {
      console.error('Error removing player mesh:', e);
    }
  }

  function _updateNameTagRotation() {
    try {
      if (!window.GameEngine || !window.GameEngine.camera) return;
      var camera = window.GameEngine.camera;
      _playerMeshes.forEach(function(group) {
        group.traverse(function(child) {
          if (child.userData && child.userData.isNameTag) {
            child.lookAt(camera.position);
          }
        });
      });
    } catch(e) {}
  }

  function _sendPosition() {
    try {
      if (!window.GameEngine || !window.GameEngine.player) return;
      if (!window.GameState || !window.GameState.isRunning) return;
      var player = window.GameEngine.player;
      var pos = player.position || { x: 0, y: 0, z: 0 };
      var rot = player.rotation ? player.rotation.y : 0;
      _broadcast({
        type: 'position',
        id: _myId,
        pos: { x: pos.x, y: pos.y, z: pos.z },
        rot: rot
      });
    } catch(e) {
      console.error('Error sending position:', e);
    }
  }

  function _sendAlisaUpdate() {
    try {
      if (!_isHost) return;
      if (!window.GameEngine || !window.GameEngine.scene) return;
      var alisa = window.GameEngine.scene.getObjectByName('alisa');
      if (!alisa) return;
      var isHunting = alisa.userData && alisa.userData.isHunting;
      _broadcast({
        type: 'alisa',
        pos: { x: alisa.position.x, y: alisa.position.y, z: alisa.position.z },
        isHunting: !!isHunting
      });
    } catch(e) {
      console.error('Error sending alisa update:', e);
    }
  }

  function _startPositionUpdates() {
    if (_positionInterval) clearInterval(_positionInterval);
    _positionInterval = setInterval(function() {
      try {
        _sendPosition();
        if (_isHost) _sendAlisaUpdate();
        _updateNameTagRotation();
      } catch(e) {
        console.error('Position update error:', e);
      }
    }, 100);
  }

  function _stopPositionUpdates() {
    if (_positionInterval) {
      clearInterval(_positionInterval);
      _positionInterval = null;
    }
  }

  function _handleData(data, fromId) {
    try {
      if (!data || !data.type) return;

      switch (data.type) {
        case 'join':
          if (_isHost) {
            var playerData = { id: fromId, name: data.name || 'Desconocido', position: { x: 0, y: 0, z: 0 }, rot: 0 };
            _players.set(fromId, playerData);
            _createPlayerMesh(fromId, data.name || 'Desconocido');
            _updatePlayerListUI();
            var list = [];
            _players.forEach(function(p) { list.push(p); });
            var myName = (window.GameState && window.GameState.playerName) ? window.GameState.playerName : 'Host';
            list.push({ id: _myId, name: myName, position: { x: 0, y: 0, z: 0 }, rot: 0 });
            _broadcast({ type: 'players', list: list });
          }
          break;

        case 'players':
          if (!_isHost && data.list) {
            _players.clear();
            data.list.forEach(function(p) {
              if (p.id !== _myId) {
                _players.set(p.id, p);
                if (!_playerMeshes.has(p.id)) {
                  _createPlayerMesh(p.id, p.name);
                }
              }
            });
            _updatePlayerListUI();
          }
          break;

        case 'position':
          if (data.id && data.id !== _myId && data.pos) {
            if (_players.has(data.id)) {
              var pd = _players.get(data.id);
              pd.position = data.pos;
              pd.rot = data.rot || 0;
              _players.set(data.id, pd);
            }
            if (_playerMeshes.has(data.id)) {
              var mesh = _playerMeshes.get(data.id);
              mesh.position.set(data.pos.x, data.pos.y, data.pos.z);
              if (data.rot !== undefined) mesh.rotation.y = data.rot;
            }
            if (_isHost) {
              _relayToOthers(data, fromId);
            }
          }
          break;

        case 'alisa':
          if (!_isHost && data.pos) {
            try {
              if (window.GameEngine && window.GameEngine.scene) {
                var alisaObj = window.GameEngine.scene.getObjectByName('alisa');
                if (alisaObj) {
                  alisaObj.position.set(data.pos.x, data.pos.y, data.pos.z);
                  if (alisaObj.userData) alisaObj.userData.isHunting = data.isHunting;
                }
              }
            } catch(e) {}
          }
          break;

        case 'item':
          if (data.itemId && data.playerId) {
            if (window.GameState && window.GameState.items) {
              var itemIdx = window.GameState.items.findIndex(function(it) { return it.id === data.itemId; });
              if (itemIdx !== -1) {
                window.GameState.items[itemIdx].collected = true;
                window.GameState.items[itemIdx].collectedBy = data.playerId;
              }
            }
            if (_isHost) _relayToOthers(data, fromId);
          }
          break;

        case 'objective':
          if (data.index !== undefined && window.GameState && window.GameState.objectives) {
            if (window.GameState.objectives[data.index]) {
              window.GameState.objectives[data.index].completed = true;
            }
            if (window.UIManager) window.UIManager.updateHUD();
            if (_isHost) _relayToOthers(data, fromId);
          }
          break;

        case 'start':
          if (!_isHost) {
            if (window.UIManager) window.UIManager.showScreen('game-container');
            if (window.UIManager) window.UIManager.showScreen('hud-overlay');
            if (window.UIManager) window.UIManager.hideScreen('lobby-screen');
            if (window.GameState) window.GameState.isRunning = true;
            _startPositionUpdates();
          }
          break;

        case 'chat':
          if (data.name && data.msg) {
            console.log('[Chat] ' + data.name + ': ' + data.msg);
            if (window.UIManager) {
              window.UIManager.showSubtitle(data.name + ': ' + data.msg, 4000);
            }
            if (_isHost) _relayToOthers(data, fromId);
          }
          break;

        default:
          break;
      }

      if (_dataCallback) {
        try { _dataCallback(data, fromId); } catch(e) { console.error('Data callback error:', e); }
      }
    } catch(e) {
      console.error('Error handling data:', e);
    }
  }

  function _relayToOthers(data, excludeId) {
    try {
      _connections.forEach(function(conn) {
        try {
          if (conn && conn.open && conn.peer !== excludeId) {
            conn.send(data);
          }
        } catch(e) {}
      });
    } catch(e) {
      console.error('Error relaying data:', e);
    }
  }

  function _broadcast(data) {
    try {
      _connections.forEach(function(conn) {
        try {
          if (conn && conn.open) {
            conn.send(data);
          }
        } catch(e) {}
      });
    } catch(e) {
      console.error('Error broadcasting:', e);
    }
  }

  function _updatePlayerListUI() {
    try {
      var listEl = document.getElementById('player-list');
      if (!listEl) return;
      listEl.innerHTML = '';
      var myName = (window.GameState && window.GameState.playerName) ? window.GameState.playerName : 'TÃº';
      var myItem = document.createElement('div');
      myItem.className = 'player-list-item';
      myItem.style.cssText = 'padding:5px 10px;color:#00ffaa;font-family:monospace;';
      myItem.textContent = (_isHost ? 'ð ' : 'â¢ ') + myName + ' (TÃº)';
      listEl.appendChild(myItem);
      _players.forEach(function(p, id) {
        if (id === _myId) return;
        var item = document.createElement('div');
        item.className = 'player-list-item';
        item.style.cssText = 'padding:5px 10px;color:#aaffdd;font-family:monospace;';
        item.textContent = 'â¢ ' + (p.name || id.substring(0, 8));
        listEl.appendChild(item);
      });
      var codeDisplay = document.getElementById('room-code-display');
      if (codeDisplay && _roomCode) {
        codeDisplay.textContent = 'CÃ³digo: ' + _roomCode;
      }
      var startBtn = document.getElementById('btn-start-game');
      if (startBtn) {
        startBtn.style.display = _isHost ? 'block' : 'none';
      }
    } catch(e) {
      console.error('Error updating player list UI:', e);
    }
  }

  function _setupConnection(conn) {
    try {
      conn.on('open', function() {
        try {
          console.log('ConexiÃ³n abierta con:', conn.peer);
          if (!_connections.find(function(c) { return c.peer === conn.peer; })) {
            _connections.push(conn);
          }
        } catch(e) {}
      });

      conn.on('data', function(data) {
        try {
          _handleData(data, conn.peer);
        } catch(e) {
          console.error('Error in conn.on(data):', e);
        }
      });

      conn.on('close', function() {
        try {
          console.log('ConexiÃ³n cerrada con:', conn.peer);
          _connections = _connections.filter(function(c) { return c.peer !== conn.peer; });
          if (_players.has(conn.peer)) {
            var playerName = _players.get(conn.peer).name || conn.peer;
            _players.delete(conn.peer);
            _removePlayerMesh(conn.peer);
            _updatePlayerListUI();
            if (window.UIManager) {
              window.UIManager.showSubtitle(playerName + ' se ha desconectado', 3000);
            }
            if (_isHost) {
              var list = [];
              _players.forEach(function(p) { list.push(p); });
              var myName2 = (window.GameState && window.GameState.playerName) ? window.GameState.playerName : 'Host';
              list.push({ id: _myId, name: myName2, position: { x: 0, y: 0, z: 0 }, rot: 0 });
              _broadcast({ type: 'players', list: list });
            }
          }
        } catch(e) {
          console.error('Error on connection close:', e);
        }
      });

      conn.on('error', function(err) {
        console.error('Error en conexiÃ³n con ' + conn.peer + ':', err);
        _connections = _connections.filter(function(c) { return c.peer !== conn.peer; });
      });
    } catch(e) {
      console.error('Error setting up connection:', e);
    }
  }

  var MM = {
    peer: null,
    connections: _connections,
    roomCode: '',
    isHost: false,
    players: _players,
    myId: '',

    init: function() {
      return new Promise(function(resolve, reject) {
        try {
          if (typeof Peer === 'undefined') {
            reject(new Error('PeerJS no estÃ¡ disponible'));
            return;
          }

          if (_peer) {
            try { _peer.destroy(); } catch(e) {}
            _peer = null;
          }

          var randomId = 'esin-player-' + Math.random().toString(36).substr(2, 9);

          var peerConfig = {
            debug: 0,
            config: {
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
              ]
            }
          };

          try {
            _peer = new Peer(randomId, peerConfig);
          } catch(e) {
            try {
              _peer = new Peer(peerConfig);
            } catch(e2) {
              reject(e2);
              return;
            }
          }

          var timeout = setTimeout(function() {
            try {
              reject(new Error('Tiempo de espera agotado al conectar con el servidor de seÃ±alizaciÃ³n'));
            } catch(e) {}
          }, 10000);

          _peer.on('open', function(id) {
            try {
              clearTimeout(timeout);
              _myId = id;
              MM.myId = id;
              MM.peer = _peer;
              console.log('PeerJS inicializado con ID:', id);

              _peer.on('connection', function(conn) {
                try {
                  if (_connections.length >= MAX_PLAYERS - 1) {
                    conn.close();
                    return;
                  }
                  _setupConnection(conn);
                  conn.on('open', function() {
                    try {
                      if (!_players.has(conn.peer)) {
                        _players.set(conn.peer, { id: conn.peer, name: 'Conectando...', position: { x: 0, y: 0, z: 0 }, rot: 0 });
                      }
                    } catch(e) {}
                  });
                } catch(e) {
                  console.error('Error handling incoming connection:', e);
                }
              });

              _peer.on('error', function(err) {
                console.error('PeerJS error:', err);
                if (err.type === 'peer-unavailable') {
                  if (window.UIManager) window.UIManager.showSubtitle('No se puede conectar al jugador', 3000);
                } else if (err.type === 'network' || err.type === 'server-error') {
                  if (_reconnectAttempts < MAX_RECONNECT) {
                    _reconnectAttempts++;
                    setTimeout(function() {
                      try { MM.init(); } catch(e) {}
                    }, 2000 * _reconnectAttempts);
                  }
                }
              });

              _peer.on('disconnected', function() {
                console.warn('PeerJS desconectado del servidor, intentando reconectar...');
                try {
                  if (_peer && !_peer.destroyed) {
                    _peer.reconnect();
                  }
                } catch(e) {}
              });

              resolve(id);
            } catch(e) {
              clearTimeout(timeout);
              reject(e);
            }
          });

          _peer.on('error', function(err) {
            clearTimeout(timeout);
            console.error('PeerJS init error:', err);
            reject(err);
          });

        } catch(e) {
          reject(e);
        }
      });
    },

    createRoom: function() {
      try {
        _roomCode = _generateRoomCode();
        _isHost = true;
        MM.isHost = true;
        MM.roomCode = _roomCode;
        if (window.GameState) window.GameState.isHost = true;
        console.log('Sala creada con cÃ³digo:', _roomCode);
        _updatePlayerListUI();
        return _roomCode;
      } catch(e) {
        console.error('Error creating room:', e);
        return '';
      }
    },

    joinRoom: function(code) {
      return new Promise(function(resolve, reject) {
        try {
          if (!code) {
            reject(new Error('CÃ³digo de sala invÃ¡lido'));
            return;
          }

          code = code.toUpperCase().trim();
          _roomCode = code;
          MM.roomCode = code;
          _isHost = false;
          MM.isHost = false;
          if (window.GameState) window.GameState.isHost = false;

          if (!_peer) {
            reject(new Error('PeerJS no inicializado'));
            return;
          }

          var hostPeerId = 'esin-player-' + code.toLowerCase();

          var timeout = setTimeout(function() {
            try {
              reject(new Error('Tiempo de espera agotado al unirse a la sala'));
            } catch(e) {}
          }, 10000);

          var tryConnect = function(peerId) {
            try {
              var conn = _peer.connect(peerId, {
                reliable: true,
                serialization: 'json'
              });

              if (!conn) {
                clearTimeout(timeout);
                reject(new Error('No se pudo crear la conexiÃ³n'));
                return;
              }

              _setupConnection(conn);

              conn.on('open', function() {
                try {
                  clearTimeout(timeout);
                  var playerName = (window.GameState && window.GameState.playerName) ? window.GameState.playerName : 'Jugador';
                  conn.send({ type: 'join', name: playerName });
                  _updatePlayerListUI();
                  resolve(conn);
                } catch(e) {
                  reject(e);
                }
              });

              conn.on('error', function(err) {
                clearTimeout(timeout);
                console.error('Error connecting to host:', err);
                reject(err);
              });
            } catch(e) {
              clearTimeout(timeout);
              reject(e);
            }
          };

          var altHostId = 'esin-' + code;
          tryConnect(altHostId);

        } catch(e) {
          reject(e);
        }
      });
    },

    broadcast: function(data) {
      try {
        _broadcast(data);
      } catch(e) {
        console.error('Error in broadcast:', e);
      }
    },

    onData: function(callback) {
      try {
        if (typeof callback === 'function') {
          _dataCallback = callback;
        }
      } catch(e) {
        console.error('Error setting data callback:', e);
      }
    },

    disconnect: function() {
      try {
        _stopPositionUpdates();
        _connections.forEach(function(conn) {
          try { if (conn && conn.open) conn.close(); } catch(e) {}
        });
        _connections.length = 0;
        MM.connections = _connections;
        _players.forEach(function(p, id) {
          _removePlayerMesh(id);
        });
        _players.clear();
        _isHost = false;
        MM.isHost = false;
        _roomCode = '';
        MM.roomCode = '';
        if (_peer && !_peer.destroyed) {
          try { _peer.destroy(); } catch(e) {}
          _peer = null;
          MM.peer = null;
        }
        console.log('MultiplayerManager desconectado');
      } catch(e) {
        console.error('Error disconnecting:', e);
      }
    },

    getPlayerCount: function() {
      try {
        return _players.size + 1;
      } catch(e) {
        return 1;
      }
    },

    startGame: function() {
      try {
        if (!_isHost) return;
        _broadcast({ type: 'start' });
        if (window.GameState) window.GameState.isRunning = true;
        _startPositionUpdates();
        if (window.UIManager) {
          window.UIManager.showScreen('game-container');
          window.UIManager.showScreen('hud-overlay');
          window.UIManager.hideScreen('lobby-screen');
        }
      } catch(e) {
        console.error('Error starting game:', e);
      }
    },

    sendItemPickup: function(itemId) {
      try {
        var data = { type: 'item', itemId: itemId, playerId: _myId };
        _broadcast(data);
      } catch(e) {
        console.error('Error sending item pickup:', e);
      }
    },

    sendObjectiveProgress: function(index) {
      try {
        var data = { type: 'objective', index: index };
        _broadcast(data);
      } catch(e) {
        console.error('Error sending objective progress:', e);
      }
    },

    sendChat: function(msg) {
      try {
        var playerName = (window.GameState && window.GameState.playerName) ? window.GameState.playerName : 'Jugador';
        var data = { type: 'chat', name: playerName, msg: msg };
        _broadcast(data);
        if (_dataCallback) _dataCallback(data, _myId);
      } catch(e) {
        console.error('Error sending chat:', e);
      }
    },

    startPositionUpdates: function() {
      try {
        _startPositionUpdates();
      } catch(e) {
        console.error('Error starting position updates:', e);
      }
    },

    stopPositionUpdates: function() {
      try {
        _stopPositionUpdates();
      } catch(e) {
        console.error('Error stopping position updates:', e);
      }
    },

    updatePlayerMeshes: function() {
      try {
        _updateNameTagRotation();
      } catch(e) {}
    }
  };

  return MM;
})();
} catch(e) { console.error('MultiplayerManager init error:', e); }
</script>

<script>
// ============================================================
// SECTION 6: UI, INPUT, MOBILE & BOOTSTRAP
// ============================================================
try {
(function() {

  // ============================================================
  // UIManager
  // ============================================================
  window.UIManager = {
    _subtitleTimer: null,

    showScreen: function(id) {
      try {
        var screens = [
          'main-menu', 'game-container', 'hud-overlay', 'loading-screen',
          'lobby-screen', 'settings-screen', 'pause-menu', 'death-screen'
        ];
        screens.forEach(function(sid) {
          try {
            var el = document.getElementById(sid);
            if (el) {
              if (sid === id) {
                el.style.display = '';
                el.classList.remove('hidden');
              } else {
                if (sid !== 'hud-overlay' && sid !== 'game-container') {
                  el.style.display = 'none';
                  el.classList.add('hidden');
                } else if (sid !== id) {
                  if (id !== 'game-container' && id !== 'hud-overlay' && id !== 'pause-menu' && id !== 'death-screen') {
                    el.style.display = 'none';
                    el.classList.add('hidden');
                  }
                }
              }
            }
          } catch(e) { console.error('showScreen inner error:', e); }
        });
        var target = document.getElementById(id);
        if (target) {
          target.style.display = '';
          target.classList.remove('hidden');
        }
      } catch(e) { console.error('showScreen error:', e); }
    },

    hideScreen: function(id) {
      try {
        var el = document.getElementById(id);
        if (el) {
          el.style.display = 'none';
          el.classList.add('hidden');
        }
      } catch(e) { console.error('hideScreen error:', e); }
    },

    updateHUD: function() {
      try {
        var gs = window.GameState;
        if (!gs) return;

        // Sanity bar
        var sanityBar = document.getElementById('sanity-bar');
        var sanityValue = document.getElementById('sanity-value');
        if (sanityBar) {
          var s = Math.max(0, Math.min(100, gs.sanity));
          sanityBar.style.width = s + '%';
          if (s > 70) {
            sanityBar.style.backgroundColor = '#4caf50';
          } else if (s > 40) {
            sanityBar.style.backgroundColor = '#ffeb3b';
          } else if (s > 10) {
            sanityBar.style.backgroundColor = '#ff9800';
          } else {
            sanityBar.style.backgroundColor = '#f44336';
            // Hallucination pulse
            sanityBar.style.boxShadow = '0 0 10px #f44336';
          }
          if (s > 10) sanityBar.style.boxShadow = 'none';
        }
        if (sanityValue) {
          sanityValue.textContent = Math.floor(gs.sanity) + '%';
        }

        // Stamina bar
        var staminaBar = document.getElementById('stamina-bar');
        if (staminaBar) {
          var st = Math.max(0, Math.min(100, gs.stamina));
          staminaBar.style.width = st + '%';
          if (st < 20) {
            staminaBar.style.backgroundColor = '#ff5722';
          } else {
            staminaBar.style.backgroundColor = '#2196f3';
          }
        }

        // Objective
        var objText = document.getElementById('objective-text');
        if (objText) {
          objText.textContent = gs.currentObjective || 'Explora el orfanato...';
        }

        // Inventory item slots
        var itemSlots = document.getElementById('item-slots');
        if (itemSlots) {
          itemSlots.innerHTML = '';
          var itemIcons = {
            'vela': 'ð¯ï¸',
            'llave': 'ðï¸',
            'diario': 'ð',
            'amuleto': 'ð¿',
            'foto': 'ð¼ï¸',
            'cruz': 'âï¸',
            'campana': 'ð',
            'sal': 'ð§',
            'espejo': 'ðª',
            'cuerda': 'ðª¢'
          };
          var inv = gs.inventory || [];
          for (var i = 0; i < 6; i++) {
            var slot = document.createElement('div');
            slot.style.cssText = 'width:40px;height:40px;border:1px solid rgba(255,255,255,0.3);border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:20px;background:rgba(0,0,0,0.5);';
            if (inv[i]) {
              slot.textContent = itemIcons[inv[i]] || 'â';
              slot.title = inv[i];
            }
            itemSlots.appendChild(slot);
          }
        }
      } catch(e) { console.error('updateHUD error:', e); }
    },

    showInteraction: function(text) {
      try {
        var el = document.getElementById('interaction-prompt');
        if (el) {
          el.textContent = text || '';
          el.style.display = 'block';
          el.classList.remove('hidden');
        }
      } catch(e) { console.error('showInteraction error:', e); }
    },

    hideInteraction: function() {
      try {
        var el = document.getElementById('interaction-prompt');
        if (el) {
          el.style.display = 'none';
          el.classList.add('hidden');
        }
      } catch(e) { console.error('hideInteraction error:', e); }
    },

    showSubtitle: function(text, duration) {
      try {
        var el = document.getElementById('subtitle-text');
        if (!el) return;
        el.textContent = text || '';
        el.style.display = 'block';
        el.classList.remove('hidden');
        if (this._subtitleTimer) clearTimeout(this._subtitleTimer);
        var self = this;
        this._subtitleTimer = setTimeout(function() {
          try {
            el.style.display = 'none';
            el.classList.add('hidden');
          } catch(e) {}
        }, duration || 3000);
      } catch(e) { console.error('showSubtitle error:', e); }
    },

    addChatMessage: function(name, msg) {
      try {
        var chatLog = document.getElementById('chat-log');
        if (!chatLog) return;
        var line = document.createElement('div');
        line.style.cssText = 'padding:2px 0;color:#ccc;font-size:13px;';
        line.innerHTML = '<strong style="color:#e8d5b7;">' + name + ':</strong> ' + msg;
        chatLog.appendChild(line);
        chatLog.scrollTop = chatLog.scrollHeight;
      } catch(e) { console.error('addChatMessage error:', e); }
    },

    updatePlayerList: function(players) {
      try {
        var el = document.getElementById('player-list');
        if (!el) return;
        el.innerHTML = '';
        (players || []).forEach(function(p) {
          try {
            var item = document.createElement('div');
            item.style.cssText = 'padding:6px 10px;margin:3px 0;background:rgba(255,255,255,0.05);border-radius:4px;color:#e8d5b7;font-size:14px;display:flex;align-items:center;gap:8px;';
            var dot = document.createElement('span');
            dot.style.cssText = 'width:8px;height:8px;border-radius:50%;background:#4caf50;display:inline-block;';
            item.appendChild(dot);
            var nameSpan = document.createElement('span');
            nameSpan.textContent = p.name || p;
            item.appendChild(nameSpan);
            if (p.isHost) {
              var hostBadge = document.createElement('span');
              hostBadge.textContent = '[AnfitriÃ³n]';
              hostBadge.style.cssText = 'font-size:11px;color:#ff9800;margin-left:auto;';
              item.appendChild(hostBadge);
            }
            el.appendChild(item);
          } catch(e) {}
        });
      } catch(e) { console.error('updatePlayerList error:', e); }
    }
  };

  // ============================================================
  // InputManager
  // ============================================================
  window.InputManager = {
    keys: {},
    mouse: { x: 0, y: 0, dx: 0, dy: 0 },
    _touchMove: { x: 0, y: 0 },
    _joystickActive: false,
    _joystickOrigin: { x: 0, y: 0 },

    init: function() {
      try {
        var self = this;

        // Keyboard
        document.addEventListener('keydown', function(e) {
          try {
            self.keys[e.key.toLowerCase()] = true;
            self.keys[e.code ? e.code.toLowerCase() : ''] = true;
          } catch(err) {}
        });

        document.addEventListener('keyup', function(e) {
          try {
            self.keys[e.key.toLowerCase()] = false;
            self.keys[e.code ? e.code.toLowerCase() : ''] = false;
          } catch(err) {}
        });

        // Mouse movement (pointer lock)
        document.addEventListener('mousemove', function(e) {
          try {
            if (document.pointerLockElement) {
              self.mouse.dx = e.movementX || 0;
              self.mouse.dy = e.movementY || 0;
            } else {
              self.mouse.dx = 0;
              self.mouse.dy = 0;
            }
            self.mouse.x = e.clientX;
            self.mouse.y = e.clientY;
          } catch(err) {}
        });

        // Reset dx/dy after each frame
        function resetMouseDelta() {
          self.mouse.dx = 0;
          self.mouse.dy = 0;
        }
        // We'll reset after reading in game loop, but also do a fallback
        document.addEventListener('mouseup', function() {
          try { resetMouseDelta(); } catch(err) {}
        });

        // Pointer lock click on game container
        var gc = document.getElementById('game-container');
        if (gc) {
          gc.addEventListener('click', function() {
            try {
              if (!document.pointerLockElement && window.GameState && window.GameState.isRunning) {
                gc.requestPointerLock();
              }
            } catch(err) {}
          });
        }

        // Pointer lock change
        document.addEventListener('pointerlockchange', function() {
          try {
            if (!document.pointerLockElement && window.GameState && window.GameState.isRunning && !window.GameState.isPaused) {
              // Optionally auto-pause
            }
          } catch(err) {}
        });

        console.log('[InputManager] Inicializado');
      } catch(e) { console.error('InputManager.init error:', e); }
    },

    isPressed: function(key) {
      try {
        return !!this.keys[key.toLowerCase()];
      } catch(e) { return false; }
    },

    isMobile: function() {
      try {
        return ('ontouchstart' in window) ||
               (navigator.maxTouchPoints > 0) ||
               /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);
      } catch(e) { return false; }
    },

    setupMobile: function() {
      try {
        var self = this;
        var jz = document.getElementById('joystick-zone');
        if (jz) {
          jz.style.cssText += 'position:relative;overflow:hidden;';

          // Create knob
          var knob = document.createElement('div');
          knob.id = 'joystick-knob';
          knob.style.cssText = 'width:50px;height:50px;border-radius:50%;background:rgba(255,255,255,0.5);position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);pointer-events:none;transition:background 0.1s;';
          jz.appendChild(knob);

          var baseX = 0, baseY = 0;
          var maxRadius = 40;

          jz.addEventListener('touchstart', function(e) {
            try {
              e.preventDefault();
              self._joystickActive = true;
              var rect = jz.getBoundingClientRect();
              var t = e.touches[0];
              baseX = t.clientX - rect.left;
              baseY = t.clientY - rect.top;
              self._joystickOrigin = { x: baseX, y: baseY };
              knob.style.left = baseX + 'px';
              knob.style.top = baseY + 'px';
              knob.style.transform = 'translate(-50%,-50%)';
            } catch(err) {}
          }, { passive: false });

          jz.addEventListener('touchmove', function(e) {
            try {
              e.preventDefault();
              if (!self._joystickActive) return;
              var rect = jz.getBoundingClientRect();
              var t = e.touches[0];
              var cx = t.clientX - rect.left;
              var cy = t.clientY - rect.top;
              var dx = cx - self._joystickOrigin.x;
              var dy = cy - self._joystickOrigin.y;
              var dist = Math.sqrt(dx*dx + dy*dy);
              if (dist > maxRadius) {
                dx = dx / dist * maxRadius;
                dy = dy / dist * maxRadius;
              }
              knob.style.left = (self._joystickOrigin.x + dx) + 'px';
              knob.style.top = (self._joystickOrigin.y + dy) + 'px';
              // Map to keys
              var nx = dx / maxRadius;
              var ny = dy / maxRadius;
              self._touchMove = { x: nx, y: ny };
              // Simulate key presses based on direction
              self.keys['w'] = ny < -0.3;
              self.keys['s'] = ny > 0.3;
              self.keys['a'] = nx < -0.3;
              self.keys['d'] = nx > 0.3;
              self.keys['arrowup'] = ny < -0.3;
              self.keys['arrowdown'] = ny > 0.3;
              self.keys['arrowleft'] = nx < -0.3;
              self.keys['arrowright'] = nx > 0.3;
            } catch(err) {}
          }, { passive: false });

          function resetJoystick() {
            try {
              self._joystickActive = false;
              self._touchMove = { x: 0, y: 0 };
              self.keys['w'] = false;
              self.keys['s'] = false;
              self.keys['a'] = false;
              self.keys['d'] = false;
              self.keys['arrowup'] = false;
              self.keys['arrowdown'] = false;
              self.keys['arrowleft'] = false;
              self.keys['arrowright'] = false;
              knob.style.left = '50%';
              knob.style.top = '50%';
              knob.style.transform = 'translate(-50%,-50%)';
            } catch(err) {}
          }

          jz.addEventListener('touchend', resetJoystick, { passive: true });
          jz.addEventListener('touchcancel', resetJoystick, { passive: true });
        }

        // Mobile buttons
        var btnInteract = document.getElementById('btn-mobile-interact');
        if (btnInteract) {
          btnInteract.addEventListener('touchstart', function(e) {
            try { e.preventDefault(); self.keys['e'] = true; } catch(err) {}
          }, { passive: false });
          btnInteract.addEventListener('touchend', function(e) {
            try { e.preventDefault(); self.keys['e'] = false; } catch(err) {}
          }, { passive: false });
        }

        var btnSprint = document.getElementById('btn-mobile-sprint');
        if (btnSprint) {
          btnSprint.addEventListener('touchstart', function(e) {
            try { e.preventDefault(); self.keys['shift'] = true; } catch(err) {}
          }, { passive: false });
          btnSprint.addEventListener('touchend', function(e) {
            try { e.preventDefault(); self.keys['shift'] = false; } catch(err) {}
          }, { passive: false });
        }

        var btnFlashlight = document.getElementById('btn-mobile-flashlight');
        if (btnFlashlight) {
          btnFlashlight.addEventListener('touchstart', function(e) {
            try {
              e.preventDefault();
              if (window.GameEngine && window.GameEngine.flashlight) {
                window.GameEngine.flashlight.visible = !window.GameEngine.flashlight.visible;
              }
            } catch(err) {}
          }, { passive: false });
        }

        // Touch look (on game container)
        var gc = document.getElementById('game-container');
        if (gc) {
          var lastTouchX = null, lastTouchY = null;
          gc.addEventListener('touchstart', function(e) {
            try {
              if (e.touches.length === 1) {
                var jzRect = document.getElementById('joystick-zone') ? document.getElementById('joystick-zone').getBoundingClientRect() : null;
                var t = e.touches[0];
                if (jzRect && t.clientX >= jzRect.left && t.clientX <= jzRect.right &&
                    t.clientY >= jzRect.top && t.clientY <= jzRect.bottom) return;
                lastTouchX = t.clientX;
                lastTouchY = t.clientY;
              }
            } catch(err) {}
          }, { passive: true });

          gc.addEventListener('touchmove', function(e) {
            try {
              if (e.touches.length === 1 && lastTouchX !== null) {
                var t = e.touches[0];
                var dx = t.clientX - lastTouchX;
                var dy = t.clientY - lastTouchY;
                window.InputManager.mouse.dx += dx * 0.5;
                window.InputManager.mouse.dy += dy * 0.5;
                lastTouchX = t.clientX;
                lastTouchY = t.clientY;
              }
            } catch(err) {}
          }, { passive: true });

          gc.addEventListener('touchend', function() {
            try { lastTouchX = null; lastTouchY = null; } catch(err) {}
          }, { passive: true });
        }

        console.log('[InputManager] Controles mÃ³viles configurados');
      } catch(e) { console.error('setupMobile error:', e); }
    }
  };

  // ============================================================
  // Bootstrap / Initialization
  // ============================================================

  var loadingMessages = [
    'Conectando con el mÃ¡s allÃ¡...',
    'Los susurros se acercan...',
    'Ella te estÃ¡ esperando...',
    'El orfanato despierta...',
    'Alisa abre los ojos...'
  ];

  var gameLoopId = null;
  var lastTime = 0;
  var loadingMsgIndex = 0;
  var loadingInterval = null;

  function cycleLoadingMessages() {
    try {
      var msgEl = document.getElementById('loading-message') || document.querySelector('#loading-screen p') || document.querySelector('#loading-screen .loading-msg');
      if (!msgEl) {
        // Try to find any p inside loading screen
        var ls = document.getElementById('loading-screen');
        if (ls) {
          var ps = ls.querySelectorAll('p, span, div.msg');
          if (ps.length > 0) msgEl = ps[0];
        }
      }
      if (msgEl) {
        msgEl.textContent = loadingMessages[loadingMsgIndex % loadingMessages.length];
      }
      loadingMsgIndex++;
    } catch(e) {}
  }

  function showLoadingScreen(callback) {
    try {
      UIManager.showScreen('loading-screen');
      UIManager.hideScreen('main-menu');
      UIManager.hideScreen('lobby-screen');
      loadingMsgIndex = 0;
      cycleLoadingMessages();
      if (loadingInterval) clearInterval(loadingInterval);
      loadingInterval = setInterval(cycleLoadingMessages, 800);
      setTimeout(function() {
        try {
          clearInterval(loadingInterval);
          loadingInterval = null;
          if (callback) callback();
        } catch(e) { console.error('Loading callback error:', e); }
      }, 3000);
    } catch(e) { console.error('showLoadingScreen error:', e); }
  }

  function startGame(isMultiplayer) {
    try {
      // Initialize GameEngine
      if (window.GameEngine && typeof window.GameEngine.init === 'function') {
        window.GameEngine.init();
      } else {
        console.error('[Bootstrap] GameEngine no disponible');
      }

      // Initialize AudioManager
      if (window.AudioManager && typeof window.AudioManager.init === 'function') {
        window.AudioManager.init();
      } else {
        console.error('[Bootstrap] AudioManager no disponible');
      }

      // Initialize InputManager
      if (window.InputManager && typeof window.InputManager.init === 'function') {
        window.InputManager.init();
      }

      // Initialize GameState
      if (window.GameState) {
        window.GameState.sanity = 100;
        window.GameState.stamina = 100;
        window.GameState.isRunning = true;
        window.GameState.isPaused = false;
        window.GameState.inventory = [];
        window.GameState.alisaPhase = 1;
        window.GameState.currentObjective = 'Encuentra la sala ritual en el orfanato';
        window.GameState.items = [];
        if (!window.GameState.objectives) window.GameState.objectives = [];
      }

      // Show game screens
      UIManager.hideScreen('loading-screen');
      UIManager.hideScreen('main-menu');
      UIManager.hideScreen('lobby-screen');
      UIManager.hideScreen('pause-menu');
      UIManager.hideScreen('death-screen');

      var gc = document.getElementById('game-container');
      if (gc) { gc.style.display = 'block'; gc.classList.remove('hidden'); }
      var hud = document.getElementById('hud-overlay');
      if (hud) { hud.style.display = 'block'; hud.classList.remove('hidden'); }

      // Mobile setup
      if (window.InputManager.isMobile()) {
        var mc = document.getElementById('mobile-controls');
        if (mc) { mc.style.display = 'flex'; mc.classList.remove('hidden'); }
        window.InputManager.setupMobile();
      }

      // Request pointer lock
      if (gc && !window.InputManager.isMobile()) {
        setTimeout(function() {
          try { gc.requestPointerLock(); } catch(e) {}
        }, 500);
      }

      // Ambient audio
      if (window.AudioManager && typeof window.AudioManager.playAmbient === 'function') {
        try { window.AudioManager.playAmbient(); } catch(e) {}
      }

      // Initial HUD update
      UIManager.updateHUD();

      // Show opening subtitle
      setTimeout(function() {
        try {
          UIManager.showSubtitle('El orfanato lleva dÃ©cadas abandonado... pero algo sigue aquÃ­.', 5000);
        } catch(e) {}
      }, 1000);

      // Start game loop
      if (gameLoopId) cancelAnimationFrame(gameLoopId);
      lastTime = performance.now();

      function gameLoop(timestamp) {
        try {
          if (!window.GameState || !window.GameState.isRunning) return;
          if (window.GameState.isPaused) {
            gameLoopId = requestAnimationFrame(gameLoop);
            return;
          }

          var dt = Math.min((timestamp - lastTime) / 1000, 0.1);
          lastTime = timestamp;

          // Animate (render)
          if (window.GameEngine && typeof window.GameEngine.animate === 'function') {
            try { window.GameEngine.animate(dt); } catch(e) { console.error('GameEngine.animate error:', e); }
          }

          // Update game state
          if (window.GameState && typeof window.GameState.update === 'function') {
            try { window.GameState.update(dt); } catch(e) { console.error('GameState.update error:', e); }
          }

          // Update HUD (every frame is fine)
          try { UIManager.updateHUD(); } catch(e) {}

          // Reset mouse delta
          if (window.InputManager) {
            window.InputManager.mouse.dx = 0;
            window.InputManager.mouse.dy = 0;
          }

          // Check death
          if (window.GameState && window.GameState.sanity <= 0 && window.GameState.isRunning) {
            try { handleDeath(); } catch(e) {}
          }

          gameLoopId = requestAnimationFrame(gameLoop);
        } catch(e) {
          console.error('Game loop error:', e);
          gameLoopId = requestAnimationFrame(gameLoop);
        }
      }

      gameLoopId = requestAnimationFrame(gameLoop);
      console.log('[Bootstrap] Juego iniciado');
    } catch(e) { console.error('startGame error:', e); }
  }

  function stopGame() {
    try {
      if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
      }
      if (window.GameState) {
        window.GameState.isRunning = false;
        window.GameState.isPaused = false;
      }
      if (window.AudioManager && typeof window.AudioManager.stopAll === 'function') {
        try { window.AudioManager.stopAll(); } catch(e) {}
      }
      // Release pointer lock
      try { if (document.pointerLockElement) document.exitPointerLock(); } catch(e) {}

      UIManager.hideScreen('game-container');
      UIManager.hideScreen('hud-overlay');
      UIManager.hideScreen('pause-menu');
      UIManager.hideScreen('death-screen');
      UIManager.hideScreen('mobile-controls');
      UIManager.showScreen('main-menu');
    } catch(e) { console.error('stopGame error:', e); }
  }

  function handleDeath() {
    try {
      if (!window.GameState || !window.GameState.isRunning) return;
      window.GameState.isRunning = false;
      window.GameState.isPaused = false;
      if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
      }
      try { if (document.pointerLockElement) document.exitPointerLock(); } catch(e) {}
      if (window.AudioManager) {
        try { window.AudioManager.stopAll(); } catch(e) {}
        try { window.AudioManager.playEffect('death'); } catch(e) {}
      }
      UIManager.showSubtitle('Alisa te ha encontrado...', 3000);
      setTimeout(function() {
        try {
          var ds = document.getElementById('death-screen');
          if (ds) { ds.style.display = 'flex'; ds.classList.remove('hidden'); }
        } catch(e) {}
      }, 2000);
    } catch(e) { console.error('handleDeath error:', e); }
  }

  function togglePause() {
    try {
      if (!window.GameState || !window.GameState.isRunning) return;
      window.GameState.isPaused = !window.GameState.isPaused;
      var pm = document.getElementById('pause-menu');
      if (pm) {
        if (window.GameState.isPaused) {
          pm.style.display = 'flex';
          pm.classList.remove('hidden');
          try { if (document.pointerLockElement) document.exitPointerLock(); } catch(e) {}
          if (window.AudioManager) {
            try { window.AudioManager.updateSanityAudio(0); } catch(e) {}
          }
        } else {
          pm.style.display = 'none';
          pm.classList.add('hidden');
          var gc = document.getElementById('game-container');
          if (gc && !window.InputManager.isMobile()) {
            try { gc.requestPointerLock(); } catch(e) {}
          }
          if (window.AudioManager && typeof window.AudioManager.playAmbient === 'function') {
            try { window.AudioManager.playAmbient(); } catch(e) {}
          }
        }
      }
    } catch(e) { console.error('togglePause error:', e); }
  }

  // ============================================================
  // DOMContentLoaded - Wire everything up
  // ============================================================
  document.addEventListener('DOMContentLoaded', function() {
    try {
      console.log('[Bootstrap] DOM listo - Iniciando El Susurro de la Inocente');

      // Show main menu
      UIManager.showScreen('main-menu');

      // Ensure other screens are hidden
      UIManager.hideScreen('game-container');
      UIManager.hideScreen('hud-overlay');
      UIManager.hideScreen('loading-screen');
      UIManager.hideScreen('lobby-screen');
      UIManager.hideScreen('settings-screen');
      UIManager.hideScreen('pause-menu');
      UIManager.hideScreen('death-screen');
      UIManager.hideScreen('mobile-controls');

      // ---- SOLO PLAY ----
      var btnSolo = document.getElementById('btn-solo');
      if (btnSolo) {
        btnSolo.addEventListener('click', function() {
          try {
            if (window.GameState) {
              window.GameState.isHost = true;
              window.GameState.playerName = (document.getElementById('input-player-name') && document.getElementById('input-player-name').value.trim()) || 'Explorador';
            }
            showLoadingScreen(function() {
              startGame(false);
            });
          } catch(e) { console.error('btn-solo error:', e); }
        });
      }

      // ---- MULTIPLAYER ----
      var btnMultiplayer = document.getElementById('btn-multiplayer');
      if (btnMultiplayer) {
        btnMultiplayer.addEventListener('click', function() {
          try {
            UIManager.showScreen('lobby-screen');
          } catch(e) { console.error('btn-multiplayer error:', e); }
        });
      }

      // ---- SETTINGS ----
      var btnSettings = document.getElementById('btn-settings');
      if (btnSettings) {
        btnSettings.addEventListener('click', function() {
          try {
            UIManager.showScreen('settings-screen');
          } catch(e) { console.error('btn-settings error:', e); }
        });
      }

      // ---- CREATE ROOM ----
      var btnCreateRoom = document.getElementById('btn-create-room');
      if (btnCreateRoom) {
        btnCreateRoom.addEventListener('click', function() {
          try {
            var nameInput = document.getElementById('input-player-name');
            var playerName = (nameInput && nameInput.value.trim()) || 'AnfitriÃ³n';
            if (window.GameState) {
              window.GameState.playerName = playerName;
              window.GameState.isHost = true;
            }
            if (window.MultiplayerManager && typeof window.MultiplayerManager.init === 'function') {
              window.MultiplayerManager.init();
              window.MultiplayerManager.createRoom();
              // Display room code after short delay
              setTimeout(function() {
                try {
                  var roomCodeDisplay = document.getElementById('room-code-display');
                  if (roomCodeDisplay && window.MultiplayerManager.roomCode) {
                    roomCodeDisplay.textContent = 'CÃ³digo: ' + window.MultiplayerManager.roomCode;
                  }
                  // Update player list
                  UIManager.updatePlayerList([{ name: playerName, isHost: true }]);
                } catch(e) {}
              }, 1500);
            } else {
              // Generate a fake room code for offline testing
              var fakeCode = Math.random().toString(36).substring(2, 8).toUpperCase();
              var roomCodeDisplay = document.getElementById('room-code-display');
              if (roomCodeDisplay) roomCodeDisplay.textContent = 'CÃ³digo: ' + fakeCode;
              UIManager.updatePlayerList([{ name: playerName, isHost: true }]);
            }
          } catch(e) { console.error('btn-create-room error:', e); }
        });
      }

      // ---- JOIN ROOM ----
      var btnJoinRoom = document.getElementById('btn-join-room');
      if (btnJoinRoom) {
        btnJoinRoom.addEventListener('click', function() {
          try {
            var codeInput = document.getElementById('input-room-code');
            var code = codeInput ? codeInput.value.trim() : '';
            var nameInput = document.getElementById('input-player-name');
            var playerName = (nameInput && nameInput.value.trim()) || 'Jugador';
            if (!code) {
              UIManager.showSubtitle('Ingresa un cÃ³digo de sala vÃ¡lido', 3000);
              return;
            }
            if (window.GameState) {
              window.GameState.playerName = playerName;
              window.GameState.isHost = false;
            }
            if (window.MultiplayerManager && typeof window.MultiplayerManager.init === 'function') {
              window.MultiplayerManager.init();
              window.MultiplayerManager.joinRoom(code);
            }
            var roomCodeDisplay = document.getElementById('room-code-display');
            if (roomCodeDisplay) roomCodeDisplay.textContent = 'CÃ³digo: ' + code;
            UIManager.updatePlayerList([{ name: playerName, isHost: false }]);
            UIManager.showSubtitle('Conectando a la sala ' + code + '...', 3000);
          } catch(e) { console.error('btn-join-room error:', e); }
        });
      }

      // ---- START GAME (HOST) ----
      var btnStartGame = document.getElementById('btn-start-game');
      if (btnStartGame) {
        btnStartGame.addEventListener('click', function() {
          try {
            // Broadcast start to all peers
            if (window.MultiplayerManager && typeof window.MultiplayerManager.broadcast === 'function') {
              try { window.MultiplayerManager.broadcast({ type: 'start_game' }); } catch(e) {}
            }
            showLoadingScreen(function() {
              startGame(true);
            });
          } catch(e) { console.error('btn-start-game error:', e); }
        });
      }

      // ---- BACK FROM LOBBY ----
      var btnBackLobby = document.getElementById('btn-back-lobby');
      if (btnBackLobby) {
        btnBackLobby.addEventListener('click', function() {
          try {
            UIManager.showScreen('main-menu');
            // Disconnect multiplayer
            if (window.MultiplayerManager && window.MultiplayerManager.peer) {
              try { window.MultiplayerManager.peer.destroy(); } catch(e) {}
            }
          } catch(e) { console.error('btn-back-lobby error:', e); }
        });
      }

      // ---- BACK FROM SETTINGS ----
      var btnBackSettings = document.getElementById('btn-back-settings');
      if (btnBackSettings) {
        btnBackSettings.addEventListener('click', function() {
          try {
            UIManager.showScreen('main-menu');
          } catch(e) { console.error('btn-back-settings error:', e); }
        });
      }

      // ---- RESUME ----
      var btnResume = document.getElementById('btn-resume');
      if (btnResume) {
        btnResume.addEventListener('click', function() {
          try {
            togglePause();
          } catch(e) { console.error('btn-resume error:', e); }
        });
      }

      // ---- QUIT TO MENU ----
      var btnQuit = document.getElementById('btn-quit');
      if (btnQuit) {
        btnQuit.addEventListener('click', function() {
          try {
            stopGame();
          } catch(e) { console.error('btn-quit error:', e); }
        });
      }

      // ---- RETRY ----
      var btnRetry = document.getElementById('btn-retry');
      if (btnRetry) {
        btnRetry.addEventListener('click', function() {
          try {
            UIManager.hideScreen('death-screen');
            showLoadingScreen(function() {
              startGame(false);
            });
          } catch(e) { console.error('btn-retry error:', e); }
        });
      }

      // ---- ESCAPE KEY - Toggle Pause ----
      document.addEventListener('keydown', function(e) {
        try {
          if (e.key === 'Escape') {
            if (window.GameState && window.GameState.isRunning) {
              togglePause();
            }
          }
        } catch(err) { console.error('Escape key error:', err); }
      });

      // ---- SETTINGS SLIDERS ----
      var sliderVolume = document.getElementById('slider-volume');
      if (sliderVolume) {
        sliderVolume.addEventListener('input', function() {
          try {
            var vol = parseFloat(sliderVolume.value);
            if (window.AudioManager && window.AudioManager.ctx) {
              // If we have a master gain node, use it
              if (window.AudioManager.masterGain) {
                window.AudioManager.masterGain.gain.setTargetAtTime(vol, window.AudioManager.ctx.currentTime, 0.01);
              }
            }
            // Store setting
            if (window.GameSettings) window.GameSettings.volume = vol;
            else window.GameSettings = { volume: vol };
          } catch(e) { console.error('slider-volume error:', e); }
        });
      }

      var sliderSensitivity = document.getElementById('slider-sensitivity');
      if (sliderSensitivity) {
        sliderSensitivity.addEventListener('input', function() {
          try {
            var sens = parseFloat(sliderSensitivity.value);
            if (window.GameSettings) window.GameSettings.sensitivity = sens;
            else window.GameSettings = { sensitivity: sens };
            // GameEngine will read this
            if (window.GameEngine) window.GameEngine.mouseSensitivity = sens;
          } catch(e) { console.error('slider-sensitivity error:', e); }
        });
      }

      var sliderBrightness = document.getElementById('slider-brightness');
      if (sliderBrightness) {
        sliderBrightness.addEventListener('input', function() {
          try {
            var brightness = parseFloat(sliderBrightness.value);
            if (window.GameSettings) window.GameSettings.brightness = brightness;
            else window.GameSettings = { brightness: brightness };
            var gc = document.getElementById('game-container');
            if (gc) gc.style.filter = 'brightness(' + brightness + ')';
          } catch(e) { console.error('slider-brightness error:', e); }
        });
      }

      var toggleFullscreen = document.getElementById('toggle-fullscreen');
      if (toggleFullscreen) {
        toggleFullscreen.addEventListener('change', function() {
          try {
            if (toggleFullscreen.checked) {
              if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
              } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
              }
            } else {
              if (document.exitFullscreen) {
                document.exitFullscreen();
              } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
              }
            }
          } catch(e) { console.error('toggle-fullscreen error:', e); }
        });
        // Sync checkbox with actual fullscreen state
        document.addEventListener('fullscreenchange', function() {
          try {
            toggleFullscreen.checked = !!document.fullscreenElement;
          } catch(e) {}
        });
      }

      // ---- MOBILE CHECK ----
      if (window.InputManager.isMobile()) {
        var mc = document.getElementById('mobile-controls');
        if (mc) { mc.style.display = 'none'; } // Will be shown on game start
      }

      // ---- AUDIO CONTEXT RESUME ON FIRST INTERACTION ----
      var audioResumed = false;
      function resumeAudio() {
        try {
          if (!audioResumed && window.AudioManager && window.AudioManager.ctx) {
            if (window.AudioManager.ctx.state === 'suspended') {
              window.AudioManager.ctx.resume().then(function() {
                audioResumed = true;
                console.log('[Bootstrap] AudioContext reanudado');
              }).catch(function(e) { console.error('AudioContext resume error:', e); });
            } else {
              audioResumed = true;
            }
          }
        } catch(e) {}
      }

      document.addEventListener('click', resumeAudio, { once: false });
      document.addEventListener('touchstart', resumeAudio, { once: false });
      document.addEventListener('keydown', resumeAudio, { once: false });

      // ---- MULTIPLAYER DATA HANDLER ----
      if (window.MultiplayerManager && typeof window.MultiplayerManager.onData === 'function') {
        try {
          window.MultiplayerManager.onData(function(data) {
            try {
              if (!data) return;
              if (data.type === 'start_game') {
                showLoadingScreen(function() { startGame(true); });
              } else if (data.type === 'player_joined') {
                UIManager.showSubtitle(data.name + ' ha entrado al orfanato', 3000);
              } else if (data.type === 'player_died') {
                UIManager.showSubtitle(data.name + ' ha sucumbido a la locura', 3000);
              } else if (data.type === 'chat') {
                UIManager.addChatMessage(data.name, data.message);
              } else if (data.type === 'sanity_update') {
                // Could update other players' sanity display
              }
            } catch(e) { console.error('onData handler error:', e); }
          });
        } catch(e) { console.error('MultiplayerManager.onData setup error:', e); }
      }

      // ---- Default GameSettings ----
      window.GameSettings = {
        volume: 0.7,
        sensitivity: 0.002,
        brightness: 1.0
      };

      // Apply default slider values
      try {
        if (sliderVolume) sliderVolume.value = window.GameSettings.volume;
        if (sliderSensitivity) sliderSensitivity.value = window.GameSettings.sensitivity;
        if (sliderBrightness) sliderBrightness.value = window.GameSettings.brightness;
      } catch(e) {}

      // Initialize InputManager right away (keyboard/mouse listeners always active)
      try {
        if (window.InputManager && typeof window.InputManager.init === 'function') {
          window.InputManager.init();
        }
      } catch(e) { console.error('InputManager early init error:', e); }

      console.log('[Bootstrap] El Susurro de la Inocente - Listo para jugar');
    } catch(e) {
      console.error('[Bootstrap] Error en DOMContentLoaded:', e);
      try {
        var body = document.body;
        if (body) {
          var errDiv = document.createElement('div');
          errDiv.style.cssText = 'position:fixed;top:20px;left:20px;color:red;background:rgba(0,0,0,0.8);padding:20px;border-radius:8px;z-index:99999;font-family:monospace;';
          errDiv.textContent = 'Error crÃ­tico: ' + e.message;
          body.appendChild(errDiv);
        }
      } catch(e2) {}
    }
  });

})();
} catch(e) { console.error('Bootstrap error:', e); }
</script>

</body>
</html>