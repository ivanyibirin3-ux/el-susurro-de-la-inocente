<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0a0a0a">
  <title>El Susurro de la Inocente</title>
  <style>
    /* ===== RESET & BASE ===== */
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-deep: #0a0a0a;
      --bg-dark: #0f0f0f;
      --bg-blood: #1a0000;
      --bg-card: #111111;
      --accent-blood: #8b0000;
      --accent-crimson: #c0392b;
      --accent-red: #e74c3c;
      --accent-dim: #4a0000;
      --text-primary: #c8c8c8;
      --text-dim: #888888;
      --text-ghost: #aaaaaa;
      --text-horror: #d4a0a0;
      --glow-red: rgba(139,0,0,0.8);
      --glow-soft: rgba(200,60,60,0.4);
      --sanity-green: #00ff88;
      --sanity-yellow: #ffcc00;
      --sanity-red: #ff2200;
      --char-elena: #3a7bd5;
      --char-diego: #27ae60;
      --char-camila: #8e44ad;
      --char-padre: #f39c12;
      --hud-bg: rgba(0,0,0,0.65);
      --border-horror: rgba(139,0,0,0.5);
      --font-mono: 'Courier New', Courier, monospace;
      --font-horror: Georgia, 'Times New Roman', serif;
      --transition-fast: 0.15s ease;
      --transition-med: 0.3s ease;
      --transition-slow: 0.6s ease;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg-deep);
      color: var(--text-primary);
      font-family: var(--font-mono);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      cursor: default;
      user-select: none;
      -webkit-user-select: none;
    }

    /* ===== SCROLLBAR ===== */
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: var(--bg-deep); }
    ::-webkit-scrollbar-thumb { background: var(--accent-blood); border-radius: 2px; }

    /* ===== SCREENS CONTAINER ===== */
    #game-container {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .screen {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: none;
      opacity: 0;
      transition: opacity var(--transition-slow);
    }

    .screen.active {
      display: flex;
      opacity: 1;
    }

    .screen.fade-in {
      animation: screenFadeIn 0.8s ease forwards;
    }

    /* ===== GLOBAL VHS OVERLAY ===== */
    .vhs-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 9999;
      overflow: hidden;
    }

    .vhs-overlay::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.08) 2px,
        rgba(0,0,0,0.08) 4px
      );
      animation: scanlineMove 8s linear infinite;
      pointer-events: none;
    }

    .vhs-overlay::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(
        ellipse at center,
        transparent 60%,
        rgba(0,0,0,0.55) 100%
      );
      pointer-events: none;
    }

    .vhs-noise {
      position: absolute;
      inset: 0;
      opacity: 0.03;
      animation: vhsNoise 0.1s steps(1) infinite;
      pointer-events: none;
      z-index: 10000;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      background-size: 256px 256px;
    }

    /* ===== VHS GLITCH BAND ===== */
    .vhs-glitch-band {
      position: absolute;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(255,255,255,0.06);
      animation: glitchBand 6s linear infinite;
      pointer-events: none;
      z-index: 10001;
    }

    /* ===== FOG LAYER ===== */
    .fog-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 1;
    }

    .fog-layer::before,
    .fog-layer::after {
      content: '';
      position: absolute;
      width: 200%;
      height: 200%;
      top: -50%;
      left: -50%;
      border-radius: 50%;
      pointer-events: none;
    }

    .fog-layer::before {
      background: radial-gradient(
        ellipse at 30% 60%,
        rgba(80,0,0,0.12) 0%,
        rgba(30,0,0,0.06) 40%,
        transparent 70%
      );
      animation: fogDrift1 18s ease-in-out infinite alternate;
    }

    .fog-layer::after {
      background: radial-gradient(
        ellipse at 70% 40%,
        rgba(60,0,20,0.10) 0%,
        rgba(20,0,10,0.05) 40%,
        transparent 70%
      );
      animation: fogDrift2 24s ease-in-out infinite alternate;
    }

    .fog-particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      background: radial-gradient(ellipse, rgba(100,20,20,0.07), transparent 70%);
      animation: fogFloat linear infinite;
    }

    /* ===========================
       MAIN MENU SCREEN
    =========================== */
    #screen-menu {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(
        ellipse at 50% 30%,
        #1a0505 0%,
        #0f0000 40%,
        #0a0a0a 100%
      );
      position: relative;
    }

    .menu-bg-image {
      position: absolute;
      inset: 0;
      background:
        radial-gradient(ellipse at 20% 80%, rgba(139,0,0,0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 20%, rgba(100,0,0,0.06) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(50,0,0,0.15) 0%, transparent 80%);
      z-index: 0;
    }

    .menu-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0;
      width: 100%;
      max-width: 480px;
      padding: 2rem;
    }

    .menu-eyebrow {
      font-family: var(--font-mono);
      font-size: 0.65rem;
      letter-spacing: 0.4em;
      color: var(--accent-blood);
      text-transform: uppercase;
      opacity: 0.7;
      margin-bottom: 1rem;
      animation: flicker 8s ease-in-out infinite;
    }

    .menu-title {
      font-family: var(--font-horror);
      font-size: clamp(2rem, 6vw, 3.8rem);
      font-weight: 700;
      text-align: center;
      line-height: 1.15;
      color: #d4a0a0;
      letter-spacing: 0.04em;
      text-shadow:
        0 0 10px rgba(139,0,0,0.9),
        0 0 25px rgba(139,0,0,0.6),
        0 0 50px rgba(100,0,0,0.4),
        0 0 80px rgba(80,0,0,0.2),
        2px 2px 0px rgba(0,0,0,0.8);
      animation: titlePulse 4s ease-in-out infinite;
      margin-bottom: 0.5rem;
    }

    .menu-title span {
      display: block;
      color: #b87070;
      font-size: 0.55em;
      letter-spacing: 0.08em;
      text-shadow:
        0 0 8px rgba(139,0,0,0.7),
        0 0 20px rgba(100,0,0,0.4);
    }

    .menu-subtitle {
      font-family: var(--font-horror);
      font-size: clamp(0.75rem, 2vw, 1rem);
      font-style: italic;
      color: #aa5555;
      letter-spacing: 0.12em;
      margin-bottom: 2.5rem;
      animation: subtitleFlicker 3.5s ease-in-out infinite;
      text-shadow: 0 0 15px rgba(139,0,0,0.8);
    }

    .menu-divider {
      width: 180px;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--accent-blood), transparent);
      margin-bottom: 2.5rem;
      box-shadow: 0 0 8px rgba(139,0,0,0.6);
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      width: 100%;
      max-width: 280px;
    }

    /* ===== HORROR BUTTONS ===== */
    .btn {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.75rem 1.5rem;
      font-family: var(--font-mono);
      font-size: 0.85rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      border: none;
      cursor: pointer;
      outline: none;
      transition:
        background var(--transition-fast),
        box-shadow var(--transition-fast),
        transform var(--transition-fast),
        color var(--transition-fast);
      overflow: hidden;
      white-space: nowrap;
      -webkit-tap-highlight-color: transparent;
    }

    .btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.04) 0%, transparent 60%);
      pointer-events: none;
    }

    .btn::after {
      content: '';
      position: absolute;
      left: -100%;
      top: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(139,0,0,0.2), transparent);
      transition: left 0.4s ease;
    }

    .btn:hover::after {
      left: 100%;
    }

    .btn-primary {
      background: linear-gradient(135deg, #3a0000 0%, #1a0000 100%);
      color: #ffaaaa;
      border: 1px solid rgba(139,0,0,0.6);
      box-shadow:
        0 0 0 1px rgba(139,0,0,0.2),
        inset 0 1px 0 rgba(255,100,100,0.05),
        0 4px 15px rgba(0,0,0,0.5);
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, #5a0000 0%, #2a0000 100%);
      color: #ffcccc;
      box-shadow:
        0 0 0 1px rgba(139,0,0,0.7),
        0 0 15px rgba(139,0,0,0.5),
        0 0 30px rgba(100,0,0,0.3),
        inset 0 1px 0 rgba(255,100,100,0.1),
        0 4px 20px rgba(0,0,0,0.6);
      transform: translateY(-1px) scale(1.01);
    }

    .btn-primary:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 0 8px rgba(139,0,0,0.4), 0 2px 6px rgba(0,0,0,0.4);
    }

    .btn-primary:hover .btn-icon {
      animation: btnIconShake 0.3s ease;
    }

    .btn-secondary {
      background: linear-gradient(135deg, #1a1a1a 0%, #111111 100%);
      color: var(--text-dim);
      border: 1px solid rgba(80,80,80,0.3);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }

    .btn-secondary:hover {
      background: linear-gradient(135deg, #242424 0%, #181818 100%);
      color: var(--text-ghost);
      border-color: rgba(139,0,0,0.4);
      box-shadow:
        0 0 10px rgba(139,0,0,0.2),
        0 4px 15px rgba(0,0,0,0.5);
      transform: translateY(-1px);
    }

    .btn-secondary:active {
      transform: translateY(1px);
    }

    .btn-danger {
      background: linear-gradient(135deg, #4a0000 0%, #2a0000 100%);
      color: #ff6666;
      border: 1px solid rgba(180,0,0,0.5);
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }

    .btn-danger:hover {
      background: linear-gradient(135deg, #6a0000 0%, #3a0000 100%);
      color: #ff9999;
      box-shadow:
        0 0 20px rgba(180,0,0,0.6),
        0 0 40px rgba(139,0,0,0.3);
      transform: translateY(-1px);
      animation: btnDanger 0.4s ease;
    }

    .btn-ghost {
      background: transparent;
      color: rgba(139,0,0,0.7);
      border: 1px solid rgba(139,0,0,0.25);
    }

    .btn-ghost:hover {
      background: rgba(139,0,0,0.08);
      color: rgba(180,60,60,0.9);
      border-color: rgba(139,0,0,0.5);
    }

    .btn-icon {
      font-size: 1em;
      display: inline-block;
    }

    .btn-full { width: 100%; }

    .btn-sm {
      padding: 0.45rem 0.9rem;
      font-size: 0.72rem;
    }

    .btn-lg {
      padding: 0.9rem 2rem;
      font-size: 0.95rem;
    }

    /* ===========================
       MULTIPLAYER LOBBY SCREEN
    =========================== */
    #screen-lobby {
      flex-direction: column;
      background: var(--bg-deep);
      overflow: hidden;
    }

    .lobby-container {
      position: relative;
      z-index: 2;
      display: grid;
      grid-template-columns: 1fr 340px;
      grid-template-rows: auto 1fr auto;
      gap: 1rem;
      width: 100%;
      height: 100%;
      max-width: 1100px;
      margin: 0 auto;
      padding: 1.5rem;
    }

    .lobby-header {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border-horror);
    }

    .lobby-title {
      font-family: var(--font-horror);
      font-size: 1.4rem;
      color: var(--text-horror);
      text-shadow: 0 0 12px rgba(139,0,0,0.7);
      letter-spacing: 0.06em;
    }

    .room-code-display {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      background: rgba(139,0,0,0.08);
      border: 1px solid rgba(139,0,0,0.3);
      padding: 0.5rem 1rem;
      border-radius: 3px;
    }

    .room-code-label {
      font-size: 0.6rem;
      letter-spacing: 0.3em;
      color: var(--accent-blood);
      text-transform: uppercase;
    }

    .room-code-value {
      font-family: var(--font-mono);
      font-size: 1.4rem;
      font-weight: bold;
      letter-spacing: 0.3em;
      color: #ff8888;
      text-shadow: 0 0 10px rgba(255,80,80,0.6);
      animation: codeFlicker 6s ease-in-out infinite;
    }

    /* === Join Room Panel === */
    .join-room-panel {
      background: rgba(139,0,0,0.05);
      border: 1px solid rgba(139,0,0,0.2);
      padding: 1rem;
      border-radius: 3px;
    }

    .join-room-panel label {
      display: block;
      font-size: 0.62rem;
      letter-spacing: 0.3em;
      color: var(--accent-blood);
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }

    .room-code-input {
      width: 100%;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(139,0,0,0.4);
      color: #ff9999;
      font-family: var(--font-mono);
      font-size: 1.4rem;
      letter-spacing: 0.35em;
      text-align: center;
      text-transform: uppercase;
      padding: 0.6rem;
      outline: none;
      border-radius: 2px;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
      margin-bottom: 0.75rem;
      caret-color: var(--accent-crimson);
    }

    .room-code-input::placeholder {
      color: rgba(139,0,0,0.35);
      letter-spacing: 0.25em;
    }

    .room-code-input:focus {
      border-color: rgba(180,0,0,0.7);
      box-shadow: 0 0 12px rgba(139,0,0,0.4), inset 0 0 8px rgba(139,0,0,0.1);
    }

    /* === Player Slots === */
    .player-slots {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .player-slot {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.6rem 0.75rem;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(50,50,50,0.5);
      border-radius: 3px;
      transition: border-color var(--transition-fast), background var(--transition-fast);
      min-height: 52px;
    }

    .player-slot.occupied {
      border-color: rgba(139,0,0,0.3);
      background: rgba(139,0,0,0.05);
    }

    .player-slot.self {
      border-color: rgba(200,60,60,0.5);
      background: rgba(139,0,0,0.1);
      box-shadow: 0 0 8px rgba(139,0,0,0.2);
    }

    .player-slot.empty {
      opacity: 0.4;
    }

    .slot-number {
      font-size: 0.65rem;
      color: var(--accent-blood);
      letter-spacing: 0.1em;
      min-width: 20px;
    }

    .slot-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid rgba(80,80,80,0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      flex-shrink: 0;
    }

    .slot-info {
      flex: 1;
      min-width: 0;
    }

    .slot-name {
      font-size: 0.8rem;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .slot-character {
      font-size: 0.65rem;
      color: var(--text-dim);
      margin-top: 0.1rem;
    }

    .slot-status {
      font-size: 0.62rem;
      padding: 0.15rem 0.4rem;
      border-radius: 2px;
    }

    .slot-status.ready {
      background: rgba(0,180,80,0.15);
      color: #00cc55;
      border: 1px solid rgba(0,180,80,0.3);
    }

    .slot-status.waiting {
      background: rgba(200,150,0,0.1);
      color: #aa9900;
      border: 1px solid rgba(200,150,0,0.25);
      animation: pulse 2s ease-in-out infinite;
    }

    .slot-empty-text {
      font-size: 0.72rem;
      color: rgba(80,80,80,0.6);
      font-style: italic;
      letter-spacing: 0.1em;
    }

    /* === Character Cards === */
    .character-selection {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      overflow: hidden;
    }

    .char-select-title {
      font-size: 0.65rem;
      letter-spacing: 0.3em;
      color: var(--accent-blood);
      text-transform: uppercase;
    }

    .char-cards-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
      flex: 1;
    }

    .char-card {
      position: relative;
      background: rgba(10,10,10,0.9);
      border: 1px solid rgba(50,50,50,0.4);
      border-radius: 4px;
      padding: 0.9rem 0.75rem;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      transition:
        border-color var(--transition-fast),
        box-shadow var(--transition-fast),
        transform var(--transition-fast),
        background var(--transition-fast);
      overflow: hidden;
    }

    .char-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      opacity: 0;
      transition: opacity var(--transition-fast);
    }

    .char-card:hover {
      transform: translateY(-2px);
    }

    .char-card.selected {
      transform: translateY(-2px);
    }

    .char-card.selected::before { opacity: 1; }
    .char-card.selected::after {
      content: 'â';
      position: absolute;
      top: 0.35rem;
      right: 0.45rem;
      font-size: 0.7rem;
      font-weight: bold;
    }

    /* Elena - Blue */
    .char-card[data-char="elena"] { --char-color: var(--char-elena); }
    .char-card[data-char="elena"]::before { background: var(--char-elena); }
    .char-card[data-char="elena"]:hover,
    .char-card[data-char="elena"].selected {
      border-color: rgba(58,123,213,0.6);
      background: rgba(58,123,213,0.06);
      box-shadow: 0 0 16px rgba(58,123,213,0.25);
    }
    .char-card[data-char="elena"].selected::after { color: var(--char-elena); }

    /* Diego - Green */
    .char-card[data-char="diego"] { --char-color: var(--char-diego); }
    .char-card[data-char="diego"]::before { background: var(--char-diego); }
    .char-card[data-char="diego"]:hover,
    .char-card[data-char="diego"].selected {
      border-color: rgba(39,174,96,0.6);
      background: rgba(39,174,96,0.06);
      box-shadow: 0 0 16px rgba(39,174,96,0.25);
    }
    .char-card[data-char="diego"].selected::after { color: var(--char-diego); }

    /* Camila - Purple */
    .char-card[data-char="camila"] { --char-color: var(--char-camila); }
    .char-card[data-char="camila"]::before { background: var(--char-camila); }
    .char-card[data-char="camila"]:hover,
    .char-card[data-char="camila"].selected {
      border-color: rgba(142,68,173,0.6);
      background: rgba(142,68,173,0.06);
      box-shadow: 0 0 16px rgba(142,68,173,0.25);
    }
    .char-card[data-char="camila"].selected::after { color: var(--char-camila); }

    /* Padre TomÃ¡s - Gold */
    .char-card[data-char="padre"] { --char-color: var(--char-padre); }
    .char-card[data-char="padre"]::before { background: var(--char-padre); }
    .char-card[data-char="padre"]:hover,
    .char-card[data-char="padre"].selected {
      border-color: rgba(243,156,18,0.6);
      background: rgba(243,156,18,0.06);
      box-shadow: 0 0 16px rgba(243,156,18,0.25);
    }
    .char-card[data-char="padre"].selected::after { color: var(--char-padre); }

    .char-portrait {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 2px solid rgba(var(--char-color-rgb, 80,80,80), 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.6rem;
      background: rgba(0,0,0,0.5);
      position: relative;
    }

    .char-name {
      font-size: 0.78rem;
      font-weight: bold;
      letter-spacing: 0.05em;
      text-align: center;
      color: var(--text-primary);
    }

    .char-role {
      font-size: 0.6rem;
      color: var(--text-dim);
      text-align: center;
      letter-spacing: 0.08em;
    }

    .char-stats {
      display: flex;
      gap: 0.25rem;
      width: 100%;
    }

    .char-stat-bar {
      flex: 1;
      height: 3px;
      background: rgba(255,255,255,0.08);
      border-radius: 2px;
      overflow: hidden;
    }

    .char-stat-fill {
      height: 100%;
      border-radius: 2px;
      transition: width 0.5s ease;
    }

    .char-card.locked {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .char-lock-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.4);
      font-size: 1.2rem;
      color: rgba(180,180,180,0.5);
    }

    /* === Lobby Chat === */
    .lobby-chat {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 0.5rem;
    }

    .chat-title {
      font-size: 0.62rem;
      letter-spacing: 0.3em;
      color: var(--accent-blood);
      text-transform: uppercase;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(50,50,50,0.4);
      border-radius: 3px;
      padding: 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      max-height: 280px;
    }

    .chat-message {
      font-size: 0.72rem;
      line-height: 1.4;
      color: var(--text-dim);
    }

    .chat-message .chat-sender {
      color: var(--accent-crimson);
      font-weight: bold;
    }

    .chat-message.system {
      color: rgba(139,0,0,0.5);
      font-style: italic;
      font-size: 0.65rem;
    }

    .chat-input-row {
      display: flex;
      gap: 0.5rem;
    }

    .chat-input {
      flex: 1;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(60,60,60,0.5);
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-size: 0.75rem;
      padding: 0.45rem 0.6rem;
      outline: none;
      border-radius: 2px;
      transition: border-color var(--transition-fast);
      caret-color: var(--accent-crimson);
    }

    .chat-input:focus {
      border-color: rgba(139,0,0,0.5);
      box-shadow: 0 0 6px rgba(139,0,0,0.2);
    }

    .chat-input::placeholder {
      color: rgba(80,80,80,0.6);
    }

    .lobby-footer {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-top: 1rem;
      border-top: 1px solid var(--border-horror);
    }

    .lobby-host-controls {
      display: flex;
      gap: 0.5rem;
    }

    /* ===========================
       GAME HUD
    =========================== */
    #screen-game {
      display: none;
      position: absolute;
      inset: 0;
    }

    #screen-game.active {
      display: block;
    }

    #game-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }

    #game-hud {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 100;
    }

    /* === Sanity Meter === */
    .hud-sanity {
      position: absolute;
      top: 1rem;
      left: 1rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      pointer-events: none;
    }

    .sanity-ring {
      position: relative;
      width: 60px;
      height: 60px;
      flex-shrink: 0;
    }

    .sanity-svg {
      width: 60px;
      height: 60px;
      transform: rotate(-90deg);
    }

    .sanity-track {
      fill: none;
      stroke: rgba(30,30,30,0.8);
      stroke-width: 5;
    }

    .sanity-fill {
      fill: none;
      stroke: var(--sanity-green);
      stroke-width: 5;
      stroke-linecap: round;
      stroke-dasharray: 163;
      stroke-dashoffset: 0;
      transition: stroke-dashoffset 0.5s ease, stroke 0.5s ease;
      filter: drop-shadow(0 0 4px var(--sanity-green));
    }

    .sanity-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.1rem;
    }

    .sanity-info {
      display: flex;
      flex-direction: column;
    }

    .sanity-label {
      font-size: 0.55rem;
      letter-spacing: 0.2em;
      color: rgba(180,180,180,0.6);
      text-transform: uppercase;
    }

    .sanity-value {
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--sanity-green);
      text-shadow: 0 0 8px var(--sanity-green);
      transition: color 0.5s ease, text-shadow 0.5s ease;
      font-family: var(--font-mono);
    }

    .sanity-status {
      font-size: 0.6rem;
      color: rgba(180,180,180,0.5);
      letter-spacing: 0.08em;
    }

    /* Sanity states */
    .sanity-fill.sanity-warn {
      stroke: var(--sanity-yellow);
      filter: drop-shadow(0 0 4px var(--sanity-yellow));
      animation: sanityWarn 1.5s ease-in-out infinite;
    }

    .sanity-fill.sanity-crit {
      stroke: var(--sanity-red);
      filter: drop-shadow(0 0 6px var(--sanity-red));
      animation: sanityCrit 0.8s ease-in-out infinite;
    }

    .sanity-value.sanity-warn { color: var(--sanity-yellow); text-shadow: 0 0 8px var(--sanity-yellow); }
    .sanity-value.sanity-crit { color: var(--sanity-red); text-shadow: 0 0 8px var(--sanity-red); animation: sanityCrit 0.8s ease-in-out infinite; }

    /* === Flashlight Battery === */
    .hud-flashlight {
      position: absolute;
      top: 1rem;
      left: calc(1rem + 140px);
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      pointer-events: none;
    }

    .battery-label {
      font-size: 0.5rem;
      letter-spacing: 0.25em;
      color: rgba(180,180,180,0.5);
      text-transform: uppercase;
    }

    .battery-leds {
      display: flex;
      gap: 3px;
      align-items: center;
    }

    .battery-led {
      width: 10px;
      height: 14px;
      border-radius: 2px;
      background: rgba(30,30,30,0.8);
      border: 1px solid rgba(60,60,60,0.5);
      transition: background 0.3s ease, box-shadow 0.3s ease;
    }

    .battery-led.lit-high {
      background: #00ff88;
      box-shadow: 0 0 5px #00ff88, 0 0 10px rgba(0,255,136,0.4);
    }

    .battery-led.lit-mid {
      background: #ffcc00;
      box-shadow: 0 0 5px #ffcc00, 0 0 10px rgba(255,204,0,0.4);
    }

    .battery-led.lit-low {
      background: #ff4400;
      box-shadow: 0 0 5px #ff4400, 0 0 10px rgba(255,68,0,0.4);
      animation: ledBlink 1.2s ease-in-out infinite;
    }

    .battery-tip {
      width: 4px;
      height: 8px;
      background: rgba(60,60,60,0.6);
      border-radius: 1px;
      border: 1px solid rgba(80,80,80,0.4);
    }

    /* === Radial Inventory Wheel === */
    .hud-inventory {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      pointer-events: auto;
    }

    .hud-inventory.visible {
      display: flex;
      animation: inventoryAppear 0.2s ease;
    }

    .inventory-wheel {
      position: relative;
      width: 180px;
      height: 180px;
    }

    .inventory-slot {
      position: absolute;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: rgba(0,0,0,0.85);
      border: 2px solid rgba(139,0,0,0.4);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.15rem;
      cursor: pointer;
      transition:
        border-color var(--transition-fast),
        box-shadow var(--transition-fast),
        transform var(--transition-fast);
      pointer-events: auto;
    }

    .inventory-slot:hover,
    .inventory-slot.active {
      border-color: rgba(200,60,60,0.7);
      box-shadow: 0 0 12px rgba(139,0,0,0.6);
      transform: scale(1.12);
    }

    .inventory-slot:nth-child(1) { top: 0; left: 50%; transform: translateX(-50%); }
    .inventory-slot:nth-child(2) { top: 50%; right: 0; transform: translateY(-50%); }
    .inventory-slot:nth-child(3) { bottom: 0; left: 50%; transform: translateX(-50%); }
    .inventory-slot:nth-child(4) { top: 50%; left: 0; transform: translateY(-50%); }

    .inventory-slot:nth-child(1):hover, .inventory-slot:nth-child(1).active { transform: translateX(-50%) scale(1.12); }
    .inventory-slot:nth-child(2):hover, .inventory-slot:nth-child(2).active { transform: translateY(-50%) scale(1.12); }
    .inventory-slot:nth-child(3):hover, .inventory-slot:nth-child(3).active { transform: translateX(-50%) scale(1.12); }
    .inventory-slot:nth-child(4):hover, .inventory-slot:nth-child(4).active { transform: translateY(-50%) scale(1.12); }

    .inventory-slot-icon { font-size: 1.2rem; }
    .inventory-slot-key {
      font-size: 0.5rem;
      color: rgba(139,0,0,0.7);
      letter-spacing: 0.05em;
    }
    .inventory-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(139,0,0,0.15);
      border: 1px solid rgba(139,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.55rem;
      color: rgba(200,100,100,0.7);
      letter-spacing: 0.05em;
    }

    /* === Minimap === */
    .hud-minimap {
      position: absolute;
      top: 1rem;
      right: 1rem;
      width: 120px;
      height: 120px;
      pointer-events: none;
    }

    .minimap-frame {
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.75);
      border: 1px solid rgba(139,0,0,0.35);
      border-radius: 3px;
      overflow: hidden;
      position: relative;
      box-shadow:
        0 0 0 1px rgba(0,0,0,0.5),
        inset 0 0 20px rgba(0,0,0,0.5);
    }

    .minimap-canvas {
      width: 100%;
      height: 100%;
      opacity: 0.85;
    }

    .minimap-overlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.6) 100%);
      pointer-events: none;
    }

    .minimap-label {
      position: absolute;
      bottom: 3px;
      right: 4px;
      font-size: 0.45rem;
      letter-spacing: 0.15em;
      color: rgba(139,0,0,0.5);
      text-transform: uppercase;
    }

    .minimap-player-dot {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4444;
      box-shadow: 0 0 4px #ff4444;
      transform: translate(-50%, -50%);
      animation: pulse 2s ease-in-out infinite;
    }

    .minimap-other-dot {
      position: absolute;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      opacity: 0.8;
    }

    /* === Chat Overlay (In-game) === */
    .hud-chat {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      width: 260px;
      pointer-events: none;
    }

    .hud-chat-messages {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      margin-bottom: 0.4rem;
      max-height: 120px;
      overflow: hidden;
    }

    .hud-chat-msg {
      background: rgba(0,0,0,0.6);
      padding: 0.25rem 0.45rem;
      border-radius: 2px;
      font-size: 0.7rem;
      color: var(--text-dim);
      border-left: 2px solid var(--accent-blood);
      animation: chatMsgIn 0.2s ease;
      pointer-events: none;
    }

    .hud-chat-msg .sender {
      font-weight: bold;
      margin-right: 0.3rem;
    }

    .hud-chat-input-wrap {
      display: none;
      pointer-events: auto;
    }

    .hud-chat-input-wrap.active {
      display: flex;
      gap: 0.3rem;
    }

    .hud-chat-input {
      flex: 1;
      background: rgba(0,0,0,0.8);
      border: 1px solid rgba(139,0,0,0.4);
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-size: 0.72rem;
      padding: 0.35rem 0.5rem;
      outline: none;
      border-radius: 2px;
      caret-color: var(--accent-crimson);
    }

    /* === Player Name Tags === */
    .player-nametag {
      position: absolute;
      transform: translateX(-50%);
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .nametag-text {
      background: rgba(0,0,0,0.65);
      color: var(--text-primary);
      font-size: 0.65rem;
      padding: 0.1rem 0.4rem;
      border-radius: 2px;
      letter-spacing: 0.05em;
      white-space: nowrap;
      border: 1px solid rgba(80,80,80,0.3);
    }

    .nametag-health {
      width: 40px;
      height: 3px;
      background: rgba(30,30,30,0.8);
      border-radius: 2px;
      overflow: hidden;
    }

    .nametag-health-fill {
      height: 100%;
      background: #00cc55;
      border-radius: 2px;
      transition: width 0.3s ease, background 0.3s ease;
    }

    /* === HUD VHS filter === */
    .hud-vhs {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 200;
      overflow: hidden;
    }

    .hud-scanlines {
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.04) 2px,
        rgba(0,0,0,0.04) 4px
      );
      pointer-events: none;
    }

    .hud-vignette {
      position: absolute;
      inset: 0;
      background: radial-gradient(
        ellipse at center,
        transparent 55%,
        rgba(0,0,0,0.7) 100%
      );
      pointer-events: none;
    }

    /* ===========================
       MOBILE TOUCH CONTROLS
    =========================== */
    .touch-controls {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 150;
      display: none;
    }

    .touch-controls.active {
      display: block;
    }

    .joystick-zone {
      position: absolute;
      bottom: 2rem;
      left: 1rem;
      width: 130px;
      height: 130px;
      pointer-events: auto;
    }

    .joystick-base {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: rgba(0,0,0,0.45);
      border: 2px solid rgba(139,0,0,0.35);
      box-shadow:
        0 0 0 1px rgba(0,0,0,0.5),
        inset 0 0 15px rgba(0,0,0,0.4);
    }

    .joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: radial-gradient(ellipse at 35% 35%, rgba(180,60,60,0.7), rgba(80,0,0,0.9));
      border: 2px solid rgba(200,60,60,0.5);
      box-shadow: 0 0 10px rgba(139,0,0,0.4);
      pointer-events: none;
      transition: none;
    }

    .camera-zone {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 45%;
      height: 55%;
      pointer-events: auto;
      border-radius: 8px 0 0 0;
    }

    .touch-action-buttons {
      position: absolute;
      bottom: 3rem;
      right: 1.5rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      pointer-events: auto;
    }

    .touch-btn {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      border: 2px solid rgba(139,0,0,0.4);
      background: rgba(0,0,0,0.55);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      transition: background var(--transition-fast), box-shadow var(--transition-fast);
      pointer-events: auto;
    }

    .touch-btn:active {
      background: rgba(139,0,0,0.25);
      box-shadow: 0 0 12px rgba(139,0,0,0.4);
    }

    .touch-btn-icon { font-size: 1rem; }
    .touch-btn-label { font-size: 0.45rem; color: rgba(200,100,100,0.7); letter-spacing: 0.05em; }

    .touch-btn-interact { border-color: rgba(58,123,213,0.4); }
    .touch-btn-interact:active { background: rgba(58,123,213,0.2); box-shadow: 0 0 12px rgba(58,123,213,0.4); }

    .touch-btn-run { border-color: rgba(243,156,18,0.4); }
    .touch-btn-run:active { background: rgba(243,156,18,0.15); box-shadow: 0 0 12px rgba(243,156,18,0.3); }

    .touch-btn-inventory { border-color: rgba(142,68,173,0.4); }
    .touch-btn-inventory:active { background: rgba(142,68,173,0.15); box-shadow: 0 0 12px rgba(142,68,173,0.3); }

    /* ===========================
       PAUSE MENU
    =========================== */
    #screen-pause {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.88);
      backdrop-filter: blur(3px);
      z-index: 500;
    }

    .pause-container {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      width: 100%;
      max-width: 320px;
      padding: 2.5rem;
      background: rgba(10,0,0,0.85);
      border: 1px solid rgba(139,0,0,0.35);
      box-shadow:
        0 0 30px rgba(0,0,0,0.8),
        0 0 60px rgba(0,0,0,0.5),
        inset 0 1px 0 rgba(139,0,0,0.1);
    }

    .pause-title {
      font-family: var(--font-horror);
      font-size: 1.8rem;
      color: var(--text-horror);
      text-shadow: 0 0 15px rgba(139,0,0,0.8);
      letter-spacing: 0.08em;
      animation: flicker 5s ease-in-out infinite;
    }

    .pause-divider {
      width: 100%;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(139,0,0,0.5), transparent);
    }

    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      width: 100%;
    }

    .pause-info {
      font-size: 0.6rem;
      color: var(--text-dim);
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    /* ===========================
       GAME OVER / DEATH SCREEN
    =========================== */
    #screen-gameover {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #000;
      z-index: 600;
    }

    .gameover-static {
      position: absolute;
      inset: 0;
      z-index: 0;
      animation: staticNoise 0.05s steps(1) infinite;
      opacity: 0;
      transition: opacity 1.5s ease;
    }

    .gameover-static.active { opacity: 0.12; }

    .gameover-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      text-align: center;
      padding: 2rem;
    }

    .gameover-label {
      font-size: 0.65rem;
      letter-spacing: 0.5em;
      color: rgba(139,0,0,0.6);
      text-transform: uppercase;
      animation: flicker 3s ease-in-out infinite;
    }

    .gameover-title {
      font-family: var(--font-horror);
      font-size: clamp(2.5rem, 8vw, 5rem);
      color: #cc0000;
      text-shadow:
        0 0 10px rgba(180,0,0,0.9),
        0 0 30px rgba(139,0,0,0.7),
        0 0 60px rgba(100,0,0,0.4);
      letter-spacing: 0.05em;
      animation: deathGlitch 0.8s ease-in-out infinite alternate;
    }

    .gameover-message {
      font-family: var(--font-horror);
      font-size: clamp(0.85rem, 2.5vw, 1.1rem);
      font-style: italic;
      color: #885555;
      letter-spacing: 0.08em;
      text-shadow: 0 0 10px rgba(139,0,0,0.4);
      max-width: 360px;
      line-height: 1.5;
    }

    .gameover-stat {
      display: flex;
      gap: 2rem;
      margin-top: 0.5rem;
    }

    .gameover-stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }

    .gameover-stat-value {
      font-size: 1.4rem;
      font-weight: bold;
      color: #cc4444;
      text-shadow: 0 0 8px rgba(139,0,0,0.6);
      font-family: var(--font-mono);
    }

    .gameover-stat-label {
      font-size: 0.55rem;
      letter-spacing: 0.2em;
      color: rgba(139,0,0,0.5);
      text-transform: uppercase;
    }

    .gameover-buttons {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    /* VHS Glitch on death */
    .gameover-vhs {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }

    .gameover-vhs::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 3px,
        rgba(0,0,0,0.12) 3px,
        rgba(0,0,0,0.12) 6px
      );
      animation: scanlineMove 4s linear infinite;
    }

    .gameover-vhs::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.85) 100%);
    }

    .gameover-glitch-band {
      position: absolute;
      left: 0;
      right: 0;
      height: 6px;
      z-index: 3;
      animation: deathBand 2s ease-in-out infinite;
      pointer-events: none;
    }

    /* ===========================
       LOADING SCREEN
    =========================== */
    #screen-loading {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-deep);
      z-index: 700;
    }

    .loading-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      width: 100%;
      max-width: 360px;
      padding: 2rem;
    }

    .loading-icon {
      font-size: 2.5rem;
      animation: loadingPulse 1.5s ease-in-out infinite;
    }

    .loading-title {
      font-family: var(--font-horror);
      font-size: 1.2rem;
      color: var(--text-horror);
      text-shadow: 0 0 10px rgba(139,0,0,0.6);
      letter-spacing: 0.08em;
      text-align: center;
    }

    .loading-bar-wrap {
      width: 100%;
      position: relative;
    }

    .loading-bar-bg {
      width: 100%;
      height: 4px;
      background: rgba(30,0,0,0.8);
      border: 1px solid rgba(139,0,0,0.25);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }

    .loading-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a0000, #8b0000, #c0392b);
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
      box-shadow: 0 0 8px rgba(139,0,0,0.7);
    }

    .loading-bar-fill::after {
      content: '';
      position: absolute;
      right: 0;
      top: -1px;
      bottom: -1px;
      width: 20px;
      background: linear-gradient(90deg, transparent, rgba(255,120,120,0.5));
      animation: loadingShimmer 1s ease-in-out infinite;
    }

    .loading-bar-markers {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      display: flex;
      justify-content: space-between;
      padding: 0 1px;
      pointer-events: none;
    }

    .loading-bar-marker {
      width: 1px;
      height: 100%;
      background: rgba(0,0,0,0.5);
    }

    .loading-percent {
      text-align: right;
      font-size: 0.6rem;
      color: var(--accent-blood);
      letter-spacing: 0.15em;
      margin-top: 0.35rem;
      font-family: var(--font-mono);
    }

    .loading-status {
      font-size: 0.65rem;
      color: rgba(139,0,0,0.5);
      letter-spacing: 0.2em;
      text-transform: uppercase;
      text-align: center;
      min-height: 1em;
      animation: flicker 4s ease-in-out infinite;
    }

    .loading-tips {
      font-size: 0.62rem;
      color: rgba(100,100,100,0.6);
      letter-spacing: 0.06em;
      text-align: center;
      max-width: 280px;
      line-height: 1.5;
      font-style: italic;
      border-top: 1px solid rgba(50,0,0,0.4);
      padding-top: 1rem;
    }

    /* ===========================
       OPTIONS SCREEN
    =========================== */
    #screen-options {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-deep);
    }

    .options-container {
      position: relative;
      z-index: 2;
      width: 100%;
      max-width: 520px;
      background: rgba(8,0,0,0.9);
      border: 1px solid rgba(139,0,0,0.3);
      box-shadow: 0 0 40px rgba(0,0,0,0.8);
      padding: 2rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .options-title {
      font-family: var(--font-horror);
      font-size: 1.5rem;
      color: var(--text-horror);
      text-shadow: 0 0 12px rgba(139,0,0,0.7);
      letter-spacing: 0.06em;
    }

    .options-section {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .options-section-title {
      font-size: 0.6rem;
      letter-spacing: 0.3em;
      color: var(--accent-blood);
      text-transform: uppercase;
      padding-bottom: 0.4rem;
      border-bottom: 1px solid rgba(139,0,0,0.2);
    }

    .options-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .options-label {
      font-size: 0.78rem;
      color: var(--text-dim);
      letter-spacing: 0.05em;
    }

    .options-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 140px;
      height: 4px;
      background: rgba(80,0,0,0.4);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
      border: 1px solid rgba(139,0,0,0.2);
    }

    .options-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: radial-gradient(ellipse at 35% 35%, #cc4444, #6a0000);
      cursor: pointer;
      border: 1px solid rgba(200,60,60,0.5);
      box-shadow: 0 0 6px rgba(139,0,0,0.5);
    }

    .options-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: radial-gradient(ellipse at 35% 35%, #cc4444, #6a0000);
      cursor: pointer;
      border: 1px solid rgba(200,60,60,0.5);
      box-shadow: 0 0 6px rgba(139,0,0,0.5);
    }

    .options-toggle {
      position: relative;
      width: 40px;
      height: 20px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .options-toggle input { display: none; }

    .options-toggle-track {
      position: absolute;
      inset: 0;
      background: rgba(30,0,0,0.8);
      border: 1px solid rgba(80,0,0,0.5);
      border-radius: 10px;
      transition: background var(--transition-fast);
    }

    .options-toggle-thumb {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(80,80,80,0.8);
      transition: transform var(--transition-fast), background var(--transition-fast);
    }

    .options-toggle input:checked ~ .options-toggle-track {
      background: rgba(100,0,0,0.7);
      border-color: rgba(139,0,0,0.6);
    }

    .options-toggle input:checked ~ .options-toggle-thumb {
      transform: translateX(20px);
      background: #cc4444;
      box-shadow: 0 0 6px rgba(139,0,0,0.6);
    }

    .options-select {
      background: rgba(15,0,0,0.9);
      border: 1px solid rgba(139,0,0,0.3);
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-size: 0.72rem;
      padding: 0.3rem 0.5rem;
      outline: none;
      cursor: pointer;
      border-radius: 2px;
      min-width: 120px;
    }

    .options-select option {
      background: #1a0000;
      color: var(--text-primary);
    }

    .options-footer {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid rgba(50,0,0,0.3);
    }

    /* ===========================
       CREDITS SCREEN
    =========================== */
    #screen-credits {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-deep);
      overflow: hidden;
    }

    .credits-scroll {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      text-align: center;
      animation: creditsScroll 30s linear infinite;
      padding: 4rem 2rem;
    }

    .credits-section-title {
      font-family: var(--font-horror);
      font-size: 0.75rem;
      letter-spacing: 0.4em;
      color: var(--accent-blood);
      text-transform: uppercase;
      margin-top: 2rem;
      margin-bottom: 0.25rem;
    }

    .credits-name {
      font-size: 0.9rem;
      color: var(--text-ghost);
      letter-spacing: 0.08em;
    }

    .credits-role {
      font-size: 0.65rem;
      color: var(--text-dim);
      letter-spacing: 0.12em;
      font-style: italic;
    }

    .credits-back {
      position: absolute;
      bottom: 2rem;
      z-index: 10;
    }

    /* ===========================
       HORROR EFFECTS / MODALS
    =========================== */
    .jumpscare-overlay {
      position: fixed;
      inset: 0;
      z-index: 9990;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.95);
      animation: jumpscareFlash 0.6s ease;
    }

    .jumpscare-overlay.active { display: flex; }

    .jumpscare-image {
      font-size: 6rem;
      animation: jumpscareScale 0.5s ease;
    }

    .event-notification {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      border: 1px solid rgba(139,0,0,0.5);
      padding: 1rem 2rem;
      font-family: var(--font-horror);
      font-size: 1.2rem;
      color: #cc4444;
      text-shadow: 0 0 12px rgba(139,0,0,0.8);
      letter-spacing: 0.08em;
      text-align: center;
      animation: eventNotif 0.5s ease;
      pointer-events: none;
      z-index: 300;
    }

    .evidence-popup {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(5,0,0,0.95);
      border: 1px solid rgba(139,0,0,0.4);
      padding: 1.5rem;
      width: 280px;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      z-index: 400;
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
      pointer-events: auto;
      display: none;
    }

    .evidence-popup.active { display: flex; }

    .evidence-title {
      font-family: var(--font-horror);
      font-size: 1rem;
      color: var(--text-horror);
      text-shadow: 0 0 8px rgba(139,0,0,0.6);
      letter-spacing: 0.06em;
    }

    .evidence-body {
      font-size: 0.75rem;
      color: var(--text-dim);
      line-height: 1.6;
      font-style: italic;
    }

    /* ===========================
       UTILITY CLASSES
    =========================== */
    .hidden { display: none !important; }
    .invisible { visibility: hidden; }
    .text-center { text-align: center; }
    .text-blood { color: var(--accent-blood); }
    .text-horror { color: var(--text-horror); }
    .text-dim { color: var(--text-dim); }
    .text-ghost { color: var(--text-ghost); }
    .glow-red { text-shadow: 0 0 10px rgba(139,0,0,0.8), 0 0 20px rgba(100,0,0,0.5); }
    .mt-1 { margin-top: 0.5rem; }
    .mt-2 { margin-top: 1rem; }
    .mb-1 { margin-bottom: 0.5rem; }
    .mb-2 { margin-bottom: 1rem; }
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .items-center { align-items: center; }
    .justify-center { justify-content: center; }
    .gap-1 { gap: 0.5rem; }
    .gap-2 { gap: 1rem; }
    .w-full { width: 100%; }
    .horror-border {
      border: 1px solid var(--border-horror);
      box-shadow: 0 0 8px rgba(139,0,0,0.1), inset 0 0 8px rgba(0,0,0,0.3);
    }
    .panel {
      background: rgba(8,0,0,0.85);
      border: 1px solid rgba(50,0,0,0.4);
      padding: 1rem;
    }

    /* ===========================
       ANIMATIONS
    =========================== */
    @keyframes screenFadeIn {
      from { opacity: 0; transform: scale(1.01); }
      to   { opacity: 1; transform: scale(1); }
    }

    @keyframes flicker {
      0%,100%  { opacity: 1; }
      4%       { opacity: 0.8; }
      8%       { opacity: 1; }
      15%      { opacity: 0.95; }
      20%      { opacity: 1; }
      60%      { opacity: 1; }
      65%      { opacity: 0.85; }
      67%      { opacity: 1; }
      75%      { opacity: 0.9; }
      80%      { opacity: 1; }
    }

    @keyframes subtitleFlicker {
      0%,100%  { opacity: 0.7; }
      10%      { opacity: 0.3; }
      12%      { opacity: 0.7; }
      20%      { opacity: 0.65; }
      22%      { opacity: 0.7; }
      50%      { opacity: 0.7; }
      55%      { opacity: 0.1; }
      56%      { opacity: 0.7; }
      90%      { opacity: 0.7; }
      95%      { opacity: 0.4; }
      97%      { opacity: 0.7; }
    }

    @keyframes titlePulse {
      0%,100% { text-shadow: 0 0 10px rgba(139,0,0,0.9), 0 0 25px rgba(139,0,0,0.6), 0 0 50px rgba(100,0,0,0.4), 2px 2px 0px rgba(0,0,0,0.8); }
      50%     { text-shadow: 0 0 15px rgba(180,0,0,1),   0 0 35px rgba(139,0,0,0.8), 0 0 70px rgba(100,0,0,0.5), 2px 2px 0px rgba(0,0,0,0.8); }
    }

    @keyframes scanlineMove {
      from { background-position: 0 0; }
      to   { background-position: 0 100%; }
    }

    @keyframes vhsNoise {
      0%  { background-position: 0 0; }
      10% { background-position: -5% -10%; }
      20% { background-position: -15% 5%; }
      30% { background-position: 7% -25%; }
      40% { background-position: 20% 25%; }
      50% { background-position: -25% 10%; }
      60% { background-position: 15% 5%; }
      70% { background-position: 0 15%; }
      80% { background-position: 25% 35%; }
      90% { background-position: -10% 10%; }
      100%{ background-position: 0 0; }
    }

    @keyframes glitchBand {
      0%   { top: -5%; opacity: 0; }
      5%   { opacity: 1; }
      10%  { top: 110%; opacity: 0; }
      100% { top: 110%; opacity: 0; }
    }

    @keyframes fogDrift1 {
      0%   { transform: translate(0, 0) scale(1); }
      50%  { transform: translate(5%, 3%) scale(1.05); }
      100% { transform: translate(-3%, -2%) scale(0.98); }
    }

    @keyframes fogDrift2 {
      0%   { transform: translate(0, 0) rotate(0deg); }
      50%  { transform: translate(-4%, 2%) rotate(2deg); }
      100% { transform: translate(3%, -3%) rotate(-1deg); }
    }

    @keyframes fogFloat {
      0%   { transform: translate(0, 0) scale(1); opacity: 0; }
      10%  { opacity: 1; }
      90%  { opacity: 0.6; }
      100% { transform: translate(var(--fog-dx, 80px), var(--fog-dy, -120px)) scale(1.4); opacity: 0; }
    }

    @keyframes pulse {
      0%,100% { opacity: 1; }
      50%     { opacity: 0.5; }
    }

    @keyframes ledBlink {
      0%,100% { opacity: 1; }
      50%     { opacity: 0.25; }
    }

    @keyframes sanityWarn {
      0%,100% { filter: drop-shadow(0 0 4px var(--sanity-yellow)); }
      50%     { filter: drop-shadow(0 0 10px var(--sanity-yellow)); }
    }

    @keyframes sanityCrit {
      0%,100% { filter: drop-shadow(0 0 6px var(--sanity-red)); opacity: 1; }
      50%     { filter: drop-shadow(0 0 15px var(--sanity-red)); opacity: 0.7; }
    }

    @keyframes codeFlicker {
      0%,100% { opacity: 1; }
      7%      { opacity: 0.6; }
      8%      { opacity: 1; }
      80%     { opacity: 1; }
      83%     { opacity: 0.5; }
      85%     { opacity: 1; }
    }

    @keyframes inventoryAppear {
      from { opacity: 0; transform: translateX(-50%) scale(0.85); }
      to   { opacity: 1; transform: translateX(-50%) scale(1); }
    }

    @keyframes chatMsgIn {
      from { opacity: 0; transform: translateX(-10px); }
      to   { opacity: 1; transform: translateX(0); }
    }

    @keyframes btnIconShake {
      0%,100% { transform: rotate(0deg); }
      25%     { transform: rotate(-8deg); }
      75%     { transform: rotate(8deg); }
    }

    @keyframes btnDanger {
      0%,100% { transform: translateX(0); }
      20%     { transform: translateX(-3px); }
      40%     { transform: translateX(3px); }
      60%     { transform: translateX(-2px); }
      80%     { transform: translateX(2px); }
    }

    @keyframes loadingPulse {
      0%,100% { transform: scale(1); opacity: 0.8; }
      50%     { transform: scale(1.1); opacity: 1; }
    }

    @keyframes loadingShimmer {
      0%   { opacity: 0; }
      50%  { opacity: 1; }
      100% { opacity: 0; }
    }

    @keyframes deathGlitch {
      0%   { text-shadow: 0 0 10px rgba(180,0,0,0.9), 0 0 30px rgba(139,0,0,0.7), 0 0 60px rgba(100,0,0,0.4); transform: none; }
      20%  { text-shadow: -3px 0 rgba(255,0,0,0.7), 3px 0 rgba(0,0,255,0.5), 0 0 30px rgba(139,0,0,0.7); transform: skewX(-2deg); }
      40%  { text-shadow: 3px 0 rgba(255,0,0,0.7), -3px 0 rgba(0,0,200,0.5), 0 0 30px rgba(139,0,0,0.7); transform: skewX(2deg); }
      60%  { text-shadow: 0 0 15px rgba(200,0,0,1), 0 0 40px rgba(139,0,0,0.8); transform: none; }
      100% { text-shadow: 0 0 10px rgba(180,0,0,0.9), 0 0 30px rgba(139,0,0,0.7); transform: none; }
    }

    @keyframes staticNoise {
      0%  { background-position: 0 0; }
      25% { background-position: 40px -50px; }
      50% { background-position: -30px 30px; }
      75% { background-position: 20px 60px; }
      100%{ background-position: -10px -40px; }
    }

    @keyframes deathBand {
      0%   { top: -10%; height: 4px; background: rgba(255,255,255,0.08); opacity: 0; }
      10%  { opacity: 1; }
      90%  { opacity: 0.8; }
      100% { top: 110%; height: 8px; background: rgba(255,0,0,0.06); opacity: 0; }
    }

    @keyframes jumpscareFlash {
      0%  { background: #fff; }
      20% { background: #ff0000; }
      40% { background: rgba(0,0,0,0.98); }
      100%{ background: rgba(0,0,0,0.95); }
    }

    @keyframes jumpscareScale {
      0%  { transform: scale(0.3) rotate(-5deg); opacity: 0; }
      40% { transform: scale(1.2) rotate(2deg); opacity: 1; }
      100%{ transform: scale(1) rotate(0deg); opacity: 1; }
    }

    @keyframes eventNotif {
      from { opacity: 0; transform: translate(-50%, -60%); }
      to   { opacity: 1; transform: translate(-50%, -50%); }
    }

    @keyframes creditsScroll {
      from { transform: translateY(100vh); }
      to   { transform: translateY(-100%); }
    }

    /* ===========================
       RESPONSIVE: MOBILE
    =========================== */
    @media screen and (max-width: 767px) {
      .lobby-container {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto auto;
        padding: 0.75rem;
        gap: 0.75rem;
        overflow-y: auto;
        height: 100%;
      }

      .lobby-header {
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .char-cards-grid {
        grid-template-columns: 1fr 1fr;
      }

      .char-card { padding: 0.6rem 0.5rem; }
      .char-portrait { width: 44px; height: 44px; font-size: 1.2rem; }
      .char-name { font-size: 0.7rem; }
      .char-role { font-size: 0.55rem; }

      .lobby-chat { max-height: 200px; }
      .chat-messages { max-height: 130px; }

      .hud-minimap { width: 85px; height: 85px; }
      .hud-sanity { top: 0.5rem; left: 0.5rem; }
      .sanity-ring { width: 48px; height: 48px; }
      .sanity-svg { width: 48px; height: 48px; }
      .sanity-value { font-size: 0.9rem; }

      .hud-flashlight { top: 0.5rem; left: calc(0.5rem + 110px); }

      .hud-chat { width: 200px; bottom: 0.5rem; left: 0.5rem; }
      .hud-chat-messages { max-height: 80px; }
      .hud-chat-msg { font-size: 0.62rem; }

      .touch-controls { display: block; }
      .touch-controls.active { display: block; }

      .hud-inventory {
        bottom: 8rem;
      }

      .pause-container { padding: 1.5rem; gap: 1rem; }
      .pause-title { font-size: 1.4rem; }

      .gameover-title { font-size: 2.5rem; }
      .gameover-buttons { flex-direction: column; align-items: center; }

      .options-container { padding: 1rem; gap: 1rem; }
      .options-row { flex-wrap: wrap; gap: 0.5rem; }
      .options-slider { width: 100%; }

      .menu-content { padding: 1rem; }
      .menu-buttons { max-width: 100%; }
      .menu-title { font-size: clamp(1.6rem, 7vw, 2.5rem); }

      .btn { padding: 0.7rem 1.2rem; font-size: 0.78rem; }
      .btn-lg { padding: 0.8rem 1.5rem; font-size: 0.85rem; }

      .room-code-display { flex-wrap: wrap; gap: 0.25rem; }
      .room-code-value { font-size: 1.1rem; }
    }

    /* ===========================
       RESPONSIVE: TABLET
    =========================== */
    @media screen and (min-width: 768px) and (max-width: 1024px) {
      .lobby-container {
        grid-template-columns: 1fr 280px;
        padding: 1rem;
      }

      .char-cards-grid {
        grid-template-columns: 1fr 1fr;
      }

      .hud-minimap { width: 100px; height: 100px; }

      .touch-controls.active { display: block; }

      .menu-title { font-size: clamp(1.8rem, 5vw, 3rem); }
    }

    /* ===========================
       RESPONSIVE: DESKTOP LARGE
    =========================== */
    @media screen and (min-width: 1400px) {
      .lobby-container { max-width: 1280px; }
      .menu-content { max-width: 520px; }
      .menu-title { font-size: 4.2rem; }
      .hud-minimap { width: 140px; height: 140px; }
    }

    /* ===========================
       LANDSCAPE PHONE
    =========================== */
    @media screen and (max-height: 500px) and (orientation: landscape) {
      .menu-content { gap: 0; padding: 0.5rem 1rem; }
      .menu-title { font-size: 1.6rem; }
      .menu-subtitle { margin-bottom: 0.75rem; }
      .menu-divider { margin-bottom: 0.75rem; }
      .menu-buttons { gap: 0.4rem; max-width: 220px; }
      .btn { padding: 0.5rem 1rem; font-size: 0.72rem; }

      .hud-sanity { top: 0.25rem; left: 0.25rem; }
      .hud-minimap { width: 70px; height: 70px; top: 0.25rem; right: 0.25rem; }
      .hud-flashlight { top: 0.25rem; }
      .hud-chat { bottom: 0.25rem; }

      .joystick-zone { bottom: 0.5rem; left: 0.5rem; width: 100px; height: 100px; }
      .touch-action-buttons { bottom: 0.5rem; right: 0.5rem; }
      .touch-btn { width: 42px; height: 42px; }
    }

    /* ===========================
       PREFERS-REDUCED-MOTION
    =========================== */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body class="horror-body">

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- LOADING SCREEN                                        -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="loading-screen" class="screen active">
  <div class="loading-vhs-overlay"></div>
  <div class="loading-scanlines"></div>
  <div class="loading-content">
    <div class="loading-logo-container">
      <div class="loading-studio-name">OBSIDIAN VEIL STUDIOS</div>
      <div class="loading-title-wrapper">
        <h1 class="loading-title horror-title">El Susurro<br><span class="loading-title-accent">de la Inocente</span></h1>
        <div class="loading-title-glitch" aria-hidden="true">El Susurro<br>de la Inocente</div>
      </div>
      <div class="loading-subtitle">&#8220;Ella recuerda todo&#8221;</div>
    </div>
    <div class="loading-bar-container">
      <div class="loading-bar-label">
        <span class="loading-bar-label-text">CARGANDO</span>
        <span class="loading-bar-percent" id="loading-percent">0%</span>
      </div>
      <div class="loading-bar-track">
        <div class="loading-bar-fill" id="loading-bar"></div>
        <div class="loading-bar-glitch"></div>
      </div>
      <div class="loading-bar-ticks">
        <span></span><span></span><span></span><span></span><span></span>
        <span></span><span></span><span></span><span></span><span></span>
      </div>
    </div>
    <div class="loading-status">
      <span class="loading-icon">â¶</span>
      <span class="loading-text" id="loading-text">Inicializando sistemas</span>
      <span class="loading-ellipsis"><span>.</span><span>.</span><span>.</span></span>
    </div>
    <div class="loading-tip-container">
      <div class="loading-tip-header">// CONSEJO //</div>
      <p class="loading-tip-text" id="loading-tip">La niÃ±a se mueve mÃ¡s rÃ¡pido en la oscuridad. Conserva las baterÃ­as de tu linterna.</p>
    </div>
    <div class="loading-rec-indicator">
      <span class="loading-rec-dot"></span>
      <span class="loading-rec-text">REC</span>
    </div>
  </div>
</div>

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- MAIN MENU                                             -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="main-menu" class="screen" style="display:none;">
  <canvas id="menu-bg-canvas" class="menu-bg-canvas" aria-hidden="true"></canvas>
  <div class="menu-fog-overlay" aria-hidden="true"></div>
  <div class="menu-vhs-overlay" aria-hidden="true"></div>
  <div class="menu-scanlines" aria-hidden="true"></div>
  <div class="menu-noise" aria-hidden="true"></div>

  <div class="menu-content">
    <div class="menu-header">
      <div class="menu-studio">OBSIDIAN VEIL STUDIOS <span class="menu-presents">PRESENTA</span></div>
      <h1 class="menu-title horror-title">El Susurro<br><em>de la Inocente</em></h1>
      <h2 class="menu-subtitle flicker">Ella sabe lo que hiciste</h2>
      <div class="menu-version">v1.4.2</div>
    </div>

    <nav class="menu-buttons" role="navigation" aria-label="MenÃº principal">
      <button class="menu-btn menu-btn--primary" id="btn-play-solo" data-sound="click">
        <span class="menu-btn-icon">&#9654;</span>
        <span class="menu-btn-text">Jugar Solo</span>
        <span class="menu-btn-line"></span>
      </button>
      <button class="menu-btn menu-btn--primary" id="btn-multiplayer" data-sound="click">
        <span class="menu-btn-icon">&#9646;&#9646;</span>
        <span class="menu-btn-text">Multijugador</span>
        <span class="menu-btn-line"></span>
      </button>
      <button class="menu-btn" id="btn-options" data-sound="click">
        <span class="menu-btn-icon">&#9881;</span>
        <span class="menu-btn-text">Opciones</span>
        <span class="menu-btn-line"></span>
      </button>
      <button class="menu-btn" id="btn-credits" data-sound="click">
        <span class="menu-btn-icon">&#9733;</span>
        <span class="menu-btn-text">CrÃ©ditos</span>
        <span class="menu-btn-line"></span>
      </button>
    </nav>

    <div class="menu-footer">
      <span class="menu-rating">PEGI 18</span>
      <span class="menu-separator">|</span>
      <span class="menu-warning">Contiene imÃ¡genes perturbadoras</span>
    </div>
  </div>

  <div class="menu-corner menu-corner--tl" aria-hidden="true"></div>
  <div class="menu-corner menu-corner--tr" aria-hidden="true"></div>
  <div class="menu-corner menu-corner--bl" aria-hidden="true"></div>
  <div class="menu-corner menu-corner--br" aria-hidden="true"></div>
</div>

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- CHARACTER SELECT                                      -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="character-select" class="screen" style="display:none;">
  <div class="cs-scanlines" aria-hidden="true"></div>
  <div class="cs-header">
    <h2 class="cs-title">Selecciona tu Personaje</h2>
    <div class="cs-title-line"></div>
    <p class="cs-subtitle">Cada superviviente tiene habilidades Ãºnicas. Elige sabiamente.</p>
  </div>

  <div class="cs-grid" role="list" aria-label="Personajes disponibles">

    <!-- Elena VÃ¡squez -->
    <div class="cs-card" id="card-elena" data-character="elena" data-accent="blue" role="listitem" tabindex="0" aria-selected="false">
      <div class="cs-card-glow cs-card-glow--blue"></div>
      <div class="cs-card-border"></div>
      <div class="cs-card-inner">
        <div class="cs-card-icon" aria-hidden="true">ð</div>
        <div class="cs-card-info">
          <h3 class="cs-card-name">Elena VÃ¡squez</h3>
          <div class="cs-card-role cs-card-role--blue">La Investigadora</div>
        </div>
        <div class="cs-card-portrait cs-card-portrait--elena" aria-hidden="true">
          <div class="cs-portrait-silhouette"></div>
        </div>
        <div class="cs-card-stats">
          <div class="cs-stat">
            <span class="cs-stat-label">Cordura</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--blue" style="width:90%"></div></div>
          </div>
          <div class="cs-stat">
            <span class="cs-stat-label">Resistencia</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--blue" style="width:60%"></div></div>
          </div>
          <div class="cs-stat">
            <span class="cs-stat-label">PercepciÃ³n</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--blue" style="width:80%"></div></div>
          </div>
        </div>
        <ul class="cs-card-abilities" aria-label="Habilidades">
          <li class="cs-ability cs-ability--blue"><span class="cs-ability-icon">â</span> Cordura Alta</li>
          <li class="cs-ability cs-ability--blue"><span class="cs-ability-icon">â</span> InvestigaciÃ³n+</li>
          <li class="cs-ability cs-ability--blue"><span class="cs-ability-icon">â</span> Liderazgo</li>
        </ul>
        <div class="cs-card-select-indicator" aria-hidden="true">SELECCIONADO</div>
      </div>
    </div>

    <!-- Diego Montero -->
    <div class="cs-card" id="card-diego" data-character="diego" data-accent="green" role="listitem" tabindex="0" aria-selected="false">
      <div class="cs-card-glow cs-card-glow--green"></div>
      <div class="cs-card-border"></div>
      <div class="cs-card-inner">
        <div class="cs-card-icon" aria-hidden="true">ð¡ï¸</div>
        <div class="cs-card-info">
          <h3 class="cs-card-name">Diego Montero</h3>
          <div class="cs-card-role cs-card-role--green">El Defensor</div>
        </div>
        <div class="cs-card-portrait cs-card-portrait--diego" aria-hidden="true">
          <div class="cs-portrait-silhouette"></div>
        </div>
        <div class="cs-card-stats">
          <div class="cs-stat">
            <span class="cs-stat-label">Cordura</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--green" style="width:60%"></div></div>
          </div>
          <div class="cs-stat">
            <span class="cs-stat-label">Resistencia</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--green" style="width:95%"></div></div>
          </div>
          <div class="cs-stat">
            <span class="cs-stat-label">PercepciÃ³n</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--green" style="width:50%"></div></div>
          </div>
        </div>
        <ul class="cs-card-abilities" aria-label="Habilidades">
          <li class="cs-ability cs-ability--green"><span class="cs-ability-icon">â</span> Resistencia Alta</li>
          <li class="cs-ability cs-ability--green"><span class="cs-ability-icon">â</span> Memoria Espacial</li>
          <li class="cs-ability cs-ability--green"><span class="cs-ability-icon">â</span> Combate</li>
        </ul>
        <div class="cs-card-select-indicator" aria-hidden="true">SELECCIONADO</div>
      </div>
    </div>

    <!-- Camila Torres -->
    <div class="cs-card" id="card-camila" data-character="camila" data-accent="purple" role="listitem" tabindex="0" aria-selected="false">
      <div class="cs-card-glow cs-card-glow--purple"></div>
      <div class="cs-card-border"></div>
      <div class="cs-card-inner">
        <div class="cs-card-icon" aria-hidden="true">ðï¸</div>
        <div class="cs-card-info">
          <h3 class="cs-card-name">Camila Torres</h3>
          <div class="cs-card-role cs-card-role--purple">La MÃ©dium</div>
        </div>
        <div class="cs-card-portrait cs-card-portrait--camila" aria-hidden="true">
          <div class="cs-portrait-silhouette"></div>
        </div>
        <div class="cs-card-stats">
          <div class="cs-stat">
            <span class="cs-stat-label">Cordura</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--purple" style="width:50%"></div></div>
          </div>
          <div class="cs-stat">
            <span class="cs-stat-label">Resistencia</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--purple" style="width:55%"></div></div>
          </div>
          <div class="cs-stat">
            <span class="cs-stat-label">PercepciÃ³n</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--purple" style="width:98%"></div></div>
          </div>
        </div>
        <ul class="cs-card-abilities" aria-label="Habilidades">
          <li class="cs-ability cs-ability--purple"><span class="cs-ability-icon">â</span> PercepciÃ³n Alta</li>
          <li class="cs-ability cs-ability--purple"><span class="cs-ability-icon">â</span> Sentido Paranormal</li>
          <li class="cs-ability cs-ability--purple"><span class="cs-ability-icon">â</span> EmpatÃ­a</li>
        </ul>
        <div class="cs-card-select-indicator" aria-hidden="true">SELECCIONADO</div>
      </div>
    </div>

    <!-- Padre TomÃ¡s -->
    <div class="cs-card" id="card-tomas" data-character="tomas" data-accent="gold" role="listitem" tabindex="0" aria-selected="false">
      <div class="cs-card-glow cs-card-glow--gold"></div>
      <div class="cs-card-border"></div>
      <div class="cs-card-inner">
        <div class="cs-card-icon" aria-hidden="true">âï¸</div>
        <div class="cs-card-info">
          <h3 class="cs-card-name">Padre TomÃ¡s</h3>
          <div class="cs-card-role cs-card-role--gold">El Exorcista</div>
        </div>
        <div class="cs-card-portrait cs-card-portrait--tomas" aria-hidden="true">
          <div class="cs-portrait-silhouette"></div>
        </div>
        <div class="cs-card-stats">
          <div class="cs-stat">
            <span class="cs-stat-label">Cordura</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--gold" style="width:75%"></div></div>
          </div>
          <div class="cs-stat">
            <span class="cs-stat-label">Resistencia</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--gold" style="width:70%"></div></div>
          </div>
          <div class="cs-stat">
            <span class="cs-stat-label">PercepciÃ³n</span>
            <div class="cs-stat-bar"><div class="cs-stat-fill cs-stat-fill--gold" style="width:65%"></div></div>
          </div>
        </div>
        <ul class="cs-card-abilities" aria-label="Habilidades">
          <li class="cs-ability cs-ability--gold"><span class="cs-ability-icon">â</span> Fe Alta</li>
          <li class="cs-ability cs-ability--gold"><span class="cs-ability-icon">â</span> Exorcismo</li>
          <li class="cs-ability cs-ability--gold"><span class="cs-ability-icon">â</span> ProtecciÃ³n</li>
        </ul>
        <div class="cs-card-select-indicator" aria-hidden="true">SELECCIONADO</div>
      </div>
    </div>

  </div><!-- /cs-grid -->

  <div class="cs-actions">
    <button class="btn-secondary" id="btn-cs-back" data-sound="click">
      <span class="btn-icon">&#8592;</span> Volver
    </button>
    <div class="cs-selected-info">
      <span class="cs-selected-label">Seleccionado:</span>
      <span class="cs-selected-name" id="cs-selected-name">Ninguno</span>
    </div>
    <button class="btn-primary" id="btn-cs-confirm" data-sound="confirm" disabled>
      Confirmar <span class="btn-icon">&#8594;</span>
    </button>
  </div>
</div>

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- MULTIPLAYER LOBBY                                     -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="multiplayer-lobby" class="screen" style="display:none;">
  <div class="lobby-scanlines" aria-hidden="true"></div>
  <div class="lobby-header">
    <h2 class="lobby-title">Sala de Espera</h2>
    <div class="lobby-connection-status" id="lobby-connection-status">
      <span class="lobby-conn-dot lobby-conn-dot--connected"></span>
      <span class="lobby-conn-text">Conectado</span>
    </div>
  </div>

  <div class="lobby-layout">
    <!-- Left Panel -->
    <div class="lobby-left">
      <div class="lobby-room-code-panel">
        <div class="lobby-room-label">CÃDIGO DE SALA</div>
        <div class="lobby-room-code" id="lobby-room-code" aria-live="polite">XKRM-7749</div>
        <button class="lobby-copy-btn" id="btn-copy-code" data-sound="click" aria-label="Copiar cÃ³digo de sala">
          <span class="lobby-copy-icon">&#9112;</span>
          <span class="lobby-copy-text">Copiar CÃ³digo</span>
          <span class="lobby-copy-confirm" id="copy-confirm">Â¡Copiado!</span>
        </button>
        <div class="lobby-room-info">
          <span class="lobby-room-mode" id="lobby-mode">Modo: Cooperativo</span>
          <span class="lobby-room-map" id="lobby-map">Mapa: La MansiÃ³n</span>
        </div>
      </div>

      <div class="lobby-players-panel">
        <div class="lobby-players-label">JUGADORES <span id="lobby-player-count">1</span>/4</div>
        <div class="lobby-player-slots">

          <div class="lobby-player-slot lobby-player-slot--occupied" id="lobby-slot-1" data-slot="1">
            <div class="lobby-slot-avatar" data-character="">?</div>
            <div class="lobby-slot-info">
              <div class="lobby-slot-name" id="lobby-slot-1-name">Esperando...</div>
              <div class="lobby-slot-character" id="lobby-slot-1-char">&#8212;</div>
            </div>
            <div class="lobby-slot-status" id="lobby-slot-1-status">
              <span class="lobby-status-badge lobby-status-badge--host">ANFITRIÃN</span>
            </div>
          </div>

          <div class="lobby-player-slot lobby-player-slot--empty" id="lobby-slot-2" data-slot="2">
            <div class="lobby-slot-avatar lobby-slot-avatar--empty">+</div>
            <div class="lobby-slot-info">
              <div class="lobby-slot-name">Esperando jugador...</div>
              <div class="lobby-slot-character">&#8212;</div>
            </div>
            <div class="lobby-slot-status">
              <span class="lobby-status-badge lobby-status-badge--empty">VACÃO</span>
            </div>
          </div>

          <div class="lobby-player-slot lobby-player-slot--empty" id="lobby-slot-3" data-slot="3">
            <div class="lobby-slot-avatar lobby-slot-avatar--empty">+</div>
            <div class="lobby-slot-info">
              <div class="lobby-slot-name">Esperando jugador...</div>
              <div class="lobby-slot-character">&#8212;</div>
            </div>
            <div class="lobby-slot-status">
              <span class="lobby-status-badge lobby-status-badge--empty">VACÃO</span>
            </div>
          </div>

          <div class="lobby-player-slot lobby-player-slot--empty" id="lobby-slot-4" data-slot="4">
            <div class="lobby-slot-avatar lobby-slot-avatar--empty">+</div>
            <div class="lobby-slot-info">
              <div class="lobby-slot-name">Esperando jugador...</div>
              <div class="lobby-slot-character">&#8212;</div>
            </div>
            <div class="lobby-slot-status">
              <span class="lobby-status-badge lobby-status-badge--empty">VACÃO</span>
            </div>
          </div>

        </div>
      </div>
    </div><!-- /lobby-left -->

    <!-- Right Panel -->
    <div class="lobby-right">
      <div class="lobby-chat-panel">
        <div class="lobby-chat-header">COMUNICACIONES</div>
        <div class="lobby-chat-messages" id="lobby-chat-messages" role="log" aria-live="polite" aria-label="Chat de sala">
          <div class="lobby-chat-msg lobby-chat-msg--system">
            <span class="lobby-msg-text">&#9656; Sala creada. Comparte el cÃ³digo para invitar jugadores.</span>
          </div>
        </div>
        <div class="lobby-chat-input-row">
          <input type="text" class="lobby-chat-input" id="lobby-chat-input" placeholder="Escribe un mensaje..." maxlength="120" autocomplete="off" aria-label="Mensaje de chat">
          <button class="lobby-chat-send" id="btn-lobby-chat-send" data-sound="click" aria-label="Enviar mensaje">&#9658;</button>
        </div>
      </div>

      <div class="lobby-settings-panel">
        <div class="lobby-settings-label">CONFIGURACIÃN DE PARTIDA</div>
        <div class="lobby-setting-row">
          <label class="lobby-setting-label" for="lobby-difficulty">Dificultad</label>
          <select class="lobby-setting-select" id="lobby-difficulty">
            <option value="normal">Normal</option>
            <option value="hard">DifÃ­cil</option>
            <option value="nightmare">Pesadilla</option>
          </select>
        </div>
        <div class="lobby-setting-row">
          <label class="lobby-setting-label" for="lobby-map-select">Mapa</label>
          <select class="lobby-setting-select" id="lobby-map-select">
            <option value="mansion">La MansiÃ³n</option>
            <option value="hospital">Hospital Abandonado</option>
            <option value="orphanage">El Orfanato</option>
          </select>
        </div>
      </div>
    </div><!-- /lobby-right -->
  </div><!-- /lobby-layout -->

  <div class="lobby-actions">
    <button class="btn-secondary" id="btn-lobby-back" data-sound="click">
      <span class="btn-icon">&#8592;</span> Salir
    </button>
    <button class="btn-ready" id="btn-lobby-ready" data-sound="click" data-ready="false">
      <span class="btn-ready-icon">&#10003;</span>
      <span class="btn-ready-text">Listo</span>
    </button>
    <button class="btn-primary btn-start" id="btn-lobby-start" data-sound="confirm" disabled>
      Iniciar Partida <span class="btn-icon">&#9658;</span>
    </button>
  </div>
</div>

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- 3D GAME CONTAINER                                     -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="game-container" style="display:none;" aria-label="Ãrea de juego 3D">
  <!-- Three.js canvas will be appended here by JS -->
</div>

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- GAME HUD                                              -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="game-hud" class="hud" style="display:none;" role="region" aria-label="Interfaz de juego">

  <!-- Top-Left: Sanity + Battery -->
  <div class="hud-tl">
    <div class="hud-sanity-panel" aria-label="Medidor de cordura">
      <svg class="hud-sanity-ring" viewBox="0 0 80 80" width="80" height="80" aria-hidden="true">
        <circle class="hud-sanity-track" cx="40" cy="40" r="32" />
        <circle class="hud-sanity-fill" id="hud-sanity-fill" cx="40" cy="40" r="32"
          stroke-dasharray="201.06" stroke-dashoffset="0" />
        <text class="hud-sanity-pct" id="hud-sanity-pct" x="40" y="44" text-anchor="middle">100%</text>
      </svg>
      <div class="hud-sanity-label">CORDURA</div>
      <div class="hud-sanity-warn" id="hud-sanity-warn" aria-live="assertive"></div>
    </div>

    <div class="hud-battery-panel" aria-label="BaterÃ­a de linterna">
      <div class="hud-battery-label">LINTERNA</div>
      <div class="hud-battery-bar" role="meter" aria-valuenow="5" aria-valuemin="0" aria-valuemax="5">
        <div class="hud-battery-seg hud-battery-seg--on" id="hud-bat-1" data-seg="1"></div>
        <div class="hud-battery-seg hud-battery-seg--on" id="hud-bat-2" data-seg="2"></div>
        <div class="hud-battery-seg hud-battery-seg--on" id="hud-bat-3" data-seg="3"></div>
        <div class="hud-battery-seg hud-battery-seg--on" id="hud-bat-4" data-seg="4"></div>
        <div class="hud-battery-seg hud-battery-seg--on" id="hud-bat-5" data-seg="5"></div>
        <div class="hud-battery-cap"></div>
      </div>
      <div class="hud-battery-pct" id="hud-battery-pct">100%</div>
    </div>

    <div class="hud-emf-panel" aria-label="Lector EMF">
      <div class="hud-emf-label">LECTURA EMF</div>
      <div class="hud-emf-value" id="hud-emf-value">0.0 Î¼T</div>
      <div class="hud-emf-bar">
        <div class="hud-emf-fill" id="hud-emf-fill" style="width:0%"></div>
      </div>
      <div class="hud-emf-level" id="hud-emf-level">NIVEL 0</div>
    </div>

    <div class="hud-temp-panel" aria-label="Temperatura ambiente">
      <div class="hud-temp-label">TEMPERATURA</div>
      <div class="hud-temp-value" id="hud-temp-value">18Â°C</div>
      <div class="hud-temp-icon" id="hud-temp-icon" aria-hidden="true">ð¡ï¸</div>
    </div>

    <div class="hud-inventory-hint">
      <kbd class="hud-key">TAB</kbd>
      <span class="hud-key-hint">Inventario</span>
    </div>
  </div><!-- /hud-tl -->

  <!-- Top-Center: Objective -->
  <div class="hud-tc">
    <div class="hud-objective" id="hud-objective" aria-live="polite">
      <div class="hud-obj-label">OBJETIVO</div>
      <div class="hud-obj-text" id="hud-obj-text">Encuentra el diario de la niÃ±a</div>
      <div class="hud-obj-progress" id="hud-obj-progress">0/3 pistas encontradas</div>
    </div>
  </div>

  <!-- Top-Right: Player list + Minimap -->
  <div class="hud-tr">
    <div class="hud-players" aria-label="Estado de jugadores">
      <div class="hud-players-label">SUPERVIVIENTES</div>
      <ul class="hud-player-list" id="hud-player-list">
        <li class="hud-player-entry hud-player-entry--self" id="hud-player-1">
          <span class="hud-player-dot hud-player-dot--alive"></span>
          <span class="hud-player-icon">ð</span>
          <span class="hud-player-name" id="hud-pname-1">Elena V.</span>
          <span class="hud-player-status" id="hud-pstatus-1">Viva</span>
        </li>
        <li class="hud-player-entry" id="hud-player-2">
          <span class="hud-player-dot hud-player-dot--alive"></span>
          <span class="hud-player-icon">ð¡ï¸</span>
          <span class="hud-player-name" id="hud-pname-2">Diego M.</span>
          <span class="hud-player-status" id="hud-pstatus-2">Vivo</span>
        </li>
        <li class="hud-player-entry" id="hud-player-3">
          <span class="hud-player-dot hud-player-dot--alive"></span>
          <span class="hud-player-icon">ðï¸</span>
          <span class="hud-player-name" id="hud-pname-3">Camila T.</span>
          <span class="hud-player-status" id="hud-pstatus-3">Viva</span>
        </li>
        <li class="hud-player-entry" id="hud-player-4">
          <span class="hud-player-dot hud-player-dot--alive"></span>
          <span class="hud-player-icon">âï¸</span>
          <span class="hud-player-name" id="hud-pname-4">Padre T.</span>
          <span class="hud-player-status" id="hud-pstatus-4">Vivo</span>
        </li>
      </ul>
    </div>

    <div class="hud-minimap-container" aria-label="Minimapa">
      <div class="hud-minimap-label">MAPA</div>
      <canvas id="hud-minimap" class="hud-minimap" width="160" height="160" aria-label="Minimapa de la mansiÃ³n"></canvas>
      <div class="hud-minimap-player-dot" id="hud-minimap-dot"></div>
    </div>
  </div><!-- /hud-tr -->

  <!-- Bottom-Left: Chat -->
  <div class="hud-bl">
    <div class="hud-chat" id="hud-chat" aria-label="Chat de juego">
      <div class="hud-chat-messages" id="hud-chat-messages" role="log" aria-live="polite"></div>
      <div class="hud-chat-input-row" id="hud-chat-input-row" style="display:none;">
        <span class="hud-chat-prefix">&gt;</span>
        <input type="text" class="hud-chat-input" id="hud-chat-input" placeholder="Mensaje..." maxlength="80" autocomplete="off" aria-label="Escribir mensaje">
      </div>
      <div class="hud-chat-hint">
        <kbd class="hud-key">T</kbd> <span class="hud-key-hint">Chat</span>
      </div>
    </div>
  </div>

  <!-- Bottom-Center: Interaction Prompt -->
  <div class="hud-bc">
    <div class="hud-interact" id="hud-interact" aria-live="polite" style="display:none;">
      <div class="hud-interact-inner">
        <kbd class="hud-interact-key">E</kbd>
        <span class="hud-interact-text" id="hud-interact-text">Presiona E para interactuar</span>
      </div>
      <div class="hud-interact-progress" id="hud-interact-progress">
        <div class="hud-interact-fill" id="hud-interact-fill"></div>
      </div>
    </div>
  </div>

  <!-- Bottom-Right: Crouch indicator -->
  <div class="hud-br">
    <div class="hud-stance" id="hud-stance">
      <span class="hud-stance-icon" id="hud-stance-icon" aria-hidden="true">ð§</span>
      <span class="hud-stance-text" id="hud-stance-text">De pie</span>
    </div>
  </div>

  <!-- RADIAL INVENTORY WHEEL -->
  <div id="inventory-wheel" class="inventory-wheel" style="display:none;" role="dialog" aria-label="Inventario radial" aria-modal="true">
    <div class="inv-wheel-bg" aria-hidden="true"></div>
    <div class="inv-wheel-center">
      <div class="inv-center-icon" id="inv-center-icon" aria-hidden="true">&#9718;</div>
      <div class="inv-center-name" id="inv-center-name">Inventario</div>
    </div>
    <!-- 4 quadrant items -->
    <div class="inv-item inv-item--top" id="inv-item-1" data-item="linterna" tabindex="0" role="button" aria-label="Linterna">
      <div class="inv-item-icon" aria-hidden="true">ð¦</div>
      <div class="inv-item-name">Linterna</div>
      <div class="inv-item-count" id="inv-count-1"></div>
      <div class="inv-item-condition">
        <div class="inv-condition-fill" id="inv-cond-1" style="width:100%"></div>
      </div>
    </div>
    <div class="inv-item inv-item--right" id="inv-item-2" data-item="cruz" tabindex="0" role="button" aria-label="Cruz de Sal">
      <div class="inv-item-icon" aria-hidden="true">âï¸</div>
      <div class="inv-item-name">Cruz de Sal</div>
      <div class="inv-item-count" id="inv-count-2">x3</div>
      <div class="inv-item-condition">
        <div class="inv-condition-fill" id="inv-cond-2" style="width:80%"></div>
      </div>
    </div>
    <div class="inv-item inv-item--bottom" id="inv-item-3" data-item="walkie" tabindex="0" role="button" aria-label="Walkie-Talkie">
      <div class="inv-item-icon" aria-hidden="true">ð»</div>
      <div class="inv-item-name">Walkie-Talkie</div>
      <div class="inv-item-count" id="inv-count-3"></div>
      <div class="inv-item-condition">
        <div class="inv-condition-fill" id="inv-cond-3" style="width:65%"></div>
      </div>
    </div>
    <div class="inv-item inv-item--left" id="inv-item-4" data-item="libro" tabindex="0" role="button" aria-label="Libro de Rezos">
      <div class="inv-item-icon" aria-hidden="true">ð</div>
      <div class="inv-item-name">Libro de Rezos</div>
      <div class="inv-item-count" id="inv-count-4"></div>
      <div class="inv-item-condition">
        <div class="inv-condition-fill" id="inv-cond-4" style="width:90%"></div>
      </div>
    </div>
    <div class="inv-wheel-hint">
      <kbd class="hud-key">TAB</kbd> para cerrar &nbsp;|&nbsp; Click para usar
    </div>
  </div><!-- /inventory-wheel -->

  <!-- Ambient horror overlays -->
  <div class="hud-vhs" aria-hidden="true"></div>
  <div class="hud-vignette" aria-hidden="true"></div>
  <div class="hud-sanity-overlay" id="hud-sanity-overlay" aria-hidden="true"></div>

</div><!-- /game-hud -->

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- MOBILE CONTROLS                                       -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="mobile-controls" style="display:none;" aria-label="Controles tÃ¡ctiles" role="region">

  <!-- Left: Joystick -->
  <div class="mobile-joystick-zone" id="mobile-joystick-zone" aria-label="Joystick de movimiento">
    <div class="mobile-joystick-base" id="mobile-joystick-base">
      <div class="mobile-joystick-ring"></div>
      <div class="mobile-joystick-stick" id="mobile-joystick-stick"></div>
    </div>
    <div class="mobile-joystick-label">MOVER</div>
  </div>

  <!-- Right: Camera look area -->
  <div class="mobile-look-zone" id="mobile-look-zone" aria-label="Ãrea de cÃ¡mara"></div>

  <!-- Action buttons (bottom-right) -->
  <div class="mobile-action-buttons">
    <button class="mobile-btn mobile-btn--interact" id="mobile-btn-interact" aria-label="Interactuar">
      <span class="mobile-btn-label">E</span>
      <span class="mobile-btn-sublabel">Usar</span>
    </button>
    <button class="mobile-btn mobile-btn--flashlight" id="mobile-btn-flashlight" aria-label="Linterna">
      <span class="mobile-btn-icon" aria-hidden="true">ð¦</span>
      <span class="mobile-btn-sublabel">Luz</span>
    </button>
    <button class="mobile-btn mobile-btn--inventory" id="mobile-btn-inventory" aria-label="Inventario">
      <span class="mobile-btn-icon" aria-hidden="true">ð</span>
      <span class="mobile-btn-sublabel">Inv.</span>
    </button>
    <button class="mobile-btn mobile-btn--crouch" id="mobile-btn-crouch" aria-label="Agacharse">
      <span class="mobile-btn-icon" aria-hidden="true">ð§</span>
      <span class="mobile-btn-sublabel">Agach.</span>
    </button>
  </div>

  <!-- Mobile HUD top row -->
  <div class="mobile-hud-top">
    <div class="mobile-sanity-bar">
      <div class="mobile-sanity-fill" id="mobile-sanity-fill" style="width:100%"></div>
    </div>
    <button class="mobile-btn mobile-btn--pause mobile-btn--sm" id="mobile-btn-pause" aria-label="Pausa">&#9646;&#9646;</button>
  </div>

</div><!-- /mobile-controls -->

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- PAUSE MENU                                            -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="pause-menu" class="screen overlay-screen" style="display:none;" role="dialog" aria-modal="true" aria-label="MenÃº de pausa">
  <div class="pause-backdrop"></div>
  <div class="pause-panel">
    <div class="pause-vhs" aria-hidden="true"></div>
    <div class="pause-header">
      <div class="pause-rec" aria-hidden="true"><span class="pause-rec-dot"></span>PAUSADO</div>
      <h2 class="pause-title">PAUSA</h2>
      <div class="pause-divider"></div>
    </div>

    <div class="pause-content">
      <!-- Pause nav -->
      <nav class="pause-nav" id="pause-nav">
        <button class="pause-btn pause-btn--primary" id="btn-resume" data-sound="click">
          <span class="pause-btn-icon">&#9658;</span> Reanudar
        </button>
        <button class="pause-btn" id="btn-pause-options" data-sound="click">
          <span class="pause-btn-icon">&#9881;</span> Opciones
        </button>
        <button class="pause-btn pause-btn--danger" id="btn-pause-quit" data-sound="click">
          <span class="pause-btn-icon">&#8962;</span> Salir al MenÃº
        </button>
      </nav>

      <!-- Inline options panel inside pause -->
      <div class="pause-options-panel" id="pause-options-panel" style="display:none;">
        <button class="pause-back-btn" id="btn-pause-back-opts" data-sound="click">
          <span>&#8592;</span> Volver
        </button>
        <h3 class="pause-opts-title">Opciones RÃ¡pidas</h3>

        <div class="pause-opts-section">
          <div class="pause-opts-label">VOLUMEN MÃSTER</div>
          <div class="pause-slider-row">
            <input type="range" class="opts-slider" id="pause-vol-master" min="0" max="100" value="80" aria-label="Volumen mÃ¡ster">
            <span class="opts-slider-val" id="pause-vol-master-val">80</span>
          </div>
          <div class="pause-opts-label">VOLUMEN MÃSICA</div>
          <div class="pause-slider-row">
            <input type="range" class="opts-slider" id="pause-vol-music" min="0" max="100" value="60" aria-label="Volumen mÃºsica">
            <span class="opts-slider-val" id="pause-vol-music-val">60</span>
          </div>
          <div class="pause-opts-label">VOLUMEN SFX</div>
          <div class="pause-slider-row">
            <input type="range" class="opts-slider" id="pause-vol-sfx" min="0" max="100" value="90" aria-label="Volumen SFX">
            <span class="opts-slider-val" id="pause-vol-sfx-val">90</span>
          </div>
        </div>

        <div class="pause-opts-section">
          <div class="pause-opts-label">SENSIBILIDAD DEL RATÃN</div>
          <div class="pause-slider-row">
            <input type="range" class="opts-slider" id="pause-sensitivity" min="1" max="10" value="5" aria-label="Sensibilidad">
            <span class="opts-slider-val" id="pause-sensitivity-val">5</span>
          </div>
        </div>

        <div class="pause-opts-section">
          <div class="pause-opts-label">CALIDAD GRÃFICA</div>
          <div class="pause-quality-row">
            <button class="pause-quality-btn" data-quality="low">Baja</button>
            <button class="pause-quality-btn pause-quality-btn--active" data-quality="medium">Media</button>
            <button class="pause-quality-btn" data-quality="high">Alta</button>
          </div>
        </div>
      </div>
    </div><!-- /pause-content -->

    <div class="pause-footer">
      <div class="pause-session-info">
        <span id="pause-session-time">Tiempo: 00:00</span>
        <span id="pause-session-mode">Modo: Solo</span>
      </div>
    </div>
  </div>
</div><!-- /pause-menu -->

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- DEATH SCREEN                                          -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="death-screen" class="screen" style="display:none;" role="dialog" aria-modal="true" aria-label="Pantalla de muerte">
  <div class="death-static" id="death-static" aria-hidden="true"></div>
  <div class="death-scanlines" aria-hidden="true"></div>
  <div class="death-vhs-noise" aria-hidden="true"></div>
  <div class="death-content">
    <div class="death-cassette" aria-hidden="true">
      <div class="death-cassette-label">CINTA 7 - ESCENA FINAL</div>
    </div>
    <div class="death-title-wrapper">
      <h2 class="death-title" id="death-title">HAS SIDO CONSUMIDO</h2>
      <div class="death-title-sub">POR LA OSCURIDAD</div>
    </div>
    <div class="death-reason-panel">
      <div class="death-reason-label">CAUSA</div>
      <p class="death-reason" id="death-reason">La niÃ±a te encontrÃ³ en la habitaciÃ³n sellada.</p>
    </div>
    <div class="death-stats">
      <div class="death-stat-item">
        <span class="death-stat-label">Tiempo sobrevivido</span>
        <span class="death-stat-val" id="death-time">08:34</span>
      </div>
      <div class="death-stat-item">
        <span class="death-stat-label">Pistas encontradas</span>
        <span class="death-stat-val" id="death-clues">2/5</span>
      </div>
      <div class="death-stat-item">
        <span class="death-stat-label">Cordura final</span>
        <span class="death-stat-val" id="death-sanity">12%</span>
      </div>
    </div>
    <div class="death-actions">
      <button class="btn-secondary death-btn" id="btn-spectate" data-sound="click">
        <span class="btn-icon">ðï¸</span> Espectar
      </button>
      <button class="btn-primary death-btn" id="btn-death-menu" data-sound="click">
        <span class="btn-icon">&#8962;</span> MenÃº Principal
      </button>
    </div>
    <div class="death-whisper" aria-hidden="true">&ldquo;SabÃ­a que vendrÃ­as aquÃ­&rdquo;</div>
  </div>
</div><!-- /death-screen -->

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- GAME OVER SCREEN                                      -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="game-over" class="screen" style="display:none;" role="dialog" aria-modal="true" aria-label="Fin de partida">
  <div class="gameover-bg" aria-hidden="true"></div>
  <div class="gameover-scanlines" aria-hidden="true"></div>
  <div class="gameover-content">
    <div class="gameover-ending-badge" id="gameover-ending-badge" data-ending="escape">
      <div class="gameover-ending-icon" id="gameover-ending-icon" aria-hidden="true">&#9733;</div>
    </div>
    <h2 class="gameover-title" id="gameover-title">PARTIDA TERMINADA</h2>
    <div class="gameover-ending-text" id="gameover-ending-text">Lograste escapar de la mansiÃ³n</div>
    <div class="gameover-rating" id="gameover-rating" aria-label="CalificaciÃ³n">
      <span class="gameover-star" data-star="1">&#9733;</span>
      <span class="gameover-star" data-star="2">&#9733;</span>
      <span class="gameover-star" data-star="3">&#9734;</span>
    </div>

    <div class="gameover-stats-grid">
      <div class="gameover-stat">
        <div class="gameover-stat-icon" aria-hidden="true">â±ï¸</div>
        <div class="gameover-stat-val" id="go-time">00:00</div>
        <div class="gameover-stat-label">Tiempo total</div>
      </div>
      <div class="gameover-stat">
        <div class="gameover-stat-icon" aria-hidden="true">ð</div>
        <div class="gameover-stat-val" id="go-clues">0/5</div>
        <div class="gameover-stat-label">Pistas</div>
      </div>
      <div class="gameover-stat">
        <div class="gameover-stat-icon" aria-hidden="true">ð¥</div>
        <div class="gameover-stat-val" id="go-survivors">0/4</div>
        <div class="gameover-stat-label">Supervivientes</div>
      </div>
      <div class="gameover-stat">
        <div class="gameover-stat-icon" aria-hidden="true">ðï¸</div>
        <div class="gameover-stat-val" id="go-encounters">0</div>
        <div class="gameover-stat-label">Encuentros</div>
      </div>
      <div class="gameover-stat">
        <div class="gameover-stat-icon" aria-hidden="true">ð§ </div>
        <div class="gameover-stat-val" id="go-sanity">0%</div>
        <div class="gameover-stat-label">Cordura promedio</div>
      </div>
      <div class="gameover-stat">
        <div class="gameover-stat-icon" aria-hidden="true">âï¸</div>
        <div class="gameover-stat-val" id="go-rituals">0</div>
        <div class="gameover-stat-label">Rituales completados</div>
      </div>
    </div>

    <div class="gameover-achievements" id="gameover-achievements" aria-label="Logros desbloqueados">
      <div class="gameover-ach-label">LOGROS DESBLOQUEADOS</div>
      <div class="gameover-ach-list" id="gameover-ach-list"></div>
    </div>

    <div class="gameover-actions">
      <button class="btn-primary" id="btn-go-replay" data-sound="confirm">
        <span class="btn-icon">&#9654;</span> Jugar de Nuevo
      </button>
      <button class="btn-secondary" id="btn-go-menu" data-sound="click">
        <span class="btn-icon">&#8962;</span> MenÃº Principal
      </button>
    </div>
  </div>
</div><!-- /game-over -->

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- CREDITS SCREEN                                        -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="credits-screen" class="screen" style="display:none;" role="dialog" aria-modal="true" aria-label="CrÃ©ditos">
  <div class="credits-bg" aria-hidden="true"></div>
  <div class="credits-vhs" aria-hidden="true"></div>
  <div class="credits-top-bar">
    <button class="btn-secondary credits-back-btn" id="btn-credits-back" data-sound="click">
      <span class="btn-icon">&#8592;</span> Volver
    </button>
    <div class="credits-top-title">CRÃDITOS</div>
  </div>
  <div class="credits-scroll-container" id="credits-scroll-container" role="list" aria-label="Lista de crÃ©ditos">
    <div class="credits-scroll" id="credits-scroll">

      <div class="credits-logo-block">
        <div class="credits-studio-logo" aria-hidden="true">â</div>
        <div class="credits-studio-name">OBSIDIAN VEIL STUDIOS</div>
        <div class="credits-game-title">El Susurro de la Inocente</div>
        <div class="credits-version">VersiÃ³n 1.4.2</div>
      </div>

      <div class="credits-section" role="listitem">
        <h3 class="credits-section-title">DirecciÃ³n</h3>
        <div class="credits-entry">
          <span class="credits-role">Director de Juego</span>
          <span class="credits-name">Alejandro Reyes</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Directora Creativa</span>
          <span class="credits-name">SofÃ­a Herrera</span>
        </div>
      </div>

      <div class="credits-section" role="listitem">
        <h3 class="credits-section-title">ProgramaciÃ³n</h3>
        <div class="credits-entry">
          <span class="credits-role">Programador Principal</span>
          <span class="credits-name">Marco Delgado</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Programadora de IA</span>
          <span class="credits-name">Valentina Cruz</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Programador de Red</span>
          <span class="credits-name">Rafael Mendoza</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Programadora de Efectos</span>
          <span class="credits-name">Isabella Romero</span>
        </div>
      </div>

      <div class="credits-section" role="listitem">
        <h3 class="credits-section-title">Arte &amp; DiseÃ±o</h3>
        <div class="credits-entry">
          <span class="credits-role">Director de Arte</span>
          <span class="credits-name">TomÃ¡s Vargas</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Artista 3D Principal</span>
          <span class="credits-name">Camila Ruiz</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">DiseÃ±adora de Entornos</span>
          <span class="credits-name">Elena Morales</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Artista de Personajes</span>
          <span class="credits-name">AndrÃ©s Castillo</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">DiseÃ±adora UI/UX</span>
          <span class="credits-name">LucÃ­a FernÃ¡ndez</span>
        </div>
      </div>

      <div class="credits-section" role="listitem">
        <h3 class="credits-section-title">Audio</h3>
        <div class="credits-entry">
          <span class="credits-role">Directora de Audio</span>
          <span class="credits-name">Marina LÃ³pez</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Compositor</span>
          <span class="credits-name">Diego AlarcÃ³n</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">DiseÃ±ador de Sonido</span>
          <span class="credits-name">Pablo SÃ¡nchez</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Actriz de Voz - La NiÃ±a</span>
          <span class="credits-name">Ana GarcÃ­a</span>
        </div>
      </div>

      <div class="credits-section" role="listitem">
        <h3 class="credits-section-title">Narrativa</h3>
        <div class="credits-entry">
          <span class="credits-role">Escritora Principal</span>
          <span class="credits-name">Carolina MejÃ­a</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">DiseÃ±ador de Niveles</span>
          <span class="credits-name">SebastiÃ¡n Torres</span>
        </div>
      </div>

      <div class="credits-section" role="listitem">
        <h3 class="credits-section-title">Control de Calidad</h3>
        <div class="credits-entry">
          <span class="credits-role">LÃ­der QA</span>
          <span class="credits-name">Natalia Ramos</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Testers</span>
          <span class="credits-name">El equipo Beta</span>
        </div>
      </div>

      <div class="credits-section" role="listitem">
        <h3 class="credits-section-title">TecnologÃ­as</h3>
        <div class="credits-entry">
          <span class="credits-role">Motor 3D</span>
          <span class="credits-name">Three.js</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Multijugador</span>
          <span class="credits-name">WebRTC / Socket.io</span>
        </div>
        <div class="credits-entry">
          <span class="credits-role">Audio</span>
          <span class="credits-name">Web Audio API</span>
        </div>
      </div>

      <div class="credits-section" role="listitem">
        <h3 class="credits-section-title">Agradecimientos Especiales</h3>
        <div class="credits-special">
          A todos los que creyeron que el horror puede ser arte.<br>
          A nuestra familia y amigos por su paciencia infinita.<br>
          A la comunidad de jugadores que hizo posible este sueÃ±o.
        </div>
      </div>

      <div class="credits-copyright">
        <div class="credits-divider-line"></div>
        <p>&copy; 2024 Obsidian Veil Studios. Todos los derechos reservados.</p>
        <p class="credits-tagline">&ldquo;El miedo mÃ¡s profundo es el que no puedes ver&rdquo;</p>
        <div class="credits-end-logo" aria-hidden="true">â</div>
      </div>

    </div><!-- /credits-scroll -->
  </div><!-- /credits-scroll-container -->
</div><!-- /credits-screen -->

<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<!-- OPTIONS SCREEN                                        -->
<!-- âââââââââââââââââââââââââââââââââââââââââââââââââââââââ -->
<div id="options-screen" class="screen" style="display:none;" role="dialog" aria-modal="true" aria-label="Opciones">
  <div class="opts-bg" aria-hidden="true"></div>
  <div class="opts-panel">
    <div class="opts-header">
      <h2 class="opts-title">Opciones</h2>
      <div class="opts-title-line"></div>
    </div>

    <div class="opts-layout">
      <!-- Tab navigation -->
      <div class="opts-tabs" role="tablist" aria-label="CategorÃ­as de opciones">
        <button class="opts-tab opts-tab--active" id="tab-audio" role="tab" aria-selected="true" aria-controls="opts-audio-panel" data-sound="click">ð Audio</button>
        <button class="opts-tab" id="tab-graphics" role="tab" aria-selected="false" aria-controls="opts-graphics-panel" data-sound="click">ð¥ï¸ GrÃ¡ficos</button>
        <button class="opts-tab" id="tab-controls" role="tab" aria-selected="false" aria-controls="opts-controls-panel" data-sound="click">ð® Controles</button>
      </div>

      <div class="opts-panels">

        <!-- Audio Panel -->
        <div class="opts-section opts-section--active" id="opts-audio-panel" role="tabpanel" aria-labelledby="tab-audio">
          <h3 class="opts-section-title">ConfiguraciÃ³n de Audio</h3>

          <div class="opts-control-group">
            <label class="opts-label" for="opt-vol-master">Volumen MÃ¡ster</label>
            <div class="opts-slider-row">
              <span class="opts-slider-icon" aria-hidden="true">ð</span>
              <input type="range" class="opts-slider" id="opt-vol-master" name="vol-master" min="0" max="100" value="80" aria-label="Volumen mÃ¡ster">
              <span class="opts-slider-icon" aria-hidden="true">ð</span>
              <span class="opts-slider-val" id="opt-vol-master-val" aria-live="polite">80</span>
            </div>
          </div>

          <div class="opts-control-group">
            <label class="opts-label" for="opt-vol-music">Volumen MÃºsica</label>
            <div class="opts-slider-row">
              <span class="opts-slider-icon" aria-hidden="true">ð</span>
              <input type="range" class="opts-slider" id="opt-vol-music" name="vol-music" min="0" max="100" value="60" aria-label="Volumen de mÃºsica">
              <span class="opts-slider-icon" aria-hidden="true">ð</span>
              <span class="opts-slider-val" id="opt-vol-music-val" aria-live="polite">60</span>
            </div>
          </div>

          <div class="opts-control-group">
            <label class="opts-label" for="opt-vol-sfx">Volumen SFX</label>
            <div class="opts-slider-row">
              <span class="opts-slider-icon" aria-hidden="true">ð</span>
              <input type="range" class="opts-slider" id="opt-vol-sfx" name="vol-sfx" min="0" max="100" value="90" aria-label="Volumen de efectos de sonido">
              <span class="opts-slider-icon" aria-hidden="true">ð</span>
              <span class="opts-slider-val" id="opt-vol-sfx-val" aria-live="polite">90</span>
            </div>
          </div>

          <div class="opts-control-group">
            <label class="opts-label" for="opt-vol-ambient">Volumen Ambiente</label>
            <div class="opts-slider-row">
              <span class="opts-slider-icon" aria-hidden="true">ð</span>
              <input type="range" class="opts-slider" id="opt-vol-ambient" name="vol-ambient" min="0" max="100" value="70" aria-label="Volumen de sonido ambiente">
              <span class="opts-slider-icon" aria-hidden="true">ð</span>
              <span class="opts-slider-val" id="opt-vol-ambient-val" aria-live="polite">70</span>
            </div>
          </div>

          <div class="opts-control-group opts-toggle-group">
            <label class="opts-label" for="opt-spatial-audio">Audio Espacial 3D</label>
            <label class="opts-toggle" aria-label="Activar audio espacial 3D">
              <input type="checkbox" id="opt-spatial-audio" checked>
              <span class="opts-toggle-slider"></span>
            </label>
          </div>

          <div class="opts-control-group opts-toggle-group">
            <label class="opts-label" for="opt-subtitles">SubtÃ­tulos</label>
            <label class="opts-toggle" aria-label="Activar subtÃ­tulos">
              <input type="checkbox" id="opt-subtitles" checked>
              <span class="opts-toggle-slider"></span>
            </label>
          </div>
        </div>

        <!-- Graphics Panel -->
        <div class="opts-section" id="opts-graphics-panel" role="tabpanel" aria-labelledby="tab-graphics" hidden>
          <h3 class="opts-section-title">ConfiguraciÃ³n de GrÃ¡ficos</h3>

          <div class="opts-control-group">
            <label class="opts-label">Calidad General</label>
            <div class="opts-quality-buttons" role="group" aria-label="Calidad grÃ¡fica">
              <button class="opts-quality-btn" data-quality="low" data-sound="click">Baja</button>
              <button class="opts-quality-btn opts-quality-btn--active" data-quality="medium" data-sound="click">Media</button>
              <button class="opts-quality-btn" data-quality="high" data-sound="click">Alta</button>
            </div>
          </div>

          <div class="opts-control-group opts-toggle-group">
            <label class="opts-label" for="opt-shadows">Sombras DinÃ¡micas</label>
            <label class="opts-toggle" aria-label="Activar sombras dinÃ¡micas">
              <input type="checkbox" id="opt-shadows" checked>
              <span class="opts-toggle-slider"></span>
            </label>
          </div>

          <div class="opts-control-group opts-toggle-group">
            <label class="opts-label" for="opt-fog">Niebla VolumÃ©trica</label>
            <label class="opts-toggle" aria-label="Activar niebla volumÃ©trica">
              <input type="checkbox" id="opt-fog" checked>
              <span class="opts-toggle-slider"></span>
            </label>
          </div>

          <div class="opts-control-group opts-toggle-group">
            <label class="opts-label" for="opt-postprocess">Post-Procesado</label>
            <label class="opts-toggle" aria-label="Activar post-procesado">
              <input type="checkbox" id="opt-postprocess" checked>
              <span class="opts-toggle-slider"></span>
            </label>
          </div>

          <div class="opts-control-group opts-toggle-group">
            <label class="opts-label" for="opt-vhs">Efecto VHS</label>
            <label class="opts-toggle" aria-label="Activar efecto VHS">
              <input type="checkbox" id="opt-vhs" checked>
              <span class="opts-toggle-slider"></span>
            </label>
          </div>

          <div class="opts-control-group opts-toggle-group">
            <label class="opts-label" for="opt-motion-blur">Motion Blur</label>
            <label class="opts-toggle" aria-label="Activar motion blur">
              <input type="checkbox" id="opt-motion-blur">
              <span class="opts-toggle-slider"></span>
            </label>
          </div>

          <div class="opts-control-group">
            <label class="opts-label" for="opt-fov">Campo de VisiÃ³n (FOV)</label>
            <div class="opts-slider-row">
              <span class="opts-slider-icon">60Â°</span>
              <input type="range" class="opts-slider" id="opt-fov" name="fov" min="60" max="110" value="75" aria-label="Campo de visiÃ³n">
              <span class="opts-slider-icon">110Â°</span>
              <span class="opts-slider-val" id="opt-fov-val" aria-live="polite">75Â°</span>
            </div>
          </div>
        </div>

        <!-- Controls Panel -->
        <div class="opts-section" id="opts-controls-panel" role="tabpanel" aria-labelledby="tab-controls" hidden>
          <h3 class="opts-section-title">ConfiguraciÃ³n de Controles</h3>

          <div class="opts-control-group">
            <label class="opts-label" for="opt-sensitivity">Sensibilidad del RatÃ³n</label>
            <div class="opts-slider-row">
              <span class="opts-slider-icon">1</span>
              <input type="range" class="opts-slider" id="opt-sensitivity" name="sensitivity" min="1" max="10" value="5" step="0.1" aria-label="Sensibilidad del ratÃ³n">
              <span class="opts-slider-icon">10</span>
              <span class="opts-slider-val" id="opt-sensitivity-val" aria-live="polite">5.0</span>
            </div>
          </div>

          <div class="opts-control-group opts-toggle-group">
            <label class="opts-label" for="opt-invert-y">Invertir Eje Y</label>
            <label class="opts-toggle" aria-label="Invertir eje Y">
              <input type="checkbox" id="opt-invert-y">
              <span class="opts-toggle-slider"></span>
            </label>
          </div>

          <div class="opts-control-group opts-toggle-group">
            <label class="opts-label" for="opt-toggle-sprint">Sprint AutomÃ¡tico</label>
            <label class="opts-toggle" aria-label="Sprint automÃ¡tico">
              <input type="checkbox" id="opt-toggle-sprint">
              <span class="opts-toggle-slider"></span>
            </label>
          </div>

          <div class="opts-keybinds">
            <div class="opts-keybinds-label">TECLAS DE CONTROL</div>
            <div class="opts-keybind-list">
              <div class="opts-keybind-row">
                <span class="opts-keybind-action">Moverse</span>
                <div class="opts-keybind-keys">
                  <kbd class="opts-key">W</kbd><kbd class="opts-key">A</kbd><kbd class="opts-key">S</kbd><kbd class="opts-key">D</kbd>
                </div>
              </div>
              <div class="opts-keybind-row">
                <span class="opts-keybind-action">Interactuar</span>
                <kbd class="opts-key">E</kbd>
              </div>
              <div class="opts-keybind-row">
                <span class="opts-keybind-action">Inventario</span>
                <kbd class="opts-key">TAB</kbd>
              </div>
              <div class="opts-keybind-row">
                <span class="opts-keybind-action">Linterna</span>
                <kbd class="opts-key">F</kbd>
              </div>
              <div class="opts-keybind-row">
                <span class="opts-keybind-action">Agacharse</span>
                <kbd class="opts-key">C</kbd>
              </div>
              <div class="opts-keybind-row">
                <span class="opts-keybind-action">Correr</span>
                <kbd class="opts-key">SHIFT</kbd>
              </div>
              <div class="opts-keybind-row">
                <span class="opts-keybind-action">Chat</span>
                <kbd class="opts-key">T</kbd>
              </div>
              <div class="opts-keybind-row">
                <span class="opts-keybind-action">Pausa</span>
                <kbd class="opts-key">ESC</kbd>
              </div>
            </div>
          </div>
        </div>

      </div><!-- /opts-panels -->
    </div><!-- /opts-layout -->

    <div class="opts-actions">
      <button class="btn-secondary" id="btn-opts-back" data-sound="click">
        <span class="btn-icon">&#8592;</span> Volver
      </button>
      <button class="btn-secondary" id="btn-opts-reset" data-sound="click">Restablecer</button>
      <button class="btn-primary" id="btn-opts-apply" data-sound="confirm">Aplicar</button>
    </div>
  </div><!-- /opts-panel -->
</div><!-- /options-screen -->


<!-- Additional elements for JS compatibility -->
<div id="hud-static-overlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:100;background:url('data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22/>') repeat;opacity:0;"></div>
<div id="hud-notification-container" style="position:fixed;top:80px;right:20px;z-index:200;pointer-events:none;"></div>
<div id="notification-toast" style="display:none;position:fixed;bottom:120px;left:50%;transform:translateX(-50%);background:rgba(139,0,0,0.9);color:#fff;padding:12px 24px;border-radius:4px;z-index:200;font-family:monospace;pointer-events:none;"></div>
<div id="transition-overlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:500;opacity:0;pointer-events:none;"></div>
<div id="chapter-end-screen" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:300;display:flex;align-items:center;justify-content:center;flex-direction:column;">
  <h1 style="color:#8b0000;font-size:2em;font-family:Georgia,serif;">CapÃ­tulo Completado</h1>
  <p style="color:#888;margin-top:1em;" id="chapter-end-text"></p>
  <button class="btn-primary" onclick="game.state.setState('menu')" style="margin-top:2em;padding:12px 32px;background:#8b0000;color:#fff;border:none;cursor:pointer;font-family:monospace;">Continuar</button>
</div>
<input type="text" id="room-code-input" style="display:none;" placeholder="CÃ³digo de sala">

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script>

// ========== DOM COMPATIBILITY LAYER ==========
// Map simplified JS IDs to actual HTML element IDs
(function setupDOMCompat() {
  const aliasMap = {
    'joystick-zone': 'mobile-joystick-zone',
    'camera-zone': 'mobile-look-zone',
    'mobile-interact': 'mobile-btn-interact',
    'mobile-crouch': 'mobile-btn-crouch',
    'mobile-flashlight': 'mobile-btn-flashlight',
    'hud': 'game-hud',
    'sanity-bar': 'hud-sanity-fill',
    'sanity-value': 'hud-sanity-pct',
    'battery-value': 'hud-battery-pct',
    'objective-text': 'hud-obj-text',
    'loading-bar-fill': 'loading-bar',
    'lobby-screen': 'multiplayer-lobby',
    'room-code-display': 'lobby-room-code',
    'game-over-screen': 'game-over',
    'character-select-screen': 'character-select',
    'settings-screen': 'options-screen',
    'mouse-sensitivity': 'opt-sensitivity',
    'invert-y': 'opt-invert-y'
  };
  
  // Create alias elements that reference the originals
  const origGetById = document.getElementById.bind(document);
  document.getElementById = function(id) {
    let el = origGetById(id);
    if (!el && aliasMap[id]) {
      el = origGetById(aliasMap[id]);
    }
    if (!el) {
      // Create a dummy hidden element to prevent null reference errors
      // console.warn('Creating placeholder for missing ID:', id);
      el = document.createElement('div');
      el.id = id;
      el.style.display = 'none';
      document.body.appendChild(el);
    }
    return el;
  };
})();

// ========== AUDIO ENGINE ==========
class AudioEngine {
  constructor() {
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

    this.masterGain = this.audioContext.createGain();
    this.masterGain.gain.setValueAtTime(0.8, this.audioContext.currentTime);
    this.masterGain.connect(this.audioContext.destination);

    this.musicGain = this.audioContext.createGain();
    this.musicGain.gain.setValueAtTime(0.5, this.audioContext.currentTime);
    this.musicGain.connect(this.masterGain);

    this.sfxGain = this.audioContext.createGain();
    this.sfxGain.gain.setValueAtTime(0.8, this.audioContext.currentTime);
    this.sfxGain.connect(this.masterGain);

    this.ambientGain = this.audioContext.createGain();
    this.ambientGain.gain.setValueAtTime(0.4, this.audioContext.currentTime);
    this.ambientGain.connect(this.masterGain);

    this.ambientNodes = [];
    this.heartbeatInterval = null;
    this.sanityLevel = 100;
    this.ambientRunning = false;
  }

  resume() {
    if (this.audioContext.state === 'suspended') {
      return this.audioContext.resume();
    }
    return Promise.resolve();
  }

  startAmbientMusic() {
    if (this.ambientRunning) return;
    this.ambientRunning = true;
    const ctx = this.audioContext;
    const now = ctx.currentTime;

    // Deep drone: 40Hz sine
    const drone1Osc = ctx.createOscillator();
    drone1Osc.type = 'sine';
    drone1Osc.frequency.setValueAtTime(40, now);
    const drone1Gain = ctx.createGain();
    drone1Gain.gain.setValueAtTime(0, now);
    drone1Gain.gain.linearRampToValueAtTime(0.6, now + 3);
    drone1Osc.connect(drone1Gain);
    drone1Gain.connect(this.ambientGain);
    drone1Osc.start(now);

    // Deep drone: 55Hz detuned sine
    const drone2Osc = ctx.createOscillator();
    drone2Osc.type = 'sine';
    drone2Osc.frequency.setValueAtTime(55.5, now);
    const drone2Gain = ctx.createGain();
    drone2Gain.gain.setValueAtTime(0, now);
    drone2Gain.gain.linearRampToValueAtTime(0.5, now + 3);
    drone2Osc.connect(drone2Gain);
    drone2Gain.connect(this.ambientGain);
    drone2Osc.start(now);

    // Eerie pad: 3 oscillators with slow LFO
    const padFreqs = [110, 164.81, 130.81];
    const padOscs = [];
    const padGains = [];
    padFreqs.forEach((freq, i) => {
      const osc = ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(freq, now);
      const g = ctx.createGain();
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.08, now + 5);
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(400 + i * 100, now);
      filter.Q.setValueAtTime(2, now);
      osc.connect(filter);
      filter.connect(g);
      g.connect(this.ambientGain);
      osc.start(now);
      padOscs.push(osc);
      padGains.push(g);
    });

    // Slow LFO modulating pad gain
    const lfo = ctx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.setValueAtTime(0.1, now);
    const lfoGain = ctx.createGain();
    lfoGain.gain.setValueAtTime(0.04, now);
    lfo.connect(lfoGain);
    padGains.forEach(g => lfoGain.connect(g.gain));
    lfo.start(now);

    this.ambientNodes = [drone1Osc, drone2Osc, ...padOscs, lfo, drone1Gain, drone2Gain, ...padGains, lfoGain];

    // Random dissonant notes every 10-20s
    const scheduleDissonant = () => {
      if (!this.ambientRunning) return;
      const delay = 10000 + Math.random() * 10000;
      this._dissonantTimeout = setTimeout(() => {
        if (!this.ambientRunning) return;
        this._playDissonantNote();
        scheduleDissonant();
      }, delay);
    };
    scheduleDissonant();
  }

  _playDissonantNote() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const baseFreq = 200 + Math.random() * 300;
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(baseFreq, now);
    osc.frequency.linearRampToValueAtTime(baseFreq * 1.059, now + 2);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(0.15, now + 0.5);
    g.gain.linearRampToValueAtTime(0, now + 3);
    osc.connect(g);
    g.connect(this.ambientGain);
    osc.start(now);
    osc.stop(now + 3.1);
  }

  stopAmbientMusic() {
    this.ambientRunning = false;
    if (this._dissonantTimeout) clearTimeout(this._dissonantTimeout);
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    this.ambientNodes.forEach(node => {
      if (node instanceof GainNode) {
        node.gain.setValueAtTime(node.gain.value, now);
        node.gain.linearRampToValueAtTime(0, now + 2);
      }
    });
    setTimeout(() => {
      this.ambientNodes.forEach(node => {
        try { node.disconnect(); } catch(e) {}
        if (node instanceof OscillatorNode) { try { node.stop(); } catch(e) {} }
      });
      this.ambientNodes = [];
    }, 2500);
  }

  playFootstep() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const duration = 0.08;
    const buffer = this.createNoise(duration, 'brown');
    const source = ctx.createBufferSource();
    source.buffer = buffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(400, now);
    filter.Q.setValueAtTime(0.8, now);

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.6, now);
    g.gain.linearRampToValueAtTime(0, now + duration);

    source.connect(filter);
    filter.connect(g);
    g.connect(this.sfxGain);
    source.start(now);
    source.stop(now + duration + 0.01);
  }

  playDoorCreak() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const duration = 1.5;

    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(200, now);
    osc.frequency.linearRampToValueAtTime(800, now + duration);

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(500, now);
    filter.Q.setValueAtTime(8, now);

    const g = ctx.createGain();
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(0.4, now + 0.05);
    g.gain.setValueAtTime(0.4, now + duration - 0.1);
    g.gain.linearRampToValueAtTime(0, now + duration);

    // Add some wobble
    const lfo = ctx.createOscillator();
    lfo.frequency.setValueAtTime(8, now);
    const lfoGain = ctx.createGain();
    lfoGain.gain.setValueAtTime(20, now);
    lfo.connect(lfoGain);
    lfoGain.connect(osc.frequency);

    osc.connect(filter);
    filter.connect(g);
    g.connect(this.sfxGain);
    lfo.start(now);
    osc.start(now);
    osc.stop(now + duration + 0.05);
    lfo.stop(now + duration + 0.05);
  }

  playDoorSlam() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;

    // Noise burst
    const noiseDuration = 0.15;
    const noiseBuffer = this.createNoise(noiseDuration, 'white');
    const noiseSource = ctx.createBufferSource();
    noiseSource.buffer = noiseBuffer;
    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'lowpass';
    noiseFilter.frequency.setValueAtTime(800, now);
    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(1.0, now);
    noiseGain.gain.linearRampToValueAtTime(0, now + noiseDuration);
    noiseSource.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(this.sfxGain);
    noiseSource.start(now);
    noiseSource.stop(now + noiseDuration + 0.01);

    // Low sine thump
    const thumpOsc = ctx.createOscillator();
    thumpOsc.type = 'sine';
    thumpOsc.frequency.setValueAtTime(60, now);
    thumpOsc.frequency.linearRampToValueAtTime(30, now + 0.3);
    const thumpGain = ctx.createGain();
    thumpGain.gain.setValueAtTime(1.0, now);
    thumpGain.gain.linearRampToValueAtTime(0, now + 0.3);
    thumpOsc.connect(thumpGain);
    thumpGain.connect(this.sfxGain);
    thumpOsc.start(now);
    thumpOsc.stop(now + 0.35);
  }

  playWhisper() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const duration = 2.0;

    const noiseBuffer = this.createNoise(duration, 'white');
    const source = ctx.createBufferSource();
    source.buffer = noiseBuffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(1800, now);
    filter.Q.setValueAtTime(1.5, now);

    // Tremolo LFO
    const tremoloLFO = ctx.createOscillator();
    tremoloLFO.frequency.setValueAtTime(6, now);
    const tremoloGain = ctx.createGain();
    tremoloGain.gain.setValueAtTime(0.3, now);
    tremoloLFO.connect(tremoloGain);

    const baseGain = ctx.createGain();
    baseGain.gain.setValueAtTime(0, now);
    baseGain.gain.linearRampToValueAtTime(0.3, now + 0.2);
    baseGain.gain.setValueAtTime(0.3, now + duration - 0.3);
    baseGain.gain.linearRampToValueAtTime(0, now + duration);
    tremoloGain.connect(baseGain.gain);

    // Random pan
    const panner = ctx.createStereoPanner();
    panner.pan.setValueAtTime(Math.random() * 2 - 1, now);

    source.connect(filter);
    filter.connect(baseGain);
    baseGain.connect(panner);
    panner.connect(this.sfxGain);

    tremoloLFO.start(now);
    source.start(now);
    source.stop(now + duration + 0.01);
    tremoloLFO.stop(now + duration + 0.01);
  }

  playJumpscare(intensity = 1.0) {
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const duration = 0.5;

    const waveshaper = ctx.createWaveShaper();
    waveshaper.curve = this.createDistortion(200 * intensity);
    waveshaper.oversample = '4x';

    const masterGainNode = ctx.createGain();
    masterGainNode.gain.setValueAtTime(intensity * 0.8, now);
    masterGainNode.gain.linearRampToValueAtTime(0, now + duration);

    // Two sawtooth oscillators a minor 2nd apart
    const freqs = [220, 233.08];
    freqs.forEach(freq => {
      const osc = ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(freq, now);
      osc.connect(waveshaper);
      osc.start(now);
      osc.stop(now + duration + 0.05);
    });

    // Also add upper harmonics
    const freqs2 = [440, 466.16];
    freqs2.forEach(freq => {
      const osc = ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(freq, now);
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.5, now);
      osc.connect(g);
      g.connect(waveshaper);
      osc.start(now);
      osc.stop(now + duration + 0.05);
    });

    waveshaper.connect(masterGainNode);
    masterGainNode.connect(this.sfxGain);
  }

  playHeartbeat(rate = 60) {
    const ctx = this.audioContext;
    const interval = 60 / rate;
    const now = ctx.currentTime;

    const playThump = (time) => {
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(60, time);
      osc.frequency.linearRampToValueAtTime(40, time + 0.1);
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.9, time);
      g.gain.linearRampToValueAtTime(0, time + 0.12);
      osc.connect(g);
      g.connect(this.sfxGain);
      osc.start(time);
      osc.stop(time + 0.15);
    };

    playThump(now);
    playThump(now + 0.15);

    return interval;
  }

  startHeartbeat(rate = 60) {
    this.stopHeartbeat();
    const interval = 60000 / rate;
    const dobeat = () => {
      this.playHeartbeat(rate);
    };
    dobeat();
    this.heartbeatInterval = setInterval(dobeat, interval);
  }

  stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }

  playBreathing(intensity = 0.5) {
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const duration = 4.0;

    const noiseBuffer = this.createNoise(duration, 'white');
    const source = ctx.createBufferSource();
    source.buffer = noiseBuffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(600, now);
    filter.Q.setValueAtTime(2.5, now);

    const g = ctx.createGain();
    // Inhale
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(intensity * 0.4, now + 1.0);
    // Pause
    g.gain.linearRampToValueAtTime(intensity * 0.1, now + 1.4);
    // Exhale
    g.gain.linearRampToValueAtTime(intensity * 0.35, now + 2.5);
    g.gain.linearRampToValueAtTime(0, now + duration);

    source.connect(filter);
    filter.connect(g);
    g.connect(this.sfxGain);
    source.start(now);
    source.stop(now + duration + 0.01);
  }

  playStaticNoise(duration = 1.0) {
    const ctx = this.audioContext;
    const now = ctx.currentTime;

    const noiseBuffer = this.createNoise(duration, 'white');
    const source = ctx.createBufferSource();
    source.buffer = noiseBuffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(3000, now);
    filter.Q.setValueAtTime(0.5, now);

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.5, now);
    g.gain.linearRampToValueAtTime(0.5, now + duration - 0.05);
    g.gain.linearRampToValueAtTime(0, now + duration);

    source.connect(filter);
    filter.connect(g);
    g.connect(this.sfxGain);
    source.start(now);
    source.stop(now + duration + 0.01);
  }

  playCreak() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;

    const baseFreq = 100 + Math.random() * 200;
    const modFreq = 2 + Math.random() * 10;
    const modDepth = 20 + Math.random() * 80;
    const duration = 0.3 + Math.random() * 0.7;

    const carrier = ctx.createOscillator();
    carrier.type = 'sine';
    carrier.frequency.setValueAtTime(baseFreq, now);

    const modulator = ctx.createOscillator();
    modulator.type = 'sine';
    modulator.frequency.setValueAtTime(modFreq, now);

    const modGain = ctx.createGain();
    modGain.gain.setValueAtTime(modDepth, now);
    modulator.connect(modGain);
    modGain.connect(carrier.frequency);

    const g = ctx.createGain();
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(0.4, now + 0.02);
    g.gain.setValueAtTime(0.4, now + duration - 0.05);
    g.gain.linearRampToValueAtTime(0, now + duration);

    carrier.connect(g);
    g.connect(this.sfxGain);

    modulator.start(now);
    carrier.start(now);
    modulator.stop(now + duration + 0.05);
    carrier.stop(now + duration + 0.05);
  }

  playChildLaugh() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;

    const notes = [800, 1000, 900, 1200, 1000, 1400, 800, 2000];
    notes.forEach((freq, i) => {
      const startTime = now + i * 0.12;
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, startTime);

      // Vibrato
      const vib = ctx.createOscillator();
      vib.frequency.setValueAtTime(7 + Math.random() * 3, startTime);
      const vibGain = ctx.createGain();
      vibGain.gain.setValueAtTime(freq * 0.03, startTime);
      vib.connect(vibGain);
      vibGain.connect(osc.frequency);

      const g = ctx.createGain();
      g.gain.setValueAtTime(0, startTime);
      g.gain.linearRampToValueAtTime(0.25, startTime + 0.02);
      g.gain.linearRampToValueAtTime(0, startTime + 0.1);

      osc.connect(g);
      g.connect(this.sfxGain);

      vib.start(startTime);
      osc.start(startTime);
      vib.stop(startTime + 0.12);
      osc.stop(startTime + 0.12);
    });
  }

  playPickupItem() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;

    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(880, now);
    osc.frequency.linearRampToValueAtTime(1100, now + 0.1);

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.5, now);
    g.gain.linearRampToValueAtTime(0, now + 0.1);

    osc.connect(g);
    g.connect(this.sfxGain);
    osc.start(now);
    osc.stop(now + 0.12);
  }

  playUIClick() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const duration = 0.02;

    const noiseBuffer = this.createNoise(duration, 'white');
    const source = ctx.createBufferSource();
    source.buffer = noiseBuffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.setValueAtTime(1000, now);

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.3, now);
    g.gain.linearRampToValueAtTime(0, now + duration);

    source.connect(filter);
    filter.connect(g);
    g.connect(this.sfxGain);
    source.start(now);
    source.stop(now + duration + 0.005);
  }

  playWindHowl() {
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const duration = 4.0;

    const noiseBuffer = this.createNoise(duration, 'brown');
    const source = ctx.createBufferSource();
    source.buffer = noiseBuffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(300, now);
    filter.frequency.linearRampToValueAtTime(800, now + 2);
    filter.frequency.linearRampToValueAtTime(200, now + duration);
    filter.Q.setValueAtTime(0.8, now);

    // Amplitude LFO
    const lfo = ctx.createOscillator();
    lfo.frequency.setValueAtTime(0.3, now);
    const lfoGain = ctx.createGain();
    lfoGain.gain.setValueAtTime(0.15, now);
    lfo.connect(lfoGain);

    const baseGain = ctx.createGain();
    baseGain.gain.setValueAtTime(0, now);
    baseGain.gain.linearRampToValueAtTime(0.4, now + 0.5);
    baseGain.gain.setValueAtTime(0.4, now + duration - 0.5);
    baseGain.gain.linearRampToValueAtTime(0, now + duration);
    lfoGain.connect(baseGain.gain);

    source.connect(filter);
    filter.connect(baseGain);
    baseGain.connect(this.ambientGain);

    lfo.start(now);
    source.start(now);
    source.stop(now + duration + 0.01);
    lfo.stop(now + duration + 0.01);
  }

  setSanityLevel(level) {
    this.sanityLevel = Math.max(0, Math.min(100, level));
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const normalizedInsanity = 1 - (this.sanityLevel / 100);

    // Increase ambient volume as sanity drops
    const ambientVolume = 0.3 + normalizedInsanity * 0.5;
    this.ambientGain.gain.setValueAtTime(this.ambientGain.gain.value, now);
    this.ambientGain.gain.linearRampToValueAtTime(ambientVolume, now + 1.0);

    // At low sanity, randomly play whispers
    if (this.sanityLevel < 30 && Math.random() < 0.3) {
      setTimeout(() => this.playWhisper(), Math.random() * 5000);
    }

    if (this.sanityLevel < 10 && Math.random() < 0.2) {
      setTimeout(() => this.playChildLaugh(), Math.random() * 8000);
    }
  }

  setMasterVolume(value) {
    const v = Math.max(0, Math.min(1, value));
    const now = this.audioContext.currentTime;
    this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, now);
    this.masterGain.gain.linearRampToValueAtTime(v, now + 0.05);
  }

  setMusicVolume(value) {
    const v = Math.max(0, Math.min(1, value));
    const now = this.audioContext.currentTime;
    this.musicGain.gain.setValueAtTime(this.musicGain.gain.value, now);
    this.musicGain.gain.linearRampToValueAtTime(v, now + 0.05);
  }

  setSFXVolume(value) {
    const v = Math.max(0, Math.min(1, value));
    const now = this.audioContext.currentTime;
    this.sfxGain.gain.setValueAtTime(this.sfxGain.gain.value, now);
    this.sfxGain.gain.linearRampToValueAtTime(v, now + 0.05);
  }

  createNoise(duration, type = 'white') {
    const ctx = this.audioContext;
    const sampleRate = ctx.sampleRate;
    const frameCount = Math.ceil(sampleRate * duration);
    const buffer = ctx.createBuffer(1, frameCount, sampleRate);
    const data = buffer.getChannelData(0);

    if (type === 'white') {
      for (let i = 0; i < frameCount; i++) {
        data[i] = Math.random() * 2 - 1;
      }
    } else if (type === 'brown') {
      let lastOut = 0;
      for (let i = 0; i < frameCount; i++) {
        const white = Math.random() * 2 - 1;
        lastOut = (lastOut + 0.02 * white) / 1.02;
        data[i] = lastOut * 3.5;
      }
    } else if (type === 'pink') {
      let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
      for (let i = 0; i < frameCount; i++) {
        const white = Math.random() * 2 - 1;
        b0 = 0.99886 * b0 + white * 0.0555179;
        b1 = 0.99332 * b1 + white * 0.0750759;
        b2 = 0.96900 * b2 + white * 0.1538520;
        b3 = 0.86650 * b3 + white * 0.3104856;
        b4 = 0.55000 * b4 + white * 0.5329522;
        b5 = -0.7616 * b5 - white * 0.0168980;
        data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
        b6 = white * 0.115926;
      }
    }

    return buffer;
  }

  createDistortion(amount = 50) {
    const samples = 256;
    const curve = new Float32Array(samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < samples; i++) {
      const x = (i * 2) / samples - 1;
      curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
    }
    return curve;
  }
}

// ========== GAME RENDERER (THREE.JS) ==========
class GameRenderer {
  constructor(container) {
    this.container = container;
    this.width = container.clientWidth || window.innerWidth;
    this.height = container.clientHeight || window.innerHeight;

    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    this.renderer.setSize(this.width, this.height);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 0.3;
    container.appendChild(this.renderer.domElement);

    this.scene = new THREE.Scene();
    this.scene.fog = new THREE.FogExp2('#000000', 0.04);
    this.scene.background = new THREE.Color(0x000000);

    this.camera = new THREE.PerspectiveCamera(70, this.width / this.height, 0.1, 100);
    this.camera.position.set(0, 1.7, 0);

    this.colliders = [];
    this.interactables = [];
    this.spawnPoints = [];
    this.candleLights = [];
    this.dustParticles = null;
    this.fogParticles = null;
    this.dustPositions = null;
    this.dustVelocities = null;
    this.fogPositions = null;
    this.fogVelocities = null;
    this.shakeIntensity = 0;
    this.shakeDuration = 0;
    this.shakeElapsed = 0;
    this.originalCameraPosition = new THREE.Vector3();
    this.flashlightOn = true;
    this.time = 0;

    this.renderTargetA = new THREE.WebGLRenderTarget(this.width, this.height, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat
    });
    this.renderTargetB = new THREE.WebGLRenderTarget(this.width, this.height, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat
    });

    this.textures = {};
    this._createTextures();
    this.setupLighting();
    this.createOrphanageLevel();
    this.createDustParticles();
    this.createFogParticles();
    this.setupPostProcessing();

    window.addEventListener('resize', () => this.onResize());
  }

  _createTextures() {
    this.textures.wall = this.createProceduralTexture('wall');
    this.textures.floor = this.createProceduralTexture('floor');
    this.textures.ceiling = this.createProceduralTexture('ceiling');
  }

  createProceduralTexture(type) {
    const size = 256;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    if (type === 'wall') {
      ctx.fillStyle = '#2a2018';
      ctx.fillRect(0, 0, size, size);
      for (let i = 0; i < 800; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const r = Math.random() * 8 + 1;
        const alpha = Math.random() * 0.15;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${Math.floor(Math.random()*40)},${Math.floor(Math.random()*30)},${Math.floor(Math.random()*20)},${alpha})`;
        ctx.fill();
      }
      for (let i = 0; i < 30; i++) {
        ctx.beginPath();
        ctx.moveTo(Math.random() * size, Math.random() * size);
        ctx.lineTo(Math.random() * size, Math.random() * size);
        ctx.strokeStyle = `rgba(0,0,0,${Math.random() * 0.3})`;
        ctx.lineWidth = Math.random() * 2;
        ctx.stroke();
      }
      for (let i = 0; i < 200; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        ctx.fillStyle = `rgba(60,40,20,${Math.random() * 0.2})`;
        ctx.fillRect(x, y, Math.random() * 4 + 1, Math.random() * 20 + 2);
      }
    } else if (type === 'floor') {
      ctx.fillStyle = '#1a1008';
      ctx.fillRect(0, 0, size, size);
      const plankWidth = 32;
      for (let px = 0; px < size; px += plankWidth) {
        const offset = (Math.floor(px / plankWidth) % 2) * 64;
        for (let py = 0; py < size; py += 16) {
          const shade = Math.floor(Math.random() * 15);
          ctx.fillStyle = `rgb(${26+shade},${16+shade},${8+shade})`;
          ctx.fillRect(px, py, plankWidth - 1, 15);
          ctx.strokeStyle = 'rgba(0,0,0,0.5)';
          ctx.strokeRect(px, py, plankWidth - 1, 15);
        }
      }
      for (let i = 0; i < 100; i++) {
        ctx.beginPath();
        ctx.moveTo(Math.random() * size, Math.random() * size);
        ctx.lineTo(Math.random() * size, Math.random() * size);
        ctx.strokeStyle = `rgba(0,0,0,${Math.random() * 0.2})`;
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
    } else if (type === 'ceiling') {
      ctx.fillStyle = '#1e1a14';
      ctx.fillRect(0, 0, size, size);
      for (let i = 0; i < 400; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const w = Math.random() * 20 + 2;
        const h = Math.random() * 10 + 1;
        ctx.fillStyle = `rgba(${Math.floor(Math.random()*20)},${Math.floor(Math.random()*15)},${Math.floor(Math.random()*10)},${Math.random()*0.4})`;
        ctx.fillRect(x, y, w, h);
      }
      for (let i = 0; i < 50; i++) {
        ctx.beginPath();
        ctx.arc(Math.random()*size, Math.random()*size, Math.random()*15+2, 0, Math.PI*2);
        ctx.fillStyle = `rgba(10,8,5,${Math.random()*0.3})`;
        ctx.fill();
      }
    }

    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(4, 4);
    return tex;
  }

  setupLighting() {
    const ambient = new THREE.HemisphereLight(0x0a0a2a, 0x000000, 0.08);
    this.scene.add(ambient);

    this.flashlight = new THREE.SpotLight(0xffe4b5, 2, 20, 0.5, 0.8, 2);
    this.flashlight.castShadow = true;
    this.flashlight.shadow.mapSize.width = 1024;
    this.flashlight.shadow.mapSize.height = 1024;
    this.flashlight.shadow.camera.near = 0.1;
    this.flashlight.shadow.camera.far = 20;
    this.camera.add(this.flashlight);
    this.flashlight.position.set(0, 0, -0.1);
    const flashlightTarget = new THREE.Object3D();
    flashlightTarget.position.set(0, 0, -1);
    this.camera.add(flashlightTarget);
    this.flashlight.target = flashlightTarget;
    this.scene.add(this.camera);

    const moon = new THREE.DirectionalLight(0x2244aa, 0.1);
    moon.position.set(10, 20, 5);
    moon.castShadow = false;
    this.scene.add(moon);

    const candlePositions = [
      new THREE.Vector3(-8, 1.0, -2),
      new THREE.Vector3(8, 1.0, -2),
      new THREE.Vector3(-14, 1.0, 0),
      new THREE.Vector3(14, 1.0, 0),
      new THREE.Vector3(0, 1.0, 12),
      new THREE.Vector3(-5, 1.0, 20),
    ];

    this.candleLights = [];
    candlePositions.forEach(pos => {
      const candle = new THREE.PointLight(0xff8833, 0.6, 4, 2);
      candle.position.copy(pos);
      candle.castShadow = false;
      candle.userData.baseIntensity = 0.6;
      candle.userData.flickerSpeed = Math.random() * 5 + 3;
      candle.userData.flickerOffset = Math.random() * Math.PI * 2;
      this.scene.add(candle);
      this.candleLights.push(candle);
    });
  }

  createOrphanageLevel() {
    const wallMat = new THREE.MeshStandardMaterial({
      color: 0x2a2018,
      roughness: 0.9,
      metalness: 0.0,
      map: this.textures.wall
    });
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x1a1008,
      roughness: 0.85,
      metalness: 0.0,
      map: this.textures.floor
    });
    const ceilMat = new THREE.MeshStandardMaterial({
      color: 0x1e1a14,
      roughness: 0.95,
      map: this.textures.ceiling
    });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x0a0806, roughness: 1.0 });
    const metalMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.7, metalness: 0.8 });

    // MAIN CORRIDOR
    this._buildRoom(0, 0, 0, 30, 3, 4, wallMat, floorMat, ceilMat, 'corridor');

    // RECEPTION HALL
    this._buildRoom(0, 0, -10, 8, 3, 8, wallMat, floorMat, ceilMat, 'reception');
    this._addDesk(2, 0, -10, wallMat, floorMat);
    this._addScatteredPapers(0, 0.01, -10);

    // 6 ROOMS - 3 on each side of corridor
    const roomOffsets = [-8, 0, 8];
    roomOffsets.forEach((z, i) => {
      this._buildRoom(-17.5, 0, z, 5, 3, 5, wallMat, floorMat, ceilMat, `room_left_${i}`);
      this._addBedFrame(-17.5, 0, z, wallMat);
      this._addDesk(-17.5, 0, z + 1.5, wallMat, floorMat);
      this._addDoor(-15, 0, z, 'left');

      this._buildRoom(17.5, 0, z, 5, 3, 5, wallMat, floorMat, ceilMat, `room_right_${i}`);
      this._addBedFrame(17.5, 0, z, wallMat);
      this._addDesk(17.5, 0, z - 1.5, wallMat, floorMat);
      this._addDoor(15, 0, z, 'right');
    });

    // CHAPEL at end
    this._buildRoom(0, 0, 18, 8, 4, 10, wallMat, floorMat, ceilMat, 'chapel');
    this._addAltar(0, 0, 22, wallMat);
    this._addPews(0, 0, 18);
    this._addStainedGlass(0, 2, 22.9);

    // STAIRCASE
    this._buildStaircase(10, 0, 2);

    // BASEMENT
    this._buildRoom(0, -3.5, 5, 20, 3, 12, darkMat, darkMat, darkMat, 'basement');
    this._addBasementProps(0, -3.5, 5);

    // SPAWN POINTS
    this.spawnPoints = [
      new THREE.Vector3(0, 1.7, -6),
      new THREE.Vector3(-8, 1.7, 0),
      new THREE.Vector3(8, 1.7, 0),
      new THREE.Vector3(0, 1.7, 15)
    ];
  }

  _buildRoom(cx, cy, cz, w, h, d, wallMat, floorMat, ceilMat, name) {
    const hw = w / 2, hh = h / 2, hd = d / 2;
    const thickness = 0.2;

    // Floor
    const floor = new THREE.Mesh(new THREE.BoxGeometry(w, thickness, d), floorMat);
    floor.position.set(cx, cy - hh + thickness / 2, cz);
    floor.receiveShadow = true;
    floor.userData.name = `${name}_floor`;
    this.scene.add(floor);
    this.colliders.push(floor);

    // Ceiling
    const ceil = new THREE.Mesh(new THREE.BoxGeometry(w, thickness, d), ceilMat);
    ceil.position.set(cx, cy + hh - thickness / 2, cz);
    ceil.receiveShadow = true;
    this.scene.add(ceil);

    // Walls
    const wallData = [
      { pos: [cx - hw + thickness / 2, cy, cz], size: [thickness, h, d] },
      { pos: [cx + hw - thickness / 2, cy, cz], size: [thickness, h, d] },
      { pos: [cx, cy, cz - hd + thickness / 2], size: [w, h, thickness] },
      { pos: [cx, cy, cz + hd - thickness / 2], size: [w, h, thickness] }
    ];
    wallData.forEach((wd, i) => {
      const wall = new THREE.Mesh(new THREE.BoxGeometry(...wd.size), wallMat);
      wall.position.set(...wd.pos);
      wall.receiveShadow = true;
      wall.castShadow = true;
      wall.userData.name = `${name}_wall_${i}`;
      this.scene.add(wall);
      this.colliders.push(wall);
    });
  }

  _addBedFrame(cx, cy, cz, mat) {
    const group = new THREE.Group();
    const frameMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9 });
    const mattressMat = new THREE.MeshStandardMaterial({ color: 0x1a1210, roughness: 1.0 });

    const base = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.15, 2.0), frameMat);
    base.position.set(0, 0.2, 0);
    group.add(base);

    const mattress = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 1.9), mattressMat);
    mattress.position.set(0, 0.33, 0);
    group.add(mattress);

    const headboard = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.5, 0.08), frameMat);
    headboard.position.set(0, 0.45, -0.96);
    group.add(headboard);

    [[0.45, 0.1, -0.9], [-0.45, 0.1, -0.9], [0.45, 0.1, 0.9], [-0.45, 0.1, 0.9]].forEach(p => {
      const leg = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.2, 0.06), frameMat);
      leg.position.set(...p);
      group.add(leg);
    });

    group.position.set(cx, cy + 0.0, cz);
    group.castShadow = true;
    group.receiveShadow = true;
    this.scene.add(group);
    this.colliders.push(base);
  }

  _addDesk(cx, cy, cz, wallMat, floorMat) {
    const group = new THREE.Group();
    const woodMat = new THREE.MeshStandardMaterial({ color: 0x1e1208, roughness: 0.9 });

    const top = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.06, 0.6), woodMat);
    top.position.set(0, 0.75, 0);
    group.add(top);

    [[0.55, 0.375, 0.25], [-0.55, 0.375, 0.25], [0.55, 0.375, -0.25], [-0.55, 0.375, -0.25]].forEach(p => {
      const leg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.75, 0.05), woodMat);
      leg.position.set(...p);
      group.add(leg);
    });

    const chair = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.05, 0.5), woodMat);
    chair.position.set(0, 0.45, 0.7);
    group.add(chair);

    const chairBack = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.04), woodMat);
    chairBack.position.set(0, 0.65, 0.95);
    group.add(chairBack);

    group.position.set(cx, cy, cz);
    group.castShadow = true;
    this.scene.add(group);

    const item = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.02, 0.2), new THREE.MeshStandardMaterial({ color: 0xccccaa }));
    item.position.set(cx, cy + 0.79, cz);
    item.userData.interactable = true;
    item.userData.type = 'note';
    item.userData.name = 'Torn Note';
    this.scene.add(item);
    this.interactables.push(item);
  }

  _addDoor(cx, cy, cz, side) {
    const doorMat = new THREE.MeshStandardMaterial({ color: 0x1a0f05, roughness: 0.9, side: THREE.DoubleSide });
    const door = new THREE.Mesh(new THREE.BoxGeometry(0.05, 2.2, 1.0), doorMat);
    door.position.set(cx, cy + 1.1, cz);
    door.castShadow = true;
    door.receiveShadow = true;
    door.userData.interactable = true;
    door.userData.type = 'door';
    door.userData.name = 'Door';
    door.userData.isOpen = false;
    door.userData.side = side;
    this.scene.add(door);
    this.interactables.push(door);
    this.colliders.push(door);
  }

  _addScatteredPapers(cx, cy, cz) {
    const paperMat = new THREE.MeshStandardMaterial({ color: 0xccccaa, roughness: 1.0 });
    for (let i = 0; i < 8; i++) {
      const paper = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.005, 0.28), paperMat);
      paper.position.set(
        cx + (Math.random() - 0.5) * 6,
        cy + 0.005,
        cz + (Math.random() - 0.5) * 6
      );
      paper.rotation.y = Math.random() * Math.PI;
      paper.userData.interactable = true;
      paper.userData.type = 'paper';
      paper.userData.name = 'Scattered Paper';
      this.scene.add(paper);
      this.interactables.push(paper);
    }
  }

  _addAltar(cx, cy, cz, mat) {
    const altarMat = new THREE.MeshStandardMaterial({ color: 0x1a1006, roughness: 0.95 });
    const altar = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 0.8), altarMat);
    altar.position.set(cx, cy + 0.5, cz);
    altar.castShadow = true;
    altar.receiveShadow = true;
    this.scene.add(altar);
    this.colliders.push(altar);

    const cross = new THREE.Group();
    const crossMat = new THREE.MeshStandardMaterial({ color: 0x0a0806, roughness: 0.9 });
    const vert = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.8, 0.05), crossMat);
    const horiz = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.08, 0.05), crossMat);
    horiz.position.y = 0.2;
    cross.add(vert);
    cross.add(horiz);
    cross.position.set(cx, cy + 1.4, cz);
    this.scene.add(cross);

    const item = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.05), new THREE.MeshStandardMaterial({ color: 0x443322 }));
    item.position.set(cx + 0.5, cy + 1.05, cz);
    item.userData.interactable = true;
    item.userData.type = 'book';
    item.userData.name = 'Old Bible';
    this.scene.add(item);
    this.interactables.push(item);
  }

  _addPews(cx, cy, cz) {
    const pewMat = new THREE.MeshStandardMaterial({ color: 0x150d05, roughness: 0.9 });
    const rows = [-2, 0, 2];
    rows.forEach(z => {
      [-2, 2].forEach(x => {
        const seat = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.05, 1.5), pewMat);
        seat.position.set(cx + x, cy + 0.45, cz + z);
        seat.castShadow = true;
        seat.receiveShadow = true;
        this.scene.add(seat);

        const back = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.35, 0.05), pewMat);
        back.position.set(cx + x, cy + 0.625, cz + z + 0.73);
        back.castShadow = true;
        this.scene.add(back);

        const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.45, 1.5), pewMat);
        leftLeg.position.set(cx + x - 0.225, cy + 0.225, cz + z);
        this.scene.add(leftLeg);

        const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.45, 1.5), pewMat);
        rightLeg.position.set(cx + x + 0.225, cy + 0.225, cz + z);
        this.scene.add(rightLeg);
      });
    });
  }

  _addStainedGlass(cx, cy, cz) {
    const colors = [0x880022, 0x004488, 0x224400, 0x664400];
    const segments = 4;
    for (let i = 0; i < segments; i++) {
      const glassMat = new THREE.MeshStandardMaterial({
        color: colors[i],
        transparent: true,
        opacity: 0.7,
        emissive: colors[i],
        emissiveIntensity: 0.05,
        side: THREE.DoubleSide
      });
      const glass = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 1.5), glassMat);
      glass.position.set(cx + (i - 1.5) * 0.9, cy, cz);
      glass.rotation.y = 0;
      this.scene.add(glass);
    }
  }

  _buildStaircase(cx, cy, cz) {
    const stairMat = new THREE.MeshStandardMaterial({ color: 0x1a1008, roughness: 0.9 });
    const steps = 12;
    for (let i = 0; i < steps; i++) {
      const step = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 0.4), stairMat);
      step.position.set(cx, cy - 1.4 + i * 0.25, cz + i * 0.35);
      step.castShadow = true;
      step.receiveShadow = true;
      this.scene.add(step);
      this.colliders.push(step);
    }
  }

  _addBasementProps(cx, cy, cz) {
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x080604, roughness: 1.0 });
    const positions = [[-5, cy + 1.5, cz - 3], [5, cy + 1.5, cz + 3], [0, cy + 1.5, cz]];
    positions.forEach((pos, i) => {
      const crate = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), darkMat);
      crate.position.set(...pos);
      crate.castShadow = true;
      crate.receiveShadow = true;
      crate.userData.interactable = i === 1;
      if (i === 1) {
        crate.userData.type = 'crate';
        crate.userData.name = 'Locked Crate';
        this.interactables.push(crate);
      }
      this.scene.add(crate);
      this.colliders.push(crate);
    });

    const candleLight = new THREE.PointLight(0xff4400, 0.4, 5, 2);
    candleLight.position.set(cx, cy + 2.5, cz);
    candleLight.userData.baseIntensity = 0.4;
    candleLight.userData.flickerSpeed = 8;
    candleLight.userData.flickerOffset = Math.PI;
    this.scene.add(candleLight);
    this.candleLights.push(candleLight);
  }

  createDustParticles() {
    const count = 200;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const velocities = [];

    for (let i = 0; i < count; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 30;
      positions[i * 3 + 1] = Math.random() * 3;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 30;
      velocities.push(
        (Math.random() - 0.5) * 0.005,
        (Math.random() - 0.5) * 0.002,
        (Math.random() - 0.5) * 0.005
      );
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    this.dustPositions = positions;
    this.dustVelocities = velocities;

    const material = new THREE.PointsMaterial({
      color: 0xaaaaaa,
      size: 0.03,
      transparent: true,
      opacity: 0.4,
      depthWrite: false,
      sizeAttenuation: true
    });

    this.dustParticles = new THREE.Points(geometry, material);
    this.scene.add(this.dustParticles);
  }

  createFogParticles() {
    const count = 100;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const velocities = [];

    for (let i = 0; i < count; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 40;
      positions[i * 3 + 1] = Math.random() * 0.5;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
      velocities.push(
        (Math.random() - 0.5) * 0.003,
        0,
        (Math.random() - 0.5) * 0.003
      );
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    this.fogPositions = positions;
    this.fogVelocities = velocities;

    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(200,200,220,0.4)');
    gradient.addColorStop(1, 'rgba(200,200,220,0.0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    const spriteTex = new THREE.CanvasTexture(canvas);

    const material = new THREE.PointsMaterial({
      color: 0xddddee,
      size: 2.5,
      transparent: true,
      opacity: 0.08,
      map: spriteTex,
      depthWrite: false,
      sizeAttenuation: true,
      blending: THREE.AdditiveBlending
    });

    this.fogParticles = new THREE.Points(geometry, material);
    this.scene.add(this.fogParticles);
  }

  setupPostProcessing() {
    this.postQuad = new THREE.Mesh(
      new THREE.PlaneGeometry(2, 2),
      new THREE.ShaderMaterial({
        uniforms: {
          tDiffuse: { value: null },
          uTime: { value: 0.0 },
          uVignetteStrength: { value: 1.0 },
          uGrainStrength: { value: 0.08 },
          uAberrationStrength: { value: 0.003 },
          uScanlineStrength: { value: 0.04 },
          uSaturation: { value: 0.3 },
          uBlueTint: { value: 0.12 },
          uResolution: { value: new THREE.Vector2(this.width, this.height) }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float uTime;
          uniform float uVignetteStrength;
          uniform float uGrainStrength;
          uniform float uAberrationStrength;
          uniform float uScanlineStrength;
          uniform float uSaturation;
          uniform float uBlueTint;
          uniform vec2 uResolution;
          varying vec2 vUv;

          float rand(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
          }

          void main() {
            vec2 uv = vUv;
            vec2 center = uv - 0.5;

            // Chromatic aberration
            float abr = uAberrationStrength;
            float r = texture2D(tDiffuse, uv + vec2(abr, 0.0)).r;
            float g = texture2D(tDiffuse, uv).g;
            float b = texture2D(tDiffuse, uv - vec2(abr, 0.0)).b;
            vec4 color = vec4(r, g, b, 1.0);

            // Desaturation
            float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114));
            color.rgb = mix(vec3(luma), color.rgb, uSaturation);

            // Blue tint
            color.r -= uBlueTint * 0.3;
            color.g -= uBlueTint * 0.1;
            color.b += uBlueTint;
            color.rgb = clamp(color.rgb, 0.0, 1.0);

            // Vignette
            float dist = length(center) * 1.5;
            float vignette = 1.0 - dist * dist * uVignetteStrength;
            color.rgb *= clamp(vignette, 0.0, 1.0);

            // Scanlines
            float scanline = sin(uv.y * uResolution.y * 1.5) * 0.5 + 0.5;
            color.rgb -= uScanlineStrength * (1.0 - scanline);

            // Film grain
            float grain = rand(uv + fract(uTime * 0.1)) - 0.5;
            color.rgb += grain * uGrainStrength;

            color.rgb = clamp(color.rgb, 0.0, 1.0);
            gl_FragColor = color;
          }
        `,
        depthTest: false,
        depthWrite: false
      })
    );

    this.postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    this.postScene = new THREE.Scene();
    this.postScene.add(this.postQuad);
  }

  render(delta, sanity) {
    this.time += delta;

    // Candle flicker
    const t = this.time;
    this.candleLights.forEach(light => {
      const base = light.userData.baseIntensity;
      const speed = light.userData.flickerSpeed;
      const offset = light.userData.flickerOffset;
      const flicker = Math.sin(t * speed + offset) * 0.15 +
                      Math.sin(t * speed * 1.7 + offset) * 0.1 +
                      Math.sin(t * speed * 3.1 + offset) * 0.05;
      light.intensity = Math.max(0.0, base + flicker * (Math.random() * 0.3 + 0.7));
    });

    // Dust particles
    if (this.dustParticles && this.dustPositions) {
      const pos = this.dustPositions;
      const vel = this.dustVelocities;
      for (let i = 0; i < pos.length / 3; i++) {
        pos[i * 3] += vel[i * 3];
        pos[i * 3 + 1] += vel[i * 3 + 1];
        pos[i * 3 + 2] += vel[i * 3 + 2];
        if (pos[i * 3] > 15) pos[i * 3] = -15;
        if (pos[i * 3] < -15) pos[i * 3] = 15;
        if (pos[i * 3 + 1] > 3) pos[i * 3 + 1] = 0;
        if (pos[i * 3 + 1] < 0) pos[i * 3 + 1] = 3;
        if (pos[i * 3 + 2] > 15) pos[i * 3 + 2] = -15;
        if (pos[i * 3 + 2] < -15) pos[i * 3 + 2] = 15;
      }
      this.dustParticles.geometry.attributes.position.needsUpdate = true;
    }

    // Fog particles
    if (this.fogParticles && this.fogPositions) {
      const pos = this.fogPositions;
      const vel = this.fogVelocities;
      for (let i = 0; i < pos.length / 3; i++) {
        pos[i * 3] += vel[i * 3];
        pos[i * 3 + 2] += vel[i * 3 + 2];
        if (pos[i * 3] > 20) pos[i * 3] = -20;
        if (pos[i * 3] < -20) pos[i * 3] = 20;
        if (pos[i * 3 + 2] > 20) pos[i * 3 + 2] = -20;
        if (pos[i * 3 + 2] < -20) pos[i * 3 + 2] = 20;
      }
      this.fogParticles.geometry.attributes.position.needsUpdate = true;
    }

    // Camera shake
    if (this.shakeElapsed < this.shakeDuration) {
      this.shakeElapsed += delta;
      const progress = 1 - (this.shakeElapsed / this.shakeDuration);
      const si = this.shakeIntensity * progress;
      this.camera.position.x = this.originalCameraPosition.x + (Math.random() - 0.5) * si;
      this.camera.position.y = this.originalCameraPosition.y + (Math.random() - 0.5) * si;
    }

    // Sanity-based post-processing
    const sanityNorm = Math.max(0, Math.min(1, (sanity !== undefined ? sanity : 100) / 100));
    const insanity = 1.0 - sanityNorm;
    const mat = this.postQuad.material;
    mat.uniforms.uTime.value = this.time;
    mat.uniforms.uVignetteStrength.value = 1.0 + insanity * 2.0;
    mat.uniforms.uGrainStrength.value = 0.05 + insanity * 0.2;
    mat.uniforms.uAberrationStrength.value = 0.002 + insanity * 0.015;
    mat.uniforms.uScanlineStrength.value = 0.02 + insanity * 0.08;
    mat.uniforms.uSaturation.value = Math.max(0.0, 0.3 - insanity * 0.25);
    mat.uniforms.uBlueTint.value = 0.1 + insanity * 0.15;

    // Render scene to target
    this.renderer.setRenderTarget(this.renderTargetA);
    this.renderer.clear();
    this.renderer.render(this.scene, this.camera);

    // Apply post-processing
    mat.uniforms.tDiffuse.value = this.renderTargetA.texture;
    this.renderer.setRenderTarget(null);
    this.renderer.clear();
    this.renderer.render(this.postScene, this.postCamera);
  }

  onResize() {
    this.width = this.container.clientWidth || window.innerWidth;
    this.height = this.container.clientHeight || window.innerHeight;
    this.camera.aspect = this.width / this.height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(this.width, this.height);
    this.renderTargetA.setSize(this.width, this.height);
    this.renderTargetB.setSize(this.width, this.height);
    if (this.postQuad && this.postQuad.material.uniforms.uResolution) {
      this.postQuad.material.uniforms.uResolution.value.set(this.width, this.height);
    }
  }

  toggleFlashlight(on) {
    this.flashlightOn = on !== undefined ? on : !this.flashlightOn;
    this.flashlight.intensity = this.flashlightOn ? 2 : 0;
    this.flashlight.visible = this.flashlightOn;
  }

  screenShake(intensity, duration) {
    this.shakeIntensity = intensity || 0.1;
    this.shakeDuration = duration || 0.5;
    this.shakeElapsed = 0;
    this.originalCameraPosition.copy(this.camera.position);
  }

  getLevelColliders() {
    return this.colliders;
  }

  getInteractables() {
    return this.interactables;
  }

  getSpawnPoints() {
    return this.spawnPoints;
  }
}

// ========== PLAYER CONTROLLER & GAME STATE ==========
class PlayerController {
  constructor(camera, colliders) {
    this.camera = camera;
    this.colliders = colliders || [];
    this.velocity = new THREE.Vector3();
    this.moveSpeed = 4;
    this.sprintSpeed = 7;
    this.crouchSpeed = 2;
    this.keys = {
      forward: false, back: false, left: false, right: false,
      sprint: false, crouch: false, interact: false,
      flashlight: false, chat: false,
      slot1: false, slot2: false, slot3: false, slot4: false
    };
    this.sensitivity = 0.002;
    this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
    this.pitch = 0;
    this.yaw = 0;
    this.isPointerLocked = false;
    this.collisionRadius = 0.4;
    this.standingHeight = 1.6;
    this.crouchHeight = 0.8;
    this.currentHeight = 1.6;
    this.targetHeight = 1.6;
    this.headBobAmplitude = 0.05;
    this.headBobTime = 0;
    this.headBobBase = 0;
    this.shakeOffset = new THREE.Vector3();
    this.shakeIntensity = 0;
    this.shakeDuration = 0;
    this.shakeTimer = 0;
    this.mobileForward = 0;
    this.mobileStrafe = 0;
    this.joystickActive = false;
    this.joystickCenter = { x: 0, y: 0 };
    this.joystickTouchId = null;
    this.cameraTouchId = null;
    this.lastCameraTouch = { x: 0, y: 0 };
    this.raycaster = new THREE.Raycaster();
    this.interactRaycaster = new THREE.Raycaster();
    this.setupKeyboard();
    this.setupMouse();
    this.setupMobileControls();
  }

  setupKeyboard() {
    this._onKeyDown = (e) => {
      switch (e.code) {
        case 'KeyW': case 'ArrowUp': this.keys.forward = true; break;
        case 'KeyS': case 'ArrowDown': this.keys.back = true; break;
        case 'KeyA': case 'ArrowLeft': this.keys.left = true; break;
        case 'KeyD': case 'ArrowRight': this.keys.right = true; break;
        case 'ShiftLeft': case 'ShiftRight': this.keys.sprint = true; break;
        case 'KeyC': case 'ControlLeft': case 'ControlRight': this.keys.crouch = true; break;
        case 'KeyE': this.keys.interact = true; break;
        case 'Tab': e.preventDefault(); break;
        case 'Escape': this.keys.interact = false; break;
        case 'KeyT': this.keys.chat = true; break;
        case 'KeyF': this.keys.flashlight = true; break;
        case 'Digit1': this.keys.slot1 = true; break;
        case 'Digit2': this.keys.slot2 = true; break;
        case 'Digit3': this.keys.slot3 = true; break;
        case 'Digit4': this.keys.slot4 = true; break;
      }
    };
    this._onKeyUp = (e) => {
      switch (e.code) {
        case 'KeyW': case 'ArrowUp': this.keys.forward = false; break;
        case 'KeyS': case 'ArrowDown': this.keys.back = false; break;
        case 'KeyA': case 'ArrowLeft': this.keys.left = false; break;
        case 'KeyD': case 'ArrowRight': this.keys.right = false; break;
        case 'ShiftLeft': case 'ShiftRight': this.keys.sprint = false; break;
        case 'KeyC': case 'ControlLeft': case 'ControlRight': this.keys.crouch = false; break;
        case 'KeyE': this.keys.interact = false; break;
        case 'KeyT': this.keys.chat = false; break;
        case 'KeyF': this.keys.flashlight = false; break;
        case 'Digit1': this.keys.slot1 = false; break;
        case 'Digit2': this.keys.slot2 = false; break;
        case 'Digit3': this.keys.slot3 = false; break;
        case 'Digit4': this.keys.slot4 = false; break;
      }
    };
    document.addEventListener('keydown', this._onKeyDown);
    document.addEventListener('keyup', this._onKeyUp);
  }

  setupMouse() {
    this._onPointerLockChange = () => {
      this.isPointerLocked = document.pointerLockElement === document.body ||
        document.pointerLockElement === document.documentElement ||
        !!document.pointerLockElement;
    };
    this._onMouseMove = (e) => {
      if (!this.isPointerLocked) return;
      const dx = e.movementX * this.sensitivity;
      const dy = e.movementY * this.sensitivity;
      this.yaw -= dx;
      this.pitch -= dy;
      this.pitch = Math.max(-Math.PI * 80 / 180, Math.min(Math.PI * 80 / 180, this.pitch));
    };
    document.addEventListener('pointerlockchange', this._onPointerLockChange);
    document.addEventListener('mousemove', this._onMouseMove);
  }

  setupMobileControls() {
    const joystickZone = document.getElementById('joystick-zone');
    const cameraZone = document.getElementById('camera-zone');

    if (joystickZone) {
      joystickZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        this.joystickTouchId = touch.identifier;
        const rect = joystickZone.getBoundingClientRect();
        this.joystickCenter.x = rect.left + rect.width / 2;
        this.joystickCenter.y = rect.top + rect.height / 2;
        this.joystickActive = true;
      }, { passive: false });

      joystickZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.identifier === this.joystickTouchId) {
            const dx = touch.clientX - this.joystickCenter.x;
            const dy = touch.clientY - this.joystickCenter.y;
            const maxRadius = 50;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const normX = dist > maxRadius ? dx / dist : dx / maxRadius;
            const normY = dist > maxRadius ? dy / dist : dy / maxRadius;
            this.mobileStrafe = normX;
            this.mobileForward = -normY;
          }
        }
      }, { passive: false });

      joystickZone.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === this.joystickTouchId) {
            this.joystickActive = false;
            this.joystickTouchId = null;
            this.mobileForward = 0;
            this.mobileStrafe = 0;
          }
        }
      }, { passive: false });
    }

    if (cameraZone) {
      cameraZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        this.cameraTouchId = touch.identifier;
        this.lastCameraTouch.x = touch.clientX;
        this.lastCameraTouch.y = touch.clientY;
      }, { passive: false });

      cameraZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.identifier === this.cameraTouchId) {
            const dx = touch.clientX - this.lastCameraTouch.x;
            const dy = touch.clientY - this.lastCameraTouch.y;
            this.yaw -= dx * this.sensitivity * 1.5;
            this.pitch -= dy * this.sensitivity * 1.5;
            this.pitch = Math.max(-Math.PI * 80 / 180, Math.min(Math.PI * 80 / 180, this.pitch));
            this.lastCameraTouch.x = touch.clientX;
            this.lastCameraTouch.y = touch.clientY;
          }
        }
      }, { passive: false });

      cameraZone.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === this.cameraTouchId) {
            this.cameraTouchId = null;
          }
        }
      }, { passive: false });
    }

    const mobileInteract = document.getElementById('mobile-interact');
    const mobileSprint = document.getElementById('mobile-sprint');
    const mobileCrouch = document.getElementById('mobile-crouch');
    const mobileFlashlight = document.getElementById('mobile-flashlight');

    if (mobileInteract) {
      mobileInteract.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys.interact = true; }, { passive: false });
      mobileInteract.addEventListener('touchend', (e) => { e.preventDefault(); this.keys.interact = false; }, { passive: false });
    }
    if (mobileSprint) {
      mobileSprint.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys.sprint = true; }, { passive: false });
      mobileSprint.addEventListener('touchend', (e) => { e.preventDefault(); this.keys.sprint = false; }, { passive: false });
    }
    if (mobileCrouch) {
      mobileCrouch.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys.crouch = !this.keys.crouch; }, { passive: false });
    }
    if (mobileFlashlight) {
      mobileFlashlight.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys.flashlight = true; }, { passive: false });
      mobileFlashlight.addEventListener('touchend', (e) => { e.preventDefault(); this.keys.flashlight = false; }, { passive: false });
    }
  }

  update(delta) {
    const isCrouching = this.keys.crouch;
    const isSprinting = this.keys.sprint && !isCrouching;
    this.targetHeight = isCrouching ? this.crouchHeight : this.standingHeight;
    this.currentHeight += (this.targetHeight - this.currentHeight) * Math.min(1, delta * 10);

    let speed = this.moveSpeed;
    if (isSprinting) speed = this.sprintSpeed;
    else if (isCrouching) speed = this.crouchSpeed;

    const forward = new THREE.Vector3(-Math.sin(this.yaw), 0, -Math.cos(this.yaw));
    const right = new THREE.Vector3(Math.cos(this.yaw), 0, -Math.sin(this.yaw));

    const moveDir = new THREE.Vector3();
    if (this.keys.forward || this.mobileForward > 0.1) moveDir.addScaledVector(forward, this.keys.forward ? 1 : this.mobileForward);
    if (this.keys.back || this.mobileForward < -0.1) moveDir.addScaledVector(forward, this.keys.back ? -1 : this.mobileForward);
    if (this.keys.right || this.mobileStrafe > 0.1) moveDir.addScaledVector(right, this.keys.right ? 1 : this.mobileStrafe);
    if (this.keys.left || this.mobileStrafe < -0.1) moveDir.addScaledVector(right, this.keys.left ? -1 : this.mobileStrafe);

    const isMoving = moveDir.lengthSq() > 0.001;
    if (isMoving) moveDir.normalize();

    const intendedMove = moveDir.clone().multiplyScalar(speed * delta);
    const currentPos = this.camera.position.clone();
    const groundPos = new THREE.Vector3(currentPos.x, 0, currentPos.z);

    let newPos = groundPos.clone().add(intendedMove);
    if (isMoving && this.colliders.length > 0) {
      newPos = this.checkCollision(groundPos, moveDir, intendedMove.length());
    }

    if (isMoving) {
      const bobFreq = isSprinting ? 12 : (isCrouching ? 4 : 7);
      this.headBobTime += delta * bobFreq;
      const bobOffset = Math.sin(this.headBobTime) * this.headBobAmplitude;
      this.camera.position.x = newPos.x;
      this.camera.position.z = newPos.z;
      this.camera.position.y = this.currentHeight + bobOffset;
    } else {
      this.headBobTime *= 0.9;
      this.camera.position.x += (groundPos.x - this.camera.position.x) * 0.1;
      this.camera.position.z += (groundPos.z - this.camera.position.z) * 0.1;
      this.camera.position.y = this.currentHeight;
    }

    if (this.shakeTimer > 0) {
      this.shakeTimer -= delta;
      const shakeProgress = this.shakeTimer / this.shakeDuration;
      const currentShake = this.shakeIntensity * shakeProgress;
      this.shakeOffset.set(
        (Math.random() - 0.5) * 2 * currentShake,
        (Math.random() - 0.5) * 2 * currentShake,
        (Math.random() - 0.5) * 2 * currentShake
      );
      this.camera.position.add(this.shakeOffset);
    }

    this.euler.set(this.pitch, this.yaw, 0, 'YXZ');
    this.camera.quaternion.setFromEuler(this.euler);

    return {
      position: this.camera.position.clone(),
      yaw: this.yaw,
      pitch: this.pitch,
      isCrouching,
      isSprinting,
      isMoving
    };
  }

  checkCollision(position, direction, moveLength) {
    if (!direction || direction.lengthSq() < 0.0001) return position;
    const origin = position.clone();
    origin.y = 1.0;
    this.raycaster.set(origin, direction.clone().normalize());
    this.raycaster.far = this.collisionRadius + moveLength + 0.1;
    const hits = this.raycaster.intersectObjects(this.colliders, true);
    if (hits.length > 0 && hits[0].distance < this.collisionRadius + moveLength) {
      const slideDir = direction.clone();
      const normal = hits[0].face ? hits[0].face.normal.clone() : new THREE.Vector3(0, 0, 0);
      normal.y = 0;
      if (normal.lengthSq() > 0.0001) {
        normal.normalize();
        const dot = slideDir.dot(normal);
        slideDir.addScaledVector(normal, -dot);
        slideDir.y = 0;
        if (slideDir.lengthSq() > 0.0001) {
          slideDir.normalize().multiplyScalar(moveLength * 0.8);
          const slidePos = position.clone().add(slideDir);
          this.raycaster.set(new THREE.Vector3(slidePos.x, 1.0, slidePos.z), direction.clone().normalize());
          const slideHits = this.raycaster.intersectObjects(this.colliders, true);
          if (slideHits.length === 0 || slideHits[0].distance > this.collisionRadius) {
            return slidePos;
          }
        }
      }
      return position;
    }
    return position.clone().add(direction.clone().multiplyScalar(moveLength));
  }

  getInteractionTarget(interactables) {
    if (!interactables || interactables.length === 0) return null;
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(this.camera.quaternion);
    this.interactRaycaster.set(this.camera.position, forward);
    this.interactRaycaster.far = 2.5;
    const hits = this.interactRaycaster.intersectObjects(interactables, true);
    for (let i = 0; i < hits.length; i++) {
      let obj = hits[i].object;
      while (obj) {
        if (obj.userData && obj.userData.interactive) return obj;
        obj = obj.parent;
      }
    }
    return null;
  }

  requestPointerLock() {
    const el = document.body;
    if (el.requestPointerLock) el.requestPointerLock();
  }

  shake(intensity, duration) {
    this.shakeIntensity = intensity;
    this.shakeDuration = duration;
    this.shakeTimer = duration;
  }

  dispose() {
    document.removeEventListener('keydown', this._onKeyDown);
    document.removeEventListener('keyup', this._onKeyUp);
    document.removeEventListener('pointerlockchange', this._onPointerLockChange);
    document.removeEventListener('mousemove', this._onMouseMove);
  }
}

class GameStateManager {
  constructor() {
    this.currentScreen = 'loading';
    this.validScreens = ['loading', 'menu', 'character-select', 'lobby', 'playing', 'paused', 'dead', 'gameover'];
    this.sanity = 100;
    this.flashlightBattery = 100;
    this.stamina = 100;
    this.flashlightOn = true;
    this.inventory = ['flashlight', null, null, null];
    this.activeSlot = 0;
    this.currentObjective = '';
    this.objectiveIndex = 0;
    this.chapter = 1;
    this.isMultiplayer = false;
    this.paranormalEventTimer = 0;
    this.eventInterval = 45;
    this.selectedCharacter = null;
    this.sanityEffectThresholds = {
      criticalSanity: 20,
      lowSanity: 40,
      midSanity: 60
    };
    this.onParanormalEvent = null;
    this.onSanityChanged = null;
    this.onScreenChanged = null;
    this.onObjectiveChanged = null;
    this._lastSanityThreshold = null;
  }

  setState(screen) {
    if (!this.validScreens.includes(screen)) {
      console.warn('GameStateManager: unknown screen', screen);
      return;
    }
    const previous = this.currentScreen;
    this.currentScreen = screen;

    const allScreens = document.querySelectorAll('.screen, [data-screen]');
    allScreens.forEach(el => {
      el.style.display = 'none';
      el.classList.remove('active');
    });

    const target = document.getElementById(screen + '-screen') ||
      document.getElementById(screen) ||
      document.querySelector('[data-screen="' + screen + '"]');

    if (target) {
      target.style.display = '';
      target.classList.add('active');
    }

    if (screen === 'playing') {
      const hud = document.getElementById('hud');
      if (hud) { hud.style.display = ''; hud.classList.add('active'); }
    } else {
      const hud = document.getElementById('hud');
      if (hud) { hud.style.display = 'none'; hud.classList.remove('active'); }
    }

    if (screen === 'loading') {
      this.sanity = 100;
      this.flashlightBattery = 100;
      this.stamina = 100;
      this.flashlightOn = true;
    }

    if (screen === 'dead' || screen === 'gameover') {
      if (document.exitPointerLock) document.exitPointerLock();
    }

    if (typeof this.onScreenChanged === 'function') {
      this.onScreenChanged(screen, previous);
    }
  }

  updateSanity(delta, conditions) {
    conditions = conditions || {};
    let rate = 0;

    if (conditions.inDark) rate -= 2;
    if (conditions.nearAlisa) rate -= 5;
    if (conditions.nearPlayers) rate += 0.3;
    if (conditions.inLight) rate += 0.1;
    if (conditions.usingPrayer) rate += 1;

    const prevSanity = this.sanity;
    this.sanity = Math.max(0, Math.min(100, this.sanity + rate * delta));

    const threshold = this.sanity < 20 ? 'critical' : this.sanity < 40 ? 'low' : this.sanity < 60 ? 'mid' : 'high';
    if (threshold !== this._lastSanityThreshold) {
      this._lastSanityThreshold = threshold;
      if (typeof this.onSanityChanged === 'function') {
        this.onSanityChanged(this.sanity, threshold);
      }
    }

    if (this.sanity <= 0 && prevSanity > 0) {
      if (this.currentScreen === 'playing') this.setState('dead');
    }

    this._updateSanityUI();
    return this.sanity;
  }

  _updateSanityUI() {
    const sanityBar = document.getElementById('sanity-bar');
    if (sanityBar) {
      sanityBar.style.width = this.sanity + '%';
      sanityBar.style.backgroundColor =
        this.sanity < 20 ? '#ff0000' :
        this.sanity < 40 ? '#ff6600' :
        this.sanity < 60 ? '#ffaa00' : '#00cc66';
    }
    const sanityText = document.getElementById('sanity-value');
    if (sanityText) sanityText.textContent = Math.floor(this.sanity);
  }

  updateBattery(delta) {
    if (this.flashlightOn && this.flashlightBattery > 0) {
      this.flashlightBattery = Math.max(0, this.flashlightBattery - 0.33 * delta);
      if (this.flashlightBattery <= 0) {
        this.flashlightOn = false;
        this.flashlightBattery = 0;
      }
    }
    const batteryBar = document.getElementById('battery-bar');
    if (batteryBar) batteryBar.style.width = this.flashlightBattery + '%';
    const batteryText = document.getElementById('battery-value');
    if (batteryText) batteryText.textContent = Math.floor(this.flashlightBattery);
    return this.flashlightBattery;
  }

  updateStamina(delta, sprinting) {
    if (sprinting && this.stamina > 0) {
      this.stamina = Math.max(0, this.stamina - 15 * delta);
    } else if (!sprinting && this.stamina < 100) {
      this.stamina = Math.min(100, this.stamina + 8 * delta);
    }
    const staminaBar = document.getElementById('stamina-bar');
    if (staminaBar) staminaBar.style.width = this.stamina + '%';
    return this.stamina;
  }

  getSanityEffects() {
    const s = this.sanity;
    const inverted = (100 - s) / 100;
    const invertedSq = inverted * inverted;

    let visualDistortion = 0;
    let audioDistortion = 0;
    let hallucinationChance = 0;
    let vignette = 0;
    let grain = 0;
    let chromatic = 0;

    if (s < 100) {
      vignette = Math.min(1, inverted * 1.2);
      grain = Math.min(1, inverted * 0.8);
    }
    if (s < 60) {
      visualDistortion = Math.min(1, (60 - s) / 60);
      audioDistortion = Math.min(1, (60 - s) / 60 * 0.7);
      chromatic = Math.min(1, (60 - s) / 60 * 0.6);
    }
    if (s < 40) {
      hallucinationChance = Math.min(1, (40 - s) / 40);
    }
    if (s < 20) {
      visualDistortion = Math.min(1, visualDistortion + (20 - s) / 20 * 0.5);
      audioDistortion = Math.min(1, audioDistortion + (20 - s) / 20 * 0.5);
      hallucinationChance = Math.min(1, hallucinationChance + (20 - s) / 20 * 0.5);
      chromatic = Math.min(1, chromatic + (20 - s) / 20 * 0.4);
    }

    return {
      visualDistortion,
      audioDistortion,
      hallucinationChance,
      vignette,
      grain,
      chromatic
    };
  }

  scheduleParanormalEvent(delta) {
    const sanityFactor = this.sanity / 100;
    const currentInterval = 15 + sanityFactor * 30;
    this.paranormalEventTimer += delta;

    if (this.paranormalEventTimer >= currentInterval) {
      this.paranormalEventTimer = 0;
      const event = this.getRandomParanormalEvent();
      if (typeof this.onParanormalEvent === 'function') {
        this.onParanormalEvent(event);
      }
      return event;
    }
    return null;
  }

  getRandomParanormalEvent() {
    const events = [
      'flickerLights',
      'doorSlam',
      'whispers',
      'shadowFigure',
      'temperatureDrop',
      'childLaugh',
      'footsteps'
    ];
    const weights = [
      1.0,
      0.8,
      1.2,
      0.6 + (1 - this.sanity / 100) * 0.8,
      0.7,
      0.5 + (1 - this.sanity / 100) * 0.5,
      1.0
    ];
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let rand = Math.random() * totalWeight;
    for (let i = 0; i < events.length; i++) {
      rand -= weights[i];
      if (rand <= 0) return events[i];
    }
    return events[events.length - 1];
  }

  addToInventory(item) {
    for (let i = 0; i < this.inventory.length; i++) {
      if (this.inventory[i] === null) {
        this.inventory[i] = item;
        this._updateInventoryUI();
        return i;
      }
    }
    return -1;
  }

  removeFromInventory(slot) {
    if (slot < 0 || slot >= this.inventory.length) return null;
    const item = this.inventory[slot];
    this.inventory[slot] = null;
    this._updateInventoryUI();
    return item;
  }

  setActiveSlot(slot) {
    if (slot >= 0 && slot < this.inventory.length) {
      this.activeSlot = slot;
      this._updateInventoryUI();
    }
  }

  _updateInventoryUI() {
    for (let i = 0; i < this.inventory.length; i++) {
      const slotEl = document.getElementById('slot-' + (i + 1));
      if (slotEl) {
        slotEl.textContent = this.inventory[i] || '';
        slotEl.classList.toggle('active', i === this.activeSlot);
        slotEl.classList.toggle('filled', !!this.inventory[i]);
      }
    }
  }

  getBatteryState() {
    if (this.flashlightBattery > 75) return 'full';
    if (this.flashlightBattery > 50) return 'good';
    if (this.flashlightBattery > 25) return 'low';
    if (this.flashlightBattery > 10) return 'critical';
    if (this.flashlightBattery > 0) return 'dying';
    return 'dead';
  }

  setObjective(objective, index) {
    this.currentObjective = objective;
    if (index !== undefined) this.objectiveIndex = index;
    const objectiveEl = document.getElementById('objective-text');
    if (objectiveEl) objectiveEl.textContent = objective;
    if (typeof this.onObjectiveChanged === 'function') {
      this.onObjectiveChanged(objective, this.objectiveIndex);
    }
  }

  toggleFlashlight() {
    if (this.flashlightBattery > 0) {
      this.flashlightOn = !this.flashlightOn;
    } else {
      this.flashlightOn = false;
    }
    return this.flashlightOn;
  }

  reset() {
    this.sanity = 100;
    this.flashlightBattery = 100;
    this.stamina = 100;
    this.flashlightOn = true;
    this.inventory = ['flashlight', null, null, null];
    this.activeSlot = 0;
    this.currentObjective = '';
    this.objectiveIndex = 0;
    this.paranormalEventTimer = 0;
    this.eventInterval = 45;
    this._lastSanityThreshold = null;
    this._updateSanityUI();
    this._updateInventoryUI();
  }
}

// ========== AI, INTERACTIONS & HUD ==========
class AlisaAI {
  constructor(scene) {
    this.scene = scene;
    this.group = new THREE.Group();
    this.state = 'dormant';
    this.aggressionLevel = 0;
    this.cooldownTimer = 0;
    this.isVisible = false;
    this.position = new THREE.Vector3(0, 0, 0);
    this.floatOffset = 0;
    this.floatTime = 0;
    this.stateTimer = 0;
    this.attackTimer = 0;
    this.nearPlayerTimer = 0;
    this.targetPlayerId = null;
    this.dormantTimer = 0;
    this.stalkDuration = 0;
    this.opacity = 0;
    this.fadeTarget = 0;
    this.particles = [];

    // Materials
    this.ghostMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.0,
      emissive: new THREE.Color(0x220000),
      emissiveIntensity: 0.5,
      side: THREE.DoubleSide
    });

    this.eyeMaterial = new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: new THREE.Color(0xff0000),
      emissiveIntensity: 2.0,
      transparent: true,
      opacity: 0.0
    });

    this.hairMaterial = new THREE.MeshStandardMaterial({
      color: 0x111111,
      transparent: true,
      opacity: 0.0
    });

    // Body
    const bodyGeo = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 8);
    this.body = new THREE.Mesh(bodyGeo, this.ghostMaterial.clone());
    this.body.position.y = 0;
    this.group.add(this.body);

    // Head
    const headGeo = new THREE.SphereGeometry(0.2, 8, 8);
    this.head = new THREE.Mesh(headGeo, this.ghostMaterial.clone());
    this.head.position.y = 0.75;
    this.group.add(this.head);

    // Hair strips
    this.hairMeshes = [];
    const hairPositions = [
      { x: -0.1, z: 0.15, ry: 0.1, len: 0.6 },
      { x: 0.1, z: 0.15, ry: -0.1, len: 0.7 },
      { x: -0.15, z: 0.1, ry: 0.3, len: 0.55 },
      { x: 0.15, z: 0.1, ry: -0.3, len: 0.6 },
      { x: 0, z: 0.18, ry: 0, len: 0.65 },
      { x: -0.05, z: -0.15, ry: 0.05, len: 0.5 },
      { x: 0.05, z: -0.15, ry: -0.05, len: 0.5 }
    ];
    hairPositions.forEach(hp => {
      const hGeo = new THREE.BoxGeometry(0.04, hp.len, 0.02);
      const hMat = this.hairMaterial.clone();
      const hMesh = new THREE.Mesh(hGeo, hMat);
      hMesh.position.set(hp.x, 0.75 - hp.len / 2, hp.z);
      hMesh.rotation.y = hp.ry;
      hMesh.rotation.z = (hp.x < 0 ? -1 : 1) * 0.15;
      this.group.add(hMesh);
      this.hairMeshes.push(hMesh);
    });

    // Eyes
    const eyeGeo = new THREE.SphereGeometry(0.03, 6, 6);
    this.leftEye = new THREE.Mesh(eyeGeo, this.eyeMaterial.clone());
    this.leftEye.position.set(-0.08, 0.78, 0.17);
    this.group.add(this.leftEye);

    this.rightEye = new THREE.Mesh(eyeGeo, this.eyeMaterial.clone());
    this.rightEye.position.set(0.08, 0.78, 0.17);
    this.group.add(this.rightEye);

    // Glow light
    this.glowLight = new THREE.PointLight(0xff2222, 0, 5);
    this.glowLight.position.y = 0.5;
    this.group.add(this.glowLight);

    this.group.visible = false;
    scene.add(this.group);

    // All mesh parts for opacity control
    this.allMeshes = [this.body, this.head, ...this.hairMeshes, this.leftEye, this.rightEye];

    this._ambientEventTimer = 0;
    this._ambientEventInterval = 8 + Math.random() * 12;
  }

  _getAllMeshMaterials() {
    return this.allMeshes.map(m => m.material);
  }

  _setOpacity(val) {
    this.opacity = Math.max(0, Math.min(1, val));
    this.body.material.opacity = this.opacity * 0.4;
    this.head.material.opacity = this.opacity * 0.4;
    this.hairMeshes.forEach(h => { h.material.opacity = this.opacity * 0.85; });
    this.leftEye.material.opacity = this.opacity;
    this.rightEye.material.opacity = this.opacity;
    this.glowLight.intensity = this.opacity * 0.3;
  }

  update(delta, playerPositions, sanityLevels) {
    // Float animation
    this.floatTime += delta;
    this.floatOffset = Math.sin(this.floatTime * 1.5) * 0.12;
    this.group.position.set(
      this.position.x,
      this.position.y + this.floatOffset,
      this.position.z
    );

    // Subtle rotation
    this.group.rotation.y += delta * 0.3;

    // Fade
    if (this.opacity < this.fadeTarget) {
      this._setOpacity(Math.min(this.opacity + delta * 0.8, this.fadeTarget));
    } else if (this.opacity > this.fadeTarget) {
      this._setOpacity(Math.max(this.opacity - delta * 0.8, this.fadeTarget));
    }

    if (this.opacity > 0 && !this.group.visible) {
      this.group.visible = true;
    }
    if (this.opacity <= 0 && this.group.visible && this.fadeTarget === 0) {
      this.group.visible = false;
    }

    // Cooldown
    if (this.cooldownTimer > 0) {
      this.cooldownTimer -= delta;
    }

    // Find lowest sanity player
    let lowestSanity = Infinity;
    let lowestSanityId = null;
    let lowestSanityPos = null;
    if (playerPositions && sanityLevels) {
      Object.keys(playerPositions).forEach(id => {
        const s = sanityLevels[id] !== undefined ? sanityLevels[id] : 100;
        if (s < lowestSanity) {
          lowestSanity = s;
          lowestSanityId = id;
          lowestSanityPos = playerPositions[id];
        }
      });
    }

    this.stateTimer += delta;

    switch (this.state) {
      case 'dormant':
        this.setVisible(false);
        this.dormantTimer += delta;
        this._ambientEventTimer += delta;

        if (this._ambientEventTimer >= this._ambientEventInterval) {
          this._ambientEventTimer = 0;
          this._ambientEventInterval = 8 + Math.random() * 12;
          this._triggerAmbientEvent();
        }

        this.aggressionLevel += delta * 0.003;

        if (this.dormantTimer >= 60 + Math.random() * 30) {
          this.dormantTimer = 0;
          this.state = 'stalking';
          this.stateTimer = 0;
          this.aggressionLevel = Math.min(1, this.aggressionLevel + 0.1);

          if (lowestSanityPos) {
            const offset = new THREE.Vector3(
              (Math.random() - 0.5) * 2,
              0,
              (Math.random() - 0.5) * 2
            ).normalize().multiplyScalar(8 + Math.random() * 5);
            this.teleportTo(new THREE.Vector3(
              lowestSanityPos.x + offset.x,
              lowestSanityPos.y,
              lowestSanityPos.z + offset.z
            ));
          }
        }
        break;

      case 'stalking':
        this.setVisible(true);
        this.stalkDuration += delta;

        // Check if player looking directly at Alisa
        if (playerPositions) {
          Object.keys(playerPositions).forEach(id => {
            const pPos = playerPositions[id];
            if (!pPos) return;
            const dist = this.position.distanceTo(pPos);
            if (dist < 15 && pPos.lookDir) {
              const toAlisa = new THREE.Vector3().subVectors(this.position, pPos).normalize();
              const dot = toAlisa.dot(pPos.lookDir);
              if (dot > 0.85) {
                // Player looking at Alisa
                if (sanityLevels && sanityLevels[id] !== undefined) {
                  sanityLevels[id] -= delta * 8;
                }
                // Disappear when looked at
                this.setVisible(false);
                this.state = 'dormant';
                this.stateTimer = 0;
                this.stalkDuration = 0;
                this.dormantTimer = 20 + Math.random() * 20;
              }
            }
          });
        }

        this.aggressionLevel = Math.min(1, this.aggressionLevel + delta * 0.01);

        if (this.stalkDuration >= 3 + Math.random() * 2) {
          this.stalkDuration = 0;
          this.setVisible(false);

          if (this.aggressionLevel > 0.5 && this.cooldownTimer <= 0) {
            this.state = 'hunting';
            this.stateTimer = 0;
            this.nearPlayerTimer = 0;
            this.targetPlayerId = lowestSanityId;
          } else {
            this.state = 'dormant';
            this.dormantTimer = 15 + Math.random() * 20;
          }
        }
        break;

      case 'hunting':
        this.setVisible(true);
        const target = lowestSanityPos || (playerPositions ? Object.values(playerPositions)[0] : null);
        const tId = lowestSanityId || (playerPositions ? Object.keys(playerPositions)[0] : null);

        if (target) {
          const direction = new THREE.Vector3().subVectors(target, this.position);
          const dist = direction.length();

          if (dist > 0.5) {
            direction.normalize();
            this.position.addScaledVector(direction, 3 * delta);
          }

          if (dist < 3) {
            this.nearPlayerTimer += delta;
            if (this.nearPlayerTimer >= 2) {
              this.nearPlayerTimer = 0;
              this.attack(tId);
              if (sanityLevels && sanityLevels[tId] !== undefined) {
                sanityLevels[tId] = Math.max(0, sanityLevels[tId] - 20);
              }
              // Retreat
              this.setVisible(false);
              this.state = 'dormant';
              this.dormantTimer = 30;
              this.cooldownTimer = 20;
            }
          } else {
            this.nearPlayerTimer = 0;
          }
        } else {
          this.state = 'dormant';
        }

        // Give up after 30s
        if (this.stateTimer > 30) {
          this.setVisible(false);
          this.state = 'dormant';
          this.dormantTimer = 20;
        }
        break;

      case 'manifesting':
        this.setVisible(true);
        // Story scripted - just float and pulse
        this._setOpacity(0.6 + Math.sin(this.floatTime * 3) * 0.2);
        if (this.stateTimer > 10) {
          this.state = 'dormant';
          this.dormantTimer = 30;
        }
        break;
    }

    // Update particles
    this.particles = this.particles.filter(p => {
      p.life -= delta;
      if (p.mesh) {
        p.mesh.position.addScaledVector(p.velocity, delta);
        p.mesh.material.opacity = Math.max(0, p.life / p.maxLife);
        if (p.life <= 0) {
          this.scene.remove(p.mesh);
          return false;
        }
      }
      return true;
    });
  }

  _triggerAmbientEvent() {
    // Ambient events like flickering or sounds would be dispatched here
    const event = new CustomEvent('alisaAmbient', {
      detail: { type: ['flicker', 'sound', 'shadow', 'cold'][Math.floor(Math.random() * 4)] }
    });
    if (typeof window !== 'undefined') window.dispatchEvent(event);
  }

  setVisible(v) {
    this.isVisible = v;
    this.fadeTarget = v ? 1 : 0;
    if (v && !this.group.visible) {
      this.group.visible = true;
    }
  }

  getPosition() {
    return this.position.clone();
  }

  isNearPlayer(pos, range) {
    if (!pos) return false;
    return this.position.distanceTo(pos) <= range;
  }

  attack(playerId) {
    const event = new CustomEvent('alisaAttack', { detail: { playerId, position: this.position.clone() } });
    if (typeof window !== 'undefined') window.dispatchEvent(event);

    // Flash effect
    this._setOpacity(1);
    setTimeout(() => { this._setOpacity(0.4); }, 100);
    setTimeout(() => { this._setOpacity(1); }, 200);
    setTimeout(() => { this._setOpacity(0); }, 350);
  }

  teleportTo(pos) {
    this._spawnParticles(this.position.clone());
    this.position.copy(pos);
    this.group.position.copy(pos);
    this._spawnParticles(pos.clone());
  }

  _spawnParticles(pos) {
    for (let i = 0; i < 8; i++) {
      const pGeo = new THREE.SphereGeometry(0.04, 4, 4);
      const pMat = new THREE.MeshBasicMaterial({ color: 0xff2222, transparent: true, opacity: 0.8 });
      const pMesh = new THREE.Mesh(pGeo, pMat);
      pMesh.position.copy(pos);
      pMesh.position.y += Math.random() * 1.5;
      this.scene.add(pMesh);
      const vel = new THREE.Vector3(
        (Math.random() - 0.5) * 2,
        Math.random() * 1.5,
        (Math.random() - 0.5) * 2
      );
      this.particles.push({ mesh: pMesh, velocity: vel, life: 0.8, maxLife: 0.8 });
    }
  }

  manifest() {
    this.state = 'manifesting';
    this.stateTimer = 0;
    this.setVisible(true);
  }

  reset() {
    this.state = 'dormant';
    this.aggressionLevel = 0;
    this.cooldownTimer = 0;
    this.dormantTimer = 0;
    this.stateTimer = 0;
    this.nearPlayerTimer = 0;
    this.stalkDuration = 0;
    this.setVisible(false);
  }
}

class InteractionSystem {
  constructor(scene, gameState) {
    this.scene = scene;
    this.gameState = gameState;
    this.interactables = new Map();
    this.doorStates = new Map();
    this.hidingState = { active: false, spotId: null, playerId: null };
    this.inventory = [];
    this.activeDocument = null;
    this.activePuzzle = null;
    this._doorAnimations = new Map();
  }

  registerDoor(id, mesh, options = {}) {
    const defaults = {
      open: false,
      locked: false,
      angle: 0,
      openAngle: 1.5,
      keyRequired: null,
      soundOpen: null,
      soundClose: null
    };
    const data = Object.assign({}, defaults, options);
    this.doorStates.set(id, {
      open: data.open,
      locked: data.locked,
      angle: data.angle,
      openAngle: data.openAngle,
      keyRequired: data.keyRequired,
      currentAngle: 0
    });
    this.interactables.set(id, {
      mesh,
      type: 'door',
      data,
      callback: options.callback || null
    });
  }

  registerItem(id, mesh, itemData = {}) {
    const defaults = {
      name: 'Item',
      type: 'generic',
      description: '',
      icon: null,
      usable: false
    };
    const data = Object.assign({}, defaults, itemData);
    this.interactables.set(id, {
      mesh,
      type: 'item',
      data,
      callback: itemData.callback || null
    });
  }

  registerDocument(id, mesh, docData = {}) {
    const defaults = {
      title: 'Document',
      content: '',
      image: null,
      read: false
    };
    const data = Object.assign({}, defaults, docData);
    this.interactables.set(id, {
      mesh,
      type: 'document',
      data,
      callback: docData.callback || null
    });
  }

  registerPuzzle(id, mesh, puzzleData = {}) {
    const defaults = {
      name: 'Puzzle',
      solved: false,
      solution: null,
      currentState: null,
      attempts: 0
    };
    const data = Object.assign({}, defaults, puzzleData);
    this.interactables.set(id, {
      mesh,
      type: 'puzzle',
      data,
      callback: puzzleData.callback || null
    });
  }

  registerHidingSpot(id, mesh, options = {}) {
    const defaults = {
      cameraPosition: new THREE.Vector3(0, 1, 0),
      cameraRotation: new THREE.Euler(0, 0, 0),
      capacity: 1,
      currentOccupants: 0
    };
    const data = Object.assign({}, defaults, options);
    this.interactables.set(id, {
      mesh,
      type: 'hiding',
      data,
      callback: options.callback || null
    });
  }

  interact(objectId, playerId) {
    if (!this.interactables.has(objectId)) return false;
    const obj = this.interactables.get(objectId);

    switch (obj.type) {
      case 'door':
        return this._interactDoor(objectId, obj, playerId);
      case 'item':
        return this._interactItem(objectId, obj, playerId);
      case 'document':
        return this._interactDocument(objectId, obj, playerId);
      case 'puzzle':
        return this._interactPuzzle(objectId, obj, playerId);
      case 'hiding':
        return this._interactHiding(objectId, obj, playerId);
      default:
        return false;
    }
  }

  _interactDoor(id, obj, playerId) {
    const doorState = this.doorStates.get(id);
    if (!doorState) return false;

    if (doorState.locked) {
      if (doorState.keyRequired) {
        const hasKey = this.inventory.some(item => item.id === doorState.keyRequired || item.type === 'llaves');
        if (!hasKey) {
          this._dispatchEvent('doorLocked', { id, message: 'La puerta estÃ¡ cerrada con llave.' });
          this._playSound('door_locked');
          return false;
        }
        doorState.locked = false;
      } else {
        this._dispatchEvent('doorLocked', { id });
        return false;
      }
    }

    doorState.open = !doorState.open;
    const targetAngle = doorState.open ? doorState.openAngle : 0;

    this._doorAnimations.set(id, {
      from: doorState.currentAngle,
      to: targetAngle,
      progress: 0,
      duration: 0.6
    });

    this._playSound(doorState.open ? 'door_open' : 'door_close');
    this._dispatchEvent('doorToggled', { id, open: doorState.open });

    if (obj.callback) obj.callback({ id, open: doorState.open });
    return true;
  }

  _interactItem(id, obj, playerId) {
    const validItems = ['linterna', 'cruz', 'walkie', 'libro', 'pilas', 'llaves', 'generic'];
    const item = {
      id,
      name: obj.data.name,
      type: obj.data.type,
      description: obj.data.description,
      icon: obj.data.icon,
      usable: obj.data.usable
    };

    this.inventory.push(item);

    if (obj.mesh) {
      this.scene.remove(obj.mesh);
      obj.mesh.geometry && obj.mesh.geometry.dispose();
    }

    this.interactables.delete(id);
    this._playSound('item_pickup');
    this._dispatchEvent('itemPickedUp', { id, item, playerId });

    if (obj.callback) obj.callback({ id, item, playerId });
    return true;
  }

  _interactDocument(id, obj, playerId) {
    obj.data.read = true;
    this.activeDocument = obj.data;
    this._dispatchEvent('documentOpened', { id, docData: obj.data });
    this._playSound('paper_rustle');
    if (obj.callback) obj.callback({ id, docData: obj.data });
    return true;
  }

  closeDocument() {
    this.activeDocument = null;
    this._dispatchEvent('documentClosed', {});
  }

  _interactPuzzle(id, obj, playerId) {
    if (obj.data.solved) {
      this._dispatchEvent('puzzleAlreadySolved', { id });
      return false;
    }
    this.activePuzzle = { id, ...obj.data };
    this._dispatchEvent('puzzleActivated', { id, puzzleData: obj.data });
    this._playSound('puzzle_activate');
    if (obj.callback) obj.callback({ id, puzzleData: obj.data });
    return true;
  }

  solvePuzzle(id, solution) {
    if (!this.interactables.has(id)) return false;
    const obj = this.interactables.get(id);
    if (obj.type !== 'puzzle') return false;

    const correct = JSON.stringify(solution) === JSON.stringify(obj.data.solution);
    obj.data.attempts++;

    if (correct) {
      obj.data.solved = true;
      this.activePuzzle = null;
      this._dispatchEvent('puzzleSolved', { id });
      this._playSound('puzzle_solved');
      return true;
    } else {
      this._dispatchEvent('puzzleFailed', { id, attempts: obj.data.attempts });
      this._playSound('puzzle_fail');
      return false;
    }
  }

  _interactHiding(id, obj, playerId) {
    if (this.hidingState.active && this.hidingState.spotId === id) {
      // Exit hiding
      this.hidingState.active = false;
      this.hidingState.spotId = null;
      this.hidingState.playerId = null;
      obj.data.currentOccupants = Math.max(0, obj.data.currentOccupants - 1);
      this._dispatchEvent('hidingExited', { id, playerId });
      this._playSound('hiding_exit');
    } else if (!this.hidingState.active && obj.data.currentOccupants < obj.data.capacity) {
      // Enter hiding
      this.hidingState.active = true;
      this.hidingState.spotId = id;
      this.hidingState.playerId = playerId;
      obj.data.currentOccupants++;
      this._dispatchEvent('hidingEntered', {
        id,
        playerId,
        cameraPosition: obj.data.cameraPosition,
        cameraRotation: obj.data.cameraRotation
      });
      this._playSound('hiding_enter');
    } else {
      this._dispatchEvent('hidingFull', { id });
      return false;
    }
    if (obj.callback) obj.callback({ id, hiding: this.hidingState.active, playerId });
    return true;
  }

  isHiding() {
    return this.hidingState.active;
  }

  updateDoors(delta) {
    this._doorAnimations.forEach((anim, id) => {
      const obj = this.interactables.get(id);
      const doorState = this.doorStates.get(id);
      if (!obj || !obj.mesh || !doorState) { this._doorAnimations.delete(id); return; }

      anim.progress += delta / anim.duration;
      const t = Math.min(1, anim.progress);
      const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      const angle = anim.from + (anim.to - anim.from) * eased;

      obj.mesh.rotation.y = angle;
      doorState.currentAngle = angle;

      if (t >= 1) {
        this._doorAnimations.delete(id);
      }
    });
  }

  getEMFReading(pos, alisaPos) {
    if (!pos || !alisaPos) return 0;
    const dist = pos.distanceTo(alisaPos);
    if (dist > 20) return 0;
    if (dist > 15) return 1;
    if (dist > 10) return 2;
    if (dist > 6) return 3;
    if (dist > 3) return 4;
    return 5;
  }

  getTemperature(pos, alisaPos) {
    if (!pos || !alisaPos) return 20;
    const dist = pos.distanceTo(alisaPos);
    const baseTemp = 20;
    const minTemp = 2;
    if (dist > 15) return baseTemp;
    const factor = Math.max(0, 1 - dist / 15);
    const temp = baseTemp - (baseTemp - minTemp) * factor;
    return Math.round(temp * 10) / 10;
  }

  getInventory() {
    return [...this.inventory];
  }

  hasItem(type) {
    return this.inventory.some(i => i.type === type || i.id === type);
  }

  removeFromInventory(id) {
    const idx = this.inventory.findIndex(i => i.id === id);
    if (idx !== -1) { this.inventory.splice(idx, 1); return true; }
    return false;
  }

  _playSound(key) {
    this._dispatchEvent('playSound', { sound: key });
  }

  _dispatchEvent(name, detail) {
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('interaction:' + name, { detail }));
    }
  }
}

class HUDManager {
  constructor() {
    this._cache = {};
    this._ids = [
      'sanity-fill', 'sanity-text', 'interaction-prompt',
      'objective-text', 'emf-value', 'temp-value',
      'inventory-wheel', 'chat-messages', 'player-list',
      'minimap-canvas', 'notification-container',
      'battery-leds', 'emf-bars', 'hud-root',
      'static-overlay', 'hud-wrapper'
    ];
    this._ids.forEach(id => {
      this._cache[id] = document.getElementById(id);
    });

    this._sanityValue = 100;
    this._batteryValue = 100;
    this._glitchInterval = null;
    this._corruptInterval = null;
    this._staticOverlay = null;
    this._chatMessages = [];
    this._maxChatMessages = 20;
    this._notificationQueue = [];
    this._notificationShowing = false;

    this._ensureStaticOverlay();
    this._ensureNotificationContainer();
  }

  _el(id) {
    if (!this._cache[id]) this._cache[id] = document.getElementById(id);
    return this._cache[id];
  }

  _ensureStaticOverlay() {
    let el = document.getElementById('hud-static-overlay');
    if (!el) {
      el = document.createElement('div');
      el.id = 'hud-static-overlay';
      el.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9998;opacity:0;background:url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'200\' height=\'200\'%3E%3Cfilter id=\'n\'%3E%3CfeTurbulence type=\'fractalNoise\' baseFrequency=\'0.65\' numOctaves=\'3\' stitchTiles=\'stitch\'/%3E%3C/filter%3E%3Crect width=\'200\' height=\'200\' filter=\'url(%23n)\' opacity=\'0.5\'/%3E%3C/svg%3E");transition:opacity 0.3s;';
      document.body.appendChild(el);
    }
    this._staticOverlay = el;
  }

  _ensureNotificationContainer() {
    let el = document.getElementById('hud-notification-container');
    if (!el) {
      el = document.createElement('div');
      el.id = 'hud-notification-container';
      el.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:9999;pointer-events:none;display:flex;flex-direction:column;align-items:center;gap:8px;';
      document.body.appendChild(el);
    }
    this._notificationContainer = el;
  }

  updateSanity(value) {
    this._sanityValue = Math.max(0, Math.min(100, value));
    const fill = this._el('sanity-fill');
    const text = this._el('sanity-text');

    if (fill) {
      // SVG circle: circumference for r=18 is ~113.1
      const circumference = 2 * Math.PI * 18;
      const offset = circumference - (this._sanityValue / 100) * circumference;
      fill.style.strokeDasharray = circumference;
      fill.style.strokeDashoffset = offset;

      let color;
      if (this._sanityValue > 60) {
        color = '#00ff88';
      } else if (this._sanityValue > 30) {
        color = '#ffcc00';
      } else {
        color = '#ff2222';
      }
      fill.style.stroke = color;
    }

    if (text) {
      text.textContent = Math.round(this._sanityValue) + '%';
      if (this._sanityValue > 60) {
        text.style.color = '#00ff88';
      } else if (this._sanityValue > 30) {
        text.style.color = '#ffcc00';
      } else {
        text.style.color = '#ff2222';
      }
    }

    this.applySanityEffects(this._sanityValue);
  }

  updateBattery(value) {
    this._batteryValue = Math.max(0, Math.min(100, value));
    const container = this._el('battery-leds');
    if (!container) return;

    const leds = container.querySelectorAll('.battery-led');
    if (leds.length === 0) {
      // Create 5 LEDs if they don't exist
      for (let i = 0; i < 5; i++) {
        const led = document.createElement('div');
        led.className = 'battery-led';
        led.style.cssText = 'width:12px;height:20px;border:1px solid #555;border-radius:2px;transition:background 0.3s;display:inline-block;margin:1px;';
        container.appendChild(led);
      }
    }

    const allLeds = container.querySelectorAll('.battery-led');
    const thresholds = [20, 40, 60, 80, 100];
    const colors = ['#ff2222', '#ff6600', '#ffcc00', '#88ff00', '#00ff88'];

    allLeds.forEach((led, i) => {
      const threshold = thresholds[i];
      const color = colors[i];
      if (this._batteryValue >= threshold - 18) {
        led.style.background = color;
        led.style.boxShadow = '0 0 4px ' + color;
      } else {
        led.style.background = '#1a1a1a';
        led.style.boxShadow = 'none';
      }
    });
  }

  showInteractionPrompt(text) {
    const el = this._el('interaction-prompt');
    if (!el) return;
    if (text) {
      el.textContent = text;
      el.style.display = 'block';
      el.style.opacity = '1';
      el.style.transform = 'translateX(-50%) translateY(0)';
    } else {
      el.style.opacity = '0';
      el.style.transform = 'translateX(-50%) translateY(10px)';
      setTimeout(() => {
        if (el.style.opacity === '0') el.style.display = 'none';
      }, 300);
    }
  }

  updateObjective(text) {
    const el = this._el('objective-text');
    if (!el) return;
    el.style.opacity = '0';
    el.style.transform = 'translateY(-5px)';
    setTimeout(() => {
      el.textContent = text;
      el.style.transition = 'opacity 0.4s, transform 0.4s';
      el.style.opacity = '1';
      el.style.transform = 'translateY(0)';
    }, 200);
  }

  updateEMF(level) {
    const el = this._el('emf-value');
    if (el) {
      el.textContent = 'EMF ' + level;
      const colors = ['#333333', '#00aa44', '#aaff00', '#ffaa00', '#ff4400', '#ff0000'];
      el.style.color = colors[Math.min(5, Math.max(0, level))];
      if (level >= 5) {
        el.style.animation = 'none';
        el.style.textShadow = '0 0 8px #ff0000';
      } else {
        el.style.textShadow = 'none';
      }
    }

    const barsEl = this._el('emf-bars');
    if (barsEl) {
      let bars = barsEl.querySelectorAll('.emf-bar');
      if (bars.length === 0) {
        for (let i = 0; i < 5; i++) {
          const bar = document.createElement('div');
          bar.className = 'emf-bar';
          bar.style.cssText = 'width:6px;height:' + (8 + i * 4) + 'px;border-radius:1px;margin:0 1px;display:inline-block;vertical-align:bottom;transition:background 0.2s;';
          barsEl.appendChild(bar);
        }
        bars = barsEl.querySelectorAll('.emf-bar');
      }
      const barColors = ['#00aa44', '#88ff00', '#ffcc00', '#ff6600', '#ff0000'];
      bars.forEach((bar, i) => {
        if (i < level) {
          bar.style.background = barColors[i];
          bar.style.boxShadow = '0 0 4px ' + barColors[i];
        } else {
          bar.style.background = '#222';
          bar.style.boxShadow = 'none';
        }
      });
    }
  }

  updateTemperature(temp) {
    const el = this._el('temp-value');
    if (!el) return;
    el.textContent = temp.toFixed(1) + 'Â°C';
    if (temp <= 5) {
      el.style.color = '#88ccff';
      el.style.textShadow = '0 0 6px #88ccff';
    } else if (temp <= 10) {
      el.style.color = '#aaddff';
      el.style.textShadow = 'none';
    } else if (temp <= 15) {
      el.style.color = '#cceecc';
      el.style.textShadow = 'none';
    } else {
      el.style.color = '#ffffff';
      el.style.textShadow = 'none';
    }
  }

  toggleInventory(show) {
    const el = this._el('inventory-wheel');
    if (!el) return;
    if (show) {
      el.style.display = 'flex';
      el.style.transform = 'scale(0.7)';
      el.style.opacity = '0';
      el.style.transition = 'transform 0.25s cubic-bezier(0.34,1.56,0.64,1), opacity 0.2s';
      requestAnimationFrame(() => {
        el.style.transform = 'scale(1)';
        el.style.opacity = '1';
      });
    } else {
      el.style.transition = 'transform 0.2s ease-in, opacity 0.2s';
      el.style.transform = 'scale(0.7)';
      el.style.opacity = '0';
      setTimeout(() => { el.style.display = 'none'; }, 220);
    }
  }

  addChatMessage(sender, msg) {
    const container = this._el('chat-messages');
    if (!container) return;

    const msgObj = { sender, msg, time: Date.now() };
    this._chatMessages.push(msgObj);

    const el = document.createElement('div');
    el.className = 'chat-message';
    el.style.cssText = 'padding:2px 6px;font-size:13px;color:#ddd;opacity:0;transition:opacity 0.3s;word-break:break-word;';
    const senderSpan = document.createElement('span');
    senderSpan.style.cssText = 'font-weight:bold;color:#ff8888;margin-right:6px;';
    senderSpan.textContent = sender + ':';
    const msgSpan = document.createElement('span');
    msgSpan.textContent = msg;
    el.appendChild(senderSpan);
    el.appendChild(msgSpan);
    container.appendChild(el);

    requestAnimationFrame(() => { el.style.opacity = '1'; });
    container.scrollTop = container.scrollHeight;

    // Trim old messages
    while (this._chatMessages.length > this._maxChatMessages) {
      this._chatMessages.shift();
      const old = container.querySelector('.chat-message');
      if (old) {
        old.style.opacity = '0';
        setTimeout(() => { if (old.parentNode) old.parentNode.removeChild(old); }, 300);
      }
    }
  }

  showNotification(text) {
    this._notificationQueue.push(text);
    if (!this._notificationShowing) {
      this._showNextNotification();
    }
  }

  _showNextNotification() {
    if (this._notificationQueue.length === 0) {
      this._notificationShowing = false;
      return;
    }
    this._notificationShowing = true;
    const text = this._notificationQueue.shift();
    const container = this._notificationContainer || document.getElementById('hud-notification-container');
    if (!container) { this._notificationShowing = false; return; }

    const el = document.createElement('div');
    el.style.cssText = 'background:rgba(0,0,0,0.85);border:1px solid #ff2222;color:#fff;padding:8px 20px;border-radius:4px;font-size:14px;letter-spacing:1px;opacity:0;transform:translateY(-10px);transition:opacity 0.3s,transform 0.3s;pointer-events:none;text-align:center;max-width:300px;';
    el.textContent = text;
    container.appendChild(el);
    requestAnimationFrame(() => {
      el.style.opacity = '1';
      el.style.transform = 'translateY(0)';
    });
    setTimeout(() => {
      el.style.opacity = '0';
      el.style.transform = 'translateY(-10px)';
      setTimeout(() => {
        if (el.parentNode) el.parentNode.removeChild(el);
        setTimeout(() => this._showNextNotification(), 200);
      }, 300);
    }, 3000);
  }

  updatePlayerList(players) {
    const container = this._el('player-list');
    if (!container) return;
    container.innerHTML = '';
    if (!players) return;
    players.forEach(player => {
      const el = document.createElement('div');
      el.className = 'player-entry';
      el.style.cssText = 'display:flex;align-items:center;gap:6px;padding:2px 0;font-size:12px;color:#ccc;';

      const dot = document.createElement('span');
      dot.style.cssText = 'width:8px;height:8px;border-radius:50%;display:inline-block;flex-shrink:0;';
      const alive = player.alive !== false;
      dot.style.background = alive ? '#00ff88' : '#ff2222';
      dot.style.boxShadow = alive ? '0 0 4px #00ff88' : '0 0 4px #ff2222';

      const name = document.createElement('span');
      name.textContent = player.name || player.id || 'Player';
      if (!alive) {
        name.style.textDecoration = 'line-through';
        name.style.opacity = '0.5';
      }

      const sanity = document.createElement('span');
      sanity.style.marginLeft = 'auto';
      sanity.style.fontSize = '11px';
      const s = player.sanity !== undefined ? Math.round(player.sanity) : 100;
      sanity.textContent = s + '%';
      sanity.style.color = s > 60 ? '#00ff88' : s > 30 ? '#ffcc00' : '#ff2222';

      el.appendChild(dot);
      el.appendChild(name);
      el.appendChild(sanity);
      container.appendChild(el);
    });
  }

  updateMinimap(ctx, playerPos, others, rooms) {
    if (!ctx) return;
    const canvas = ctx.canvas;
    const W = canvas.width;
    const H = canvas.height;
    const scale = 4;
    const cx = W / 2;
    const cy = H / 2;

    ctx.clearRect(0, 0, W, H);

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.beginPath();
    ctx.arc(cx, cy, W / 2, 0, Math.PI * 2);
    ctx.fill();

    // Clip to circle
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, W / 2 - 2, 0, Math.PI * 2);
    ctx.clip();

    // Draw rooms
    if (rooms && rooms.length > 0) {
      rooms.forEach(room => {
        if (!playerPos) return;
        const rx = cx + (room.x - playerPos.x) * scale;
        const ry = cy + (room.z - playerPos.z) * scale;
        ctx.fillStyle = 'rgba(60,60,80,0.6)';
        ctx.strokeStyle = 'rgba(100,100,130,0.8)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.rect(rx - room.w * scale / 2, ry - room.h * scale / 2, room.w * scale, room.h * scale);
        ctx.fill();
        ctx.stroke();
      });
    }

    // Draw other players
    if (others && playerPos) {
      others.forEach(other => {
        if (!other.position) return;
        const ox = cx + (other.position.x - playerPos.x) * scale;
        const oy = cy + (other.position.z - playerPos.z) * scale;
        ctx.beginPath();
        ctx.arc(ox, oy, 4, 0, Math.PI * 2);
        ctx.fillStyle = other.color || '#4488ff';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.stroke();
      });
    }

    // Draw local player (always center)
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#00ff88';
    ctx.fill();
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Direction indicator
    if (playerPos && playerPos.rotation !== undefined) {
      const angle = playerPos.rotation;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.sin(angle) * 10, cy - Math.cos(angle) * 10);
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.restore();

    // Border
    ctx.beginPath();
    ctx.arc(cx, cy, W / 2 - 1, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(200,50,50,0.6)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  applySanityEffects(sanity) {
    const hudRoot = this._el('hud-root') || this._el('hud-wrapper') || document.body;

    // Clear existing
    if (this._glitchInterval) { clearInterval(this._glitchInterval); this._glitchInterval = null; }
    if (this._corruptInterval) { clearInterval(this._corruptInterval); this._corruptInterval = null; }

    // Static overlay
    if (this._staticOverlay) {
      if (sanity <= 20) {
        this._staticOverlay.style.opacity = '0.35';
        this._staticOverlay.style.mixBlendMode = 'screen';
      } else if (sanity <= 40) {
        this._staticOverlay.style.opacity = '0.12';
      } else {
        this._staticOverlay.style.opacity = '0';
      }
    }

    if (sanity < 60) {
      // HUD jitter
      const intensity = (60 - sanity) / 60;
      const glitchFreq = Math.max(100, 2000 - intensity * 1800);
      this._glitchInterval = setInterval(() => {
        if (Math.random() < intensity * 0.7) {
          const jx = (Math.random() - 0.5) * intensity * 8;
          const jy = (Math.random() - 0.5) * intensity * 4;
          if (hudRoot) {
            hudRoot.style.transform = 'translate(' + jx + 'px,' + jy + 'px)';
            setTimeout(() => { if (hudRoot) hudRoot.style.transform = 'translate(0,0)'; }, 80);
          }
        }
      }, glitchFreq);
    }

    if (sanity < 40) {
      // Text corruption
      const textEl = this._el('sanity-text');
      const corruptFreq = Math.max(150, 1500 - ((40 - sanity) / 40) * 1300);
      this._corruptInterval = setInterval(() => {
        if (!textEl) return;
        if (Math.random() < 0.5) {
          const corrupt = this._corruptText(Math.round(this._sanityValue) + '%');
          textEl.textContent = corrupt;
          setTimeout(() => {
            if (textEl) textEl.textContent = Math.round(this._sanityValue) + '%';
          }, 120);
        }
      }, corruptFreq);
    }
  }

  _corruptText(text) {
    const chars = '!@#$%^&*0123456789X?';
    return text.split('').map(c => {
      if (Math.random() < 0.4 && c !== ' ') {
        return chars[Math.floor(Math.random() * chars.length)];
      }
      return c;
    }).join('');
  }

  showCrossbar(show) {
    let crossbar = document.getElementById('hud-crossbar');
    if (!crossbar && show) {
      crossbar = document.createElement('div');
      crossbar.id = 'hud-crossbar';
      crossbar.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:12px;height:12px;pointer-events:none;z-index:9990;';
      crossbar.innerHTML = '<div style="position:absolute;top:50%;left:0;width:100%;height:1px;background:rgba(255,255,255,0.6);transform:translateY(-50%);"></div><div style="position:absolute;left:50%;top:0;height:100%;width:1px;background:rgba(255,255,255,0.6);transform:translateX(-50%);"></div>';
      document.body.appendChild(crossbar);
    }
    if (crossbar) crossbar.style.display = show ? 'block' : 'none';
  }

  flashEffect(color, duration) {
    const flash = document.createElement('div');
    flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:' + (color || '#ff0000') + ';pointer-events:none;z-index:9997;opacity:0.5;transition:opacity ' + ((duration || 300)) + 'ms ease-out;';
    document.body.appendChild(flash);
    requestAnimationFrame(() => {
      flash.style.opacity = '0';
      setTimeout(() => { if (flash.parentNode) flash.parentNode.removeChild(flash); }, duration || 300);
    });
  }
}

// ========== MULTIPLAYER NETWORKING ==========
// ============================================================
// MULTIPLAYER NETWORKING SYSTEM
// El Susurro de la Inocente - 4-Player Co-op Horror Game
// ============================================================

'use strict';

// ============================================================
// SECTION 1: MultiplayerManager
// ============================================================

class MultiplayerManager {
  constructor() {
    this.peer = null;
    this.connections = new Map(); // peerId -> DataConnection
    this.isHost = false;
    this.roomCode = null;
    this.localPlayerId = null;
    this.maxPlayers = 4;
    this.players = new Map(); // peerId -> playerData
    this.localPlayerData = null;
    this.lobbyReadyStates = new Map(); // peerId -> boolean

    // Sync state
    this._updateInterval = null;
    this._lastSentState = null;
    this._positionUpdateHz = 20;
    this._positionUpdateInterval = 1000 / this._positionUpdateHz;

    // Callbacks - set externally
    this.onPlayerJoinCallback = null;
    this.onPlayerLeaveCallback = null;
    this.onChatMessageCallback = null;
    this.onGameEventCallback = null;
    this.onObjectInteractCallback = null;
    this.onAlisaUpdateCallback = null;
    this.onGameStateCallback = null;
    this.onReadyStateCallback = null;
    this.onStartGameCallback = null;
    this.onHostMigratedCallback = null;
    this.onConnectionErrorCallback = null;
    this.onRoomCreatedCallback = null;
    this.onRoomJoinedCallback = null;
    this.onPlayerUpdateCallback = null;

    // Connection metadata
    this._joinTime = null;
    this._peerCreationTime = null;
    this._reconnectAttempts = 0;
    this._maxReconnectAttempts = 3;

    // Delta compression state
    this._lastBroadcastedState = {};

    // PeerJS config
    this._peerConfig = {
      debug: 0,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' },
          {
            urls: 'turn:openrelay.metered.ca:80',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          },
          {
            urls: 'turn:openrelay.metered.ca:443',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ]
      }
    };

    // Message handlers registry
    this._messageHandlers = {
      player_update: this._handlePlayerUpdate.bind(this),
      player_join: this._handlePlayerJoin.bind(this),
      player_leave: this._handlePlayerLeave.bind(this),
      chat_message: this._handleChatMessage.bind(this),
      game_event: this._handleGameEvent.bind(this),
      object_interact: this._handleObjectInteract.bind(this),
      alisa_update: this._handleAlisaUpdate.bind(this),
      game_state: this._handleGameState.bind(this),
      ready_state: this._handleReadyState.bind(this),
      start_game: this._handleStartGame.bind(this),
      host_ping: this._handleHostPing.bind(this),
      host_pong: this._handleHostPong.bind(this),
      request_game_state: this._handleRequestGameState.bind(this)
    };

    // Ping/latency tracking
    this._pingMap = new Map(); // peerId -> { sentAt, latency }
    this._pingInterval = null;

    // Priority queue for nearby updates
    this._localPosition = { x: 0, y: 0, z: 0 };
  }

  // ----------------------------------------------------------
  // Room System
  // ----------------------------------------------------------

  /**
   * Host creates a Peer with a generated room code as the peer ID.
   * Room code: 4 uppercase letters + 2 digits (e.g., "ABCD12")
   */
  createRoom(playerData) {
    return new Promise((resolve, reject) => {
      if (this.peer) {
        this.destroy();
      }

      const code = this._generateRoomCode();
      this.roomCode = code;
      this.isHost = true;
      this._joinTime = Date.now();
      this._peerCreationTime = Date.now();

      try {
        this.peer = new Peer(code, this._peerConfig);
      } catch (err) {
        reject(new Error('Failed to initialize PeerJS: ' + err.message));
        return;
      }

      const openTimeout = setTimeout(() => {
        reject(new Error('Room creation timed out. Check your connection.'));
        this.destroy();
      }, 15000);

      this.peer.on('open', (id) => {
        clearTimeout(openTimeout);
        this.localPlayerId = id;
        this.roomCode = id;

        // Register self as first player
        this.localPlayerData = Object.assign({ id: id, isHost: true, joinTime: Date.now() }, playerData);
        this.players.set(id, this.localPlayerData);
        this.lobbyReadyStates.set(id, false);

        // Listen for incoming connections
        this.peer.on('connection', (conn) => this._onIncomingConnection(conn));

        // Start ping interval
        this._startPingInterval();

        if (this.onRoomCreatedCallback) {
          this.onRoomCreatedCallback(id);
        }

        resolve(id);
      });

      this.peer.on('error', (err) => {
        clearTimeout(openTimeout);
        const msg = this._parsePeerError(err);

        if (err.type === 'unavailable-id') {
          // Room code collision - try again
          this.destroy();
          this.createRoom(playerData).then(resolve).catch(reject);
          return;
        }

        if (this.onConnectionErrorCallback) {
          this.onConnectionErrorCallback(msg, err.type);
        }
        reject(new Error(msg));
      });

      this.peer.on('disconnected', () => {
        console.warn('[MultiplayerManager] Peer disconnected from signaling server. Attempting reconnect...');
        this._attemptPeerReconnect();
      });

      this.peer.on('close', () => {
        console.warn('[MultiplayerManager] Peer connection closed.');
      });
    });
  }

  /**
   * Client joins a room by connecting to host's peer ID (room code).
   */
  joinRoom(roomCode, playerData) {
    return new Promise((resolve, reject) => {
      if (!this._validateRoomCode(roomCode)) {
        reject(new Error('Invalid room code format. Expected 4 uppercase letters + 2 digits (e.g. ABCD12).'));
        return;
      }

      if (this.peer) {
        this.destroy();
      }

      this.isHost = false;
      this.roomCode = roomCode.toUpperCase();
      this._joinTime = Date.now();
      this._peerCreationTime = Date.now();

      try {
        this.peer = new Peer(this._peerConfig);
      } catch (err) {
        reject(new Error('Failed to initialize PeerJS: ' + err.message));
        return;
      }

      const openTimeout = setTimeout(() => {
        reject(new Error('Connection timed out. Check your connection.'));
        this.destroy();
      }, 15000);

      this.peer.on('open', (localId) => {
        clearTimeout(openTimeout);
        this.localPlayerId = localId;

        this.localPlayerData = Object.assign({ id: localId, isHost: false, joinTime: Date.now() }, playerData);
        this.players.set(localId, this.localPlayerData);
        this.lobbyReadyStates.set(localId, false);

        // Connect to host
        const conn = this.peer.connect(this.roomCode, {
          reliable: true,
          metadata: {
            playerData: this.localPlayerData,
            version: '1.0.0'
          }
        });

        const connTimeout = setTimeout(() => {
          reject(new Error('Could not find room "' + this.roomCode + '". Room may not exist.'));
          conn.close();
        }, 10000);

        conn.on('open', () => {
          clearTimeout(connTimeout);
          this.connections.set(this.roomCode, conn);
          this._setupConnectionHandlers(conn);

          // Announce join to host
          this._sendToConnection(conn, {
            type: 'player_join',
            data: this.localPlayerData
          });

          // Request full game state
          this._sendToConnection(conn, {
            type: 'request_game_state',
            data: { id: localId }
          });

          // Also listen for incoming connections (for client-to-client if needed)
          this.peer.on('connection', (inConn) => this._onIncomingConnection(inConn));

          this._startPingInterval();

          if (this.onRoomJoinedCallback) {
            this.onRoomJoinedCallback(this.roomCode, this.localPlayerData);
          }

          resolve({ roomCode: this.roomCode, localId });
        });

        conn.on('error', (err) => {
          clearTimeout(connTimeout);
          const msg = this._parsePeerError(err);
          reject(new Error(msg));
        });

        conn.on('close', () => {
          clearTimeout(connTimeout);
          // Host disconnected
          this._onPeerDisconnect(this.roomCode);
        });
      });

      this.peer.on('error', (err) => {
        clearTimeout(openTimeout);
        const msg = this._parsePeerError(err);
        if (this.onConnectionErrorCallback) {
          this.onConnectionErrorCallback(msg, err.type);
        }
        reject(new Error(msg));
      });

      this.peer.on('disconnected', () => {
        this._attemptPeerReconnect();
      });
    });
  }

  // ----------------------------------------------------------
  // Connection Management
  // ----------------------------------------------------------

  _onIncomingConnection(conn) {
    const peerId = conn.peer;

    if (this.isHost && this.connections.size >= this.maxPlayers - 1) {
      // Room is full
      conn.on('open', () => {
        this._sendToConnection(conn, {
          type: 'game_event',
          data: { eventType: 'room_full', params: {} }
        });
        setTimeout(() => conn.close(), 500);
      });
      return;
    }

    conn.on('open', () => {
      this.connections.set(peerId, conn);
      this._setupConnectionHandlers(conn);

      if (this.isHost) {
        // Notify all existing players of new joiner
        const newPlayerData = conn.metadata && conn.metadata.playerData
          ? conn.metadata.playerData
          : { id: peerId, name: 'Player', character: 'default', color: '#ffffff' };

        newPlayerData.id = peerId;
        this.players.set(peerId, newPlayerData);
        this.lobbyReadyStates.set(peerId, false);

        // Broadcast to all existing players (except new one)
        this.connections.forEach((existingConn, existingPeerId) => {
          if (existingPeerId !== peerId) {
            this._sendToConnection(existingConn, {
              type: 'player_join',
              data: newPlayerData
            });
          }
        });

        // Also notify the new player of all existing players
        this.players.forEach((pData, pid) => {
          if (pid !== peerId) {
            this._sendToConnection(conn, {
              type: 'player_join',
              data: pData
            });
          }
        });

        if (this.onPlayerJoinCallback) {
          this.onPlayerJoinCallback(peerId, newPlayerData);
        }
      }
    });

    conn.on('close', () => {
      this._onPeerDisconnect(peerId);
    });

    conn.on('error', (err) => {
      console.error('[MultiplayerManager] Connection error with peer ' + peerId + ':', err);
      this._onPeerDisconnect(peerId);
    });
  }

  _setupConnectionHandlers(conn) {
    conn.on('data', (rawData) => {
      try {
        const message = typeof rawData === 'string' ? JSON.parse(rawData) : rawData;
        this.onMessage(conn.peer, message);
      } catch (err) {
        console.error('[MultiplayerManager] Failed to parse message from ' + conn.peer + ':', err);
      }
    });
  }

  _onPeerDisconnect(peerId) {
    if (!this.connections.has(peerId) && !this.players.has(peerId)) return;

    this.connections.delete(peerId);
    const playerData = this.players.get(peerId);
    this.players.delete(peerId);
    this.lobbyReadyStates.delete(peerId);
    this._pingMap.delete(peerId);

    // Broadcast leave event
    this.broadcast({
      type: 'player_leave',
      data: { id: peerId }
    });

    if (this.onPlayerLeaveCallback) {
      this.onPlayerLeaveCallback(peerId, playerData);
    }

    // Check if host disconnected
    const wasHost = playerData && playerData.isHost;
    if (!this.isHost && wasHost) {
      this._attemptHostMigration();
    }
  }

  onPlayerJoin(peerId, playerData) {
    this.players.set(peerId, playerData);
    this.lobbyReadyStates.set(peerId, false);
    if (this.onPlayerJoinCallback) {
      this.onPlayerJoinCallback(peerId, playerData);
    }
  }

  onPlayerLeave(peerId) {
    this._onPeerDisconnect(peerId);
  }

  // ----------------------------------------------------------
  // Message Routing
  // ----------------------------------------------------------

  onMessage(peerId, message) {
    if (!message || typeof message.type !== 'string') {
      console.warn('[MultiplayerManager] Received malformed message from ' + peerId);
      return;
    }

    const handler = this._messageHandlers[message.type];
    if (handler) {
      handler(peerId, message.data);
    } else {
      console.warn('[MultiplayerManager] Unknown message type: ' + message.type);
    }

    // Host relays messages to other clients
    if (this.isHost && message.type !== 'host_ping' && message.type !== 'host_pong') {
      const relayTypes = [
        'player_update', 'player_join', 'player_leave',
        'chat_message', 'game_event', 'object_interact'
      ];
      if (relayTypes.includes(message.type)) {
        this.connections.forEach((conn, pid) => {
          if (pid !== peerId) {
            this._sendToConnection(conn, message);
          }
        });
      }
    }
  }

  // ----------------------------------------------------------
  // Message Handlers
  // ----------------------------------------------------------

  _handlePlayerUpdate(peerId, data) {
    if (!data || !data.id) return;
    if (this.onPlayerUpdateCallback) {
      this.onPlayerUpdateCallback(peerId, data);
    }
  }

  _handlePlayerJoin(peerId, data) {
    if (!data) return;
    const playerData = Object.assign({ id: peerId }, data);
    this.onPlayerJoin(data.id || peerId, playerData);
  }

  _handlePlayerLeave(peerId, data) {
    if (!data || !data.id) return;
    if (this.onPlayerLeaveCallback) {
      this.onPlayerLeaveCallback(data.id, this.players.get(data.id));
    }
    this.players.delete(data.id);
    this.connections.delete(data.id);
    this.lobbyReadyStates.delete(data.id);
  }

  _handleChatMessage(peerId, data) {
    if (!data) return;
    if (this.onChatMessageCallback) {
      this.onChatMessageCallback(peerId, data);
    }
  }

  _handleGameEvent(peerId, data) {
    if (!data) return;
    if (data.eventType === 'room_full') {
      if (this.onConnectionErrorCallback) {
        this.onConnectionErrorCallback('Room is full (max 4 players).', 'room_full');
      }
      this.destroy();
      return;
    }
    if (this.onGameEventCallback) {
      this.onGameEventCallback(peerId, data);
    }
  }

  _handleObjectInteract(peerId, data) {
    if (!data) return;
    if (this.isHost) {
      // Validate and authorize interaction
      const authorized = this._validateInteraction(peerId, data);
      if (!authorized) return;
      // Broadcast confirmed interaction
      this.broadcast({
        type: 'object_interact',
        data: data
      });
    }
    if (this.onObjectInteractCallback) {
      this.onObjectInteractCallback(peerId, data);
    }
  }

  _handleAlisaUpdate(peerId, data) {
    if (!data) return;
    // Only trust alisa updates from host
    const hostId = this._getHostId();
    if (peerId !== hostId && !this.isHost) return;
    if (this.onAlisaUpdateCallback) {
      this.onAlisaUpdateCallback(data);
    }
  }

  _handleGameState(peerId, data) {
    if (!data) return;
    if (this.onGameStateCallback) {
      this.onGameStateCallback(data);
    }
    // Register all players from state
    if (data.players) {
      data.players.forEach((p) => {
        if (p.id !== this.localPlayerId) {
          this.players.set(p.id, p);
          this.lobbyReadyStates.set(p.id, p.ready || false);
        }
      });
    }
  }

  _handleReadyState(peerId, data) {
    if (!data || typeof data.id === 'undefined') return;
    this.lobbyReadyStates.set(data.id, data.ready);
    if (this.onReadyStateCallback) {
      this.onReadyStateCallback(data.id, data.ready);
    }
  }

  _handleStartGame(peerId, data) {
    if (!data) return;
    const hostId = this._getHostId();
    if (peerId !== hostId && !this.isHost) return;
    if (this.onStartGameCallback) {
      this.onStartGameCallback(data);
    }
  }

  _handleHostPing(peerId, data) {
    this._sendToConnection(this.connections.get(peerId), {
      type: 'host_pong',
      data: { timestamp: data && data.timestamp ? data.timestamp : Date.now() }
    });
  }

  _handleHostPong(peerId, data) {
    if (!data || !data.timestamp) return;
    const pingInfo = this._pingMap.get(peerId);
    if (pingInfo) {
      pingInfo.latency = Date.now() - data.timestamp;
    }
  }

  _handleRequestGameState(peerId, data) {
    if (!this.isHost) return;
    if (this.onGameStateCallback === null) return;
    // Host should respond with full game state - trigger external game state serialization
    const event = new CustomEvent('networkRequestGameState', { detail: { requesterId: peerId } });
    window.dispatchEvent(event);
  }

  // ----------------------------------------------------------
  // Sending
  // ----------------------------------------------------------

  /**
   * Send a message to all connected peers.
   */
  broadcast(message) {
    const payload = this._serializeMessage(message);
    this.connections.forEach((conn, peerId) => {
      if (conn.open) {
        try {
          conn.send(payload);
        } catch (err) {
          console.error('[MultiplayerManager] Failed to broadcast to ' + peerId + ':', err);
        }
      }
    });
  }

  /**
   * Send a message to host only.
   */
  sendToHost(message) {
    if (this.isHost) {
      // Process locally
      this.onMessage(this.localPlayerId, message);
      return;
    }
    const hostConn = this.connections.get(this.roomCode);
    if (hostConn && hostConn.open) {
      try {
        hostConn.send(this._serializeMessage(message));
      } catch (err) {
        console.error('[MultiplayerManager] Failed to send to host:', err);
      }
    } else {
      console.warn('[MultiplayerManager] No open connection to host.');
    }
  }

  /**
   * Send a message to a specific peer.
   */
  sendToPeer(peerId, message) {
    if (peerId === this.localPlayerId) {
      this.onMessage(peerId, message);
      return;
    }
    const conn = this.connections.get(peerId);
    if (conn && conn.open) {
      try {
        conn.send(this._serializeMessage(message));
      } catch (err) {
        console.error('[MultiplayerManager] Failed to send to peer ' + peerId + ':', err);
      }
    } else {
      console.warn('[MultiplayerManager] No open connection to peer ' + peerId);
    }
  }

  _sendToConnection(conn, message) {
    if (!conn || !conn.open) return;
    try {
      conn.send(this._serializeMessage(message));
    } catch (err) {
      console.error('[MultiplayerManager] Send error:', err);
    }
  }

  _serializeMessage(message) {
    // Return as object (PeerJS handles JSON serialization)
    return message;
  }

  // ----------------------------------------------------------
  // Optimized Player Update Broadcast
  // ----------------------------------------------------------

  /**
   * Start sending position updates at 20Hz.
   * Requires localPlayerState to be set externally or via setLocalPlayerState().
   */
  startPositionSync(getStateCallback) {
    if (this._updateInterval) clearInterval(this._updateInterval);
    this._getLocalState = getStateCallback;

    this._updateInterval = setInterval(() => {
      if (!this._getLocalState) return;
      const state = this._getLocalState();
      if (!state) return;

      // Delta compression: only send changed values
      const delta = this._computeDelta(this._lastBroadcastedState, state);
      if (Object.keys(delta).length === 0) return;

      delta.id = this.localPlayerId;
      this._lastBroadcastedState = Object.assign({}, state);

      const message = { type: 'player_update', data: delta };

      if (this.isHost) {
        this.broadcast(message);
      } else {
        this.sendToHost(message);
      }
    }, this._positionUpdateInterval);
  }

  stopPositionSync() {
    if (this._updateInterval) {
      clearInterval(this._updateInterval);
      this._updateInterval = null;
    }
  }

  _computeDelta(last, current) {
    const delta = {};
    const posThreshold = 0.001;
    const rotThreshold = 0.001;

    if (!last.position || !current.position) {
      delta.position = current.position;
    } else {
      if (
        Math.abs(current.position.x - last.position.x) > posThreshold ||
        Math.abs(current.position.y - last.position.y) > posThreshold ||
        Math.abs(current.position.z - last.position.z) > posThreshold
      ) {
        delta.position = {
          x: Math.round(current.position.x * 1000) / 1000,
          y: Math.round(current.position.y * 1000) / 1000,
          z: Math.round(current.position.z * 1000) / 1000
        };
      }
    }

    if (!last.rotation || !current.rotation) {
      delta.rotation = current.rotation;
    } else {
      if (
        Math.abs(current.rotation.x - last.rotation.x) > rotThreshold ||
        Math.abs(current.rotation.y - last.rotation.y) > rotThreshold
      ) {
        delta.rotation = {
          x: Math.round(current.rotation.x * 1000) / 1000,
          y: Math.round(current.rotation.y * 1000) / 1000
        };
      }
    }

    if (last.state !== current.state) delta.state = current.state;
    if (last.flashlightOn !== current.flashlightOn) delta.flashlightOn = current.flashlightOn;
    if (typeof current.sanity !== 'undefined' && last.sanity !== current.sanity) delta.sanity = current.sanity;

    return delta;
  }

  // ----------------------------------------------------------
  // Host Authority
  // ----------------------------------------------------------

  _validateInteraction(peerId, interactData) {
    if (!this.isHost) return true;
    // Basic validation: player must be registered
    if (!this.players.has(peerId)) return false;
    // objectId and action must exist
    if (!interactData.objectId || !interactData.action) return false;
    return true;
  }

  sendAlisaUpdate(alisaData) {
    if (!this.isHost) return;
    this.broadcast({
      type: 'alisa_update',
      data: alisaData
    });
  }

  sendGameEvent(eventType, params) {
    if (!this.isHost) return;
    this.broadcast({
      type: 'game_event',
      data: { eventType, params }
    });
  }

  sendGameState(targetPeerId, gameState) {
    if (!this.isHost) return;
    this.sendToPeer(targetPeerId, {
      type: 'game_state',
      data: gameState
    });
  }

  // ----------------------------------------------------------
  // Lobby Management
  // ----------------------------------------------------------

  getLobbyState() {
    const lobbyPlayers = [];
    this.players.forEach((pData, pid) => {
      lobbyPlayers.push(Object.assign({}, pData, {
        ready: this.lobbyReadyStates.get(pid) || false,
        latency: this._pingMap.has(pid) ? (this._pingMap.get(pid).latency || 0) : 0
      }));
    });
    return {
      roomCode: this.roomCode,
      players: lobbyPlayers,
      isHost: this.isHost,
      playerCount: this.players.size,
      maxPlayers: this.maxPlayers
    };
  }

  setReady(ready) {
    this.lobbyReadyStates.set(this.localPlayerId, ready);
    this.broadcast({
      type: 'ready_state',
      data: { id: this.localPlayerId, ready }
    });
    if (!this.isHost) {
      this.sendToHost({
        type: 'ready_state',
        data: { id: this.localPlayerId, ready }
      });
    }
  }

  canStart() {
    if (!this.isHost) return false;
    if (this.players.size < 1) return false;
    let allReady = true;
    this.lobbyReadyStates.forEach((ready, pid) => {
      if (pid !== this.localPlayerId && !ready) {
        allReady = false;
      }
    });
    return allReady;
  }

  startGame(chapter, settings) {
    if (!this.isHost) return;
    this.broadcast({
      type: 'start_game',
      data: { chapter: chapter || 1, settings: settings || {} }
    });
    if (this.onStartGameCallback) {
      this.onStartGameCallback({ chapter: chapter || 1, settings: settings || {} });
    }
  }

  // ----------------------------------------------------------
  // Host Migration
  // ----------------------------------------------------------

  _attemptHostMigration() {
    // Find oldest connected peer (by joinTime)
    let oldestPeer = null;
    let oldestTime = Infinity;

    this.players.forEach((pData, pid) => {
      if (pid !== this.localPlayerId && pData.joinTime && pData.joinTime < oldestTime) {
        oldestTime = pData.joinTime;
        oldestPeer = pid;
      }
    });

    // Check if we are the oldest remaining player
    const localJoinTime = this.localPlayerData ? this.localPlayerData.joinTime : Infinity;
    const shouldMigrate = localJoinTime <= oldestTime || oldestPeer === null;

    if (shouldMigrate) {
      console.log('[MultiplayerManager] Host migration: this client is now the host.');
      this.isHost = true;
      if (this.localPlayerData) this.localPlayerData.isHost = true;

      // Update all remaining players
      this.broadcast({
        type: 'game_event',
        data: { eventType: 'host_migrated', params: { newHostId: this.localPlayerId } }
      });

      if (this.onHostMigratedCallback) {
        this.onHostMigratedCallback(this.localPlayerId);
      }
    } else {
      console.log('[MultiplayerManager] Host migration: waiting for new host ' + oldestPeer);
    }
  }

  // ----------------------------------------------------------
  // Disconnect Handling
  // ----------------------------------------------------------

  _startPingInterval() {
    if (this._pingInterval) clearInterval(this._pingInterval);
    this._pingInterval = setInterval(() => {
      this.connections.forEach((conn, peerId) => {
        if (conn.open) {
          const timestamp = Date.now();
          if (!this._pingMap.has(peerId)) this._pingMap.set(peerId, {});
          this._pingMap.get(peerId).sentAt = timestamp;
          this._sendToConnection(conn, {
            type: 'host_ping',
            data: { timestamp }
          });
        }
      });
    }, 5000);
  }

  _attemptPeerReconnect() {
    if (this._reconnectAttempts >= this._maxReconnectAttempts) {
      console.error('[MultiplayerManager] Max reconnect attempts reached.');
      if (this.onConnectionErrorCallback) {
        this.onConnectionErrorCallback('Lost connection to signaling server.', 'reconnect_failed');
      }
      return;
    }
    this._reconnectAttempts++;
    if (this.peer && !this.peer.destroyed) {
      try {
        this.peer.reconnect();
        console.log('[MultiplayerManager] Reconnect attempt ' + this._reconnectAttempts);
      } catch (err) {
        console.error('[MultiplayerManager] Reconnect failed:', err);
      }
    }
  }

  // ----------------------------------------------------------
  // Utilities
  // ----------------------------------------------------------

  _generateRoomCode() {
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const digits = '0123456789';
    let code = '';
    for (let i = 0; i < 4; i++) {
      code += letters.charAt(Math.floor(Math.random() * letters.length));
    }
    for (let i = 0; i < 2; i++) {
      code += digits.charAt(Math.floor(Math.random() * digits.length));
    }
    return code;
  }

  _validateRoomCode(code) {
    if (typeof code !== 'string') return false;
    return /^[A-Z]{4}[0-9]{2}$/.test(code.toUpperCase());
  }

  _parsePeerError(err) {
    const typeMessages = {
      'browser-incompatible': 'Your browser does not support WebRTC.',
      'disconnected': 'Disconnected from signaling server.',
      'invalid-id': 'Invalid room code.',
      'invalid-key': 'Invalid PeerJS API key.',
      'network': 'Network error. Check your connection.',
      'peer-unavailable': 'Room not found. Check the room code.',
      'ssl-unavailable': 'SSL required for this operation.',
      'server-error': 'Could not connect to signaling server.',
      'socket-error': 'Socket error occurred.',
      'socket-closed': 'Connection was closed unexpectedly.',
      'unavailable-id': 'Room code already in use.',
      'webrtc': 'WebRTC error occurred.'
    };
    return typeMessages[err.type] || (err.message || 'Unknown network error.');
  }

  _getHostId() {
    return this.roomCode; // Host peer ID is the room code
  }

  getLatency(peerId) {
    const info = this._pingMap.get(peerId);
    return info ? info.latency || 0 : 0;
  }

  getConnectedPlayerCount() {
    return this.players.size;
  }

  setLocalPosition(x, y, z) {
    this._localPosition = { x, y, z };
  }

  // ----------------------------------------------------------
  // Cleanup
  // ----------------------------------------------------------

  destroy() {
    this.stopPositionSync();
    if (this._pingInterval) {
      clearInterval(this._pingInterval);
      this._pingInterval = null;
    }
    this.connections.forEach((conn) => {
      try { conn.close(); } catch (e) {}
    });
    this.connections.clear();
    if (this.peer && !this.peer.destroyed) {
      try { this.peer.destroy(); } catch (e) {}
    }
    this.peer = null;
    this.players.clear();
    this.lobbyReadyStates.clear();
    this._pingMap.clear();
    this.isHost = false;
    this.roomCode = null;
    this.localPlayerId = null;
    this._reconnectAttempts = 0;
    this._lastBroadcastedState = {};
  }
}

// ============================================================
// SECTION 2: RemotePlayerManager
// ============================================================

class RemotePlayerManager {
  constructor(scene) {
    this.scene = scene;
    this.remotePlayers = new Map(); // id -> RemotePlayerObject
    this._clock = { lastTime: performance.now() };

    // Interpolation config
    this.interpolationFactor = 0.15;
    this.snapDistance = 8.0; // units - snap if too far behind
    this.extrapolationMaxTime = 200; // ms - max time to extrapolate

    // Animation config
    this._walkBobFrequency = 8.0; // Hz
    this._walkBobAmplitude = 0.04;
    this._runBobFrequency = 14.0;
    this._runBobAmplitude = 0.07;

    // Character color defaults
    this._characterColors = {
      default: 0x4a90d9,
      red: 0xe74c3c,
      green: 0x2ecc71,
      blue: 0x3498db,
      yellow: 0xf1c40f,
      purple: 0x9b59b6,
      orange: 0xe67e22
    };
  }

  // ----------------------------------------------------------
  // Create Remote Player
  // ----------------------------------------------------------

  createRemotePlayer(playerData) {
    const id = playerData.id;
    if (this.remotePlayers.has(id)) {
      console.warn('[RemotePlayerManager] Player ' + id + ' already exists. Updating instead.');
      return this.remotePlayers.get(id);
    }

    const colorKey = playerData.color || 'default';
    const color = typeof colorKey === 'number'
      ? colorKey
      : (this._characterColors[colorKey] || parseInt(colorKey.replace('#', '0x'), 16) || this._characterColors.default);

    // Root group
    const playerGroup = new THREE.Group();
    playerGroup.name = 'RemotePlayer_' + id;

    // Body (capsule approximation: cylinder + two hemispheres)
    const bodyMat = new THREE.MeshLambertMaterial({ color });

    const torsoGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 10);
    const torso = new THREE.Mesh(torsoGeo, bodyMat);
    torso.position.y = 0.7;
    torso.castShadow = true;
    playerGroup.add(torso);

    const bottomCapGeo = new THREE.SphereGeometry(0.3, 10, 6, 0, Math.PI * 2, 0, Math.PI / 2);
    const bottomCap = new THREE.Mesh(bottomCapGeo, bodyMat);
    bottomCap.position.y = 0.1;
    playerGroup.add(bottomCap);

    const topCapGeo = new THREE.SphereGeometry(0.3, 10, 6, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
    const topCap = new THREE.Mesh(topCapGeo, bodyMat);
    topCap.position.y = 1.3;
    playerGroup.add(topCap);

    // Head
    const headGeo = new THREE.SphereGeometry(0.22, 12, 8);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xffe0bd });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.65;
    head.castShadow = true;
    playerGroup.add(head);

    // Eyes (for facing direction indicator)
    const eyeGeo = new THREE.SphereGeometry(0.04, 6, 4);
    const eyeMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.08, 1.67, 0.19);
    playerGroup.add(leftEye);
    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    rightEye.position.set(0.08, 1.67, 0.19);
    playerGroup.add(rightEye);

    // Flashlight cone
    const flashlightGroup = new THREE.Group();
    flashlightGroup.position.set(0.2, 1.5, 0.3);

    const flashlightGeo = new THREE.CylinderGeometry(0.04, 0.07, 0.2, 8);
    const flashlightMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
    const flashlightMesh = new THREE.Mesh(flashlightGeo, flashlightMat);
    flashlightMesh.rotation.x = Math.PI / 2;
    flashlightGroup.add(flashlightMesh);

    // Spotlight for flashlight
    const spotlight = new THREE.SpotLight(0xfffde7, 1.5, 18, Math.PI / 9, 0.3, 1.5);
    spotlight.position.set(0, 0, 0);
    spotlight.target.position.set(0, 0, 1);
    flashlightGroup.add(spotlight);
    flashlightGroup.add(spotlight.target);

    playerGroup.add(flashlightGroup);

    // Name label (canvas sprite)
    const nameLabel = this._createNameLabel(playerData.name || 'Player', color);
    nameLabel.position.y = 2.2;
    playerGroup.add(nameLabel);

    // Sanity aura (invisible by default)
    const auraGeo = new THREE.SphereGeometry(0.5, 12, 8);
    const auraMat = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      transparent: true,
      opacity: 0.0,
      side: THREE.FrontSide,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const aura = new THREE.Mesh(auraGeo, auraMat);
    aura.position.y = 1.0;
    playerGroup.add(aura);

    this.scene.add(playerGroup);

    // Fade-in animation
    const allMeshes = [];
    playerGroup.traverse((obj) => {
      if (obj.isMesh) allMeshes.push(obj);
    });
    allMeshes.forEach((mesh) => {
      if (mesh.material) {
        mesh.material = mesh.material.clone();
        mesh.material.transparent = true;
        mesh.material.opacity = 0;
      }
    });

    const remotePlayer = {
      id,
      group: playerGroup,
      head,
      flashlightGroup,
      spotlight,
      nameLabel,
      aura,
      auraMat,
      allMeshes,

      // Interpolation state
      lastPosition: new THREE.Vector3(),
      targetPosition: new THREE.Vector3(),
      currentPosition: new THREE.Vector3(),
      lastRotationY: 0,
      targetRotationY: 0,
      currentRotationY: 0,
      lastHeadPitch: 0,
      targetHeadPitch: 0,

      // Animation state
      animState: 'idle',
      bobTime: Math.random() * Math.PI * 2,
      baseHeadY: 1.65,

      // Sync state
      lastUpdateTime: performance.now(),
      lastVelocity: new THREE.Vector3(),
      flashlightOn: true,
      sanity: 100,

      // Fade state
      fadeIn: true,
      fadeAlpha: 0,
      fadeOut: false
    };

    this.remotePlayers.set(id, remotePlayer);

    // Start fade-in
    this._animateFade(remotePlayer, true);

    return remotePlayer;
  }

  // ----------------------------------------------------------
  // Update Remote Player
  // ----------------------------------------------------------

  updateRemotePlayer(id, data) {
    const rp = this.remotePlayers.get(id);
    if (!rp) {
      // Auto-create if not exists (e.g., missed join event)
      this.createRemotePlayer({ id, name: 'Player', color: 'default', ...data });
      return;
    }

    const now = performance.now();

    // Store previous position for velocity estimation
    rp.lastPosition.copy(rp.targetPosition);

    // Update target position
    if (data.position) {
      rp.targetPosition.set(
        data.position.x,
        data.position.y,
        data.position.z
      );
      // Estimate velocity for extrapolation
      const dt = (now - rp.lastUpdateTime) / 1000;
      if (dt > 0) {
        rp.lastVelocity.subVectors(rp.targetPosition, rp.lastPosition).divideScalar(dt);
      }
    }

    // Update rotation targets
    if (data.rotation) {
      rp.targetRotationY = data.rotation.y;
      rp.targetHeadPitch = data.rotation.x;
    }

    // Flashlight state
    if (typeof data.flashlightOn !== 'undefined') {
      rp.flashlightOn = data.flashlightOn;
      rp.spotlight.visible = data.flashlightOn;
      rp.spotlight.intensity = data.flashlightOn ? 1.5 : 0;
    }

    // Animation state
    if (data.state) {
      rp.animState = data.state;
    }

    // Sanity visual effects
    if (typeof data.sanity !== 'undefined') {
      rp.sanity = data.sanity;
      this._updateSanityEffect(rp, data.sanity);
    }

    rp.lastUpdateTime = now;
  }

  // ----------------------------------------------------------
  // Remove Remote Player
  // ----------------------------------------------------------

  removeRemotePlayer(id) {
    const rp = this.remotePlayers.get(id);
    if (!rp) return;

    this._animateFade(rp, false, () => {
      this.scene.remove(rp.group);
      // Dispose geometries and materials
      rp.group.traverse((obj) => {
        if (obj.isMesh) {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach((m) => m.dispose());
            } else {
              obj.material.dispose();
            }
          }
        }
      });
      if (rp.nameLabel && rp.nameLabel.material) {
        if (rp.nameLabel.material.map) rp.nameLabel.material.map.dispose();
        rp.nameLabel.material.dispose();
      }
      this.remotePlayers.delete(id);
    });
  }

  // ----------------------------------------------------------
  // Update Loop
  // ----------------------------------------------------------

  update(deltaTime) {
    const now = performance.now();

    this.remotePlayers.forEach((rp) => {
      this._interpolatePlayer(rp, deltaTime, now);
      this._updateAnimation(rp, deltaTime);
    });
  }

  _interpolatePlayer(rp, deltaTime, now) {
    const timeSinceUpdate = now - rp.lastUpdateTime;

    // Snap if too far behind
    const distToTarget = rp.currentPosition.distanceTo(rp.targetPosition);
    if (distToTarget > this.snapDistance) {
      rp.currentPosition.copy(rp.targetPosition);
      rp.currentRotationY = rp.targetRotationY;
    } else {
      // Lerp position
      const lerpFactor = Math.min(1.0, this.interpolationFactor + deltaTime * 8);

      if (timeSinceUpdate < this.extrapolationMaxTime && distToTarget > 0.01) {
        // Normal interpolation
        rp.currentPosition.lerp(rp.targetPosition, lerpFactor);
      } else if (timeSinceUpdate >= this.extrapolationMaxTime && timeSinceUpdate < this.extrapolationMaxTime * 2) {
        // Brief extrapolation when no update received
        const extraDt = (timeSinceUpdate - this.extrapolationMaxTime) / 1000;
        const extrapolated = rp.targetPosition.clone().addScaledVector(rp.lastVelocity, extraDt * 0.3);
        rp.currentPosition.lerp(extrapolated, lerpFactor * 0.5);
      } else {
        // No extrapolation, just lerp to last known
        rp.currentPosition.lerp(rp.targetPosition, lerpFactor * 0.3);
      }

      // Slerp rotation (approximate with lerp on euler angle)
      const rotDiff = rp.targetRotationY - rp.currentRotationY;
      // Handle wrapping
      let wrappedDiff = rotDiff;
      if (wrappedDiff > Math.PI) wrappedDiff -= Math.PI * 2;
      if (wrappedDiff < -Math.PI) wrappedDiff += Math.PI * 2;
      rp.currentRotationY += wrappedDiff * lerpFactor;

      // Interpolate head pitch
      rp.lastHeadPitch += (rp.targetHeadPitch - rp.lastHeadPitch) * lerpFactor;
    }

    // Apply to Three.js object
    rp.group.position.copy(rp.currentPosition);
    rp.group.rotation.y = rp.currentRotationY;
    if (rp.head) rp.head.rotation.x = rp.lastHeadPitch;
  }

  _updateAnimation(rp, deltaTime) {
    const state = rp.animState;
    let bobFreq = 0;
    let bobAmp = 0;

    if (state === 'walking') {
      bobFreq = this._walkBobFrequency;
      bobAmp = this._walkBobAmplitude;
    } else if (state === 'running') {
      bobFreq = this._runBobFrequency;
      bobAmp = this._runBobAmplitude;
    } else if (state === 'crouching') {
      bobFreq = this._walkBobFrequency * 0.5;
      bobAmp = this._walkBobAmplitude * 0.5;
      rp.group.scale.y = THREE.MathUtils.lerp(rp.group.scale.y, 0.65, 0.1);
    }

    if (state !== 'crouching') {
      rp.group.scale.y = THREE.MathUtils.lerp(rp.group.scale.y, 1.0, 0.1);
    }

    if (bobFreq > 0 && bobAmp > 0) {
      rp.bobTime += deltaTime * bobFreq;
      const bobOffset = Math.sin(rp.bobTime) * bobAmp;
      if (rp.head) rp.head.position.y = rp.baseHeadY + bobOffset;
      rp.group.position.y = rp.currentPosition.y + Math.abs(Math.sin(rp.bobTime * 0.5)) * bobAmp * 0.3;
    } else {
      if (rp.head) rp.head.position.y = THREE.MathUtils.lerp(rp.head.position.y, rp.baseHeadY, 0.1);
    }
  }

  _updateSanityEffect(rp, sanity) {
    if (!rp.auraMat) return;
    // Low sanity: red aura becomes visible
    const threshold = 50;
    if (sanity < threshold) {
      const t = 1.0 - (sanity / threshold);
      rp.auraMat.opacity = t * 0.25;
      rp.aura.scale.setScalar(1 + t * 0.3);
    } else {
      rp.auraMat.opacity = 0;
      rp.aura.scale.setScalar(1);
    }

    // Tint body color at very low sanity
    if (sanity < 20) {
      const t = 1.0 - (sanity / 20);
      rp.allMeshes.forEach((mesh) => {
        if (mesh.material && mesh.material.color) {
          // Shift towards dark red
          mesh.material.color.lerp(new THREE.Color(0.4, 0, 0), t * 0.5);
        }
      });
    }
  }

  // ----------------------------------------------------------
  // Name Label
  // ----------------------------------------------------------

  _createNameLabel(name, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    this._roundRect(ctx, 8, 8, 240, 48, 8);
    ctx.fill();

    // Border color based on player color
    const hexColor = '#' + color.toString(16).padStart(6, '0');
    ctx.strokeStyle = hexColor;
    ctx.lineWidth = 2;
    this._roundRect(ctx, 8, 8, 240, 48, 8);
    ctx.stroke();

    // Text
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(name.substring(0, 14), 128, 32);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      depthWrite: false
    });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(1.2, 0.3, 1);
    return sprite;
  }

  _roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  // ----------------------------------------------------------
  // Fade Animation
  // ----------------------------------------------------------

  _animateFade(rp, fadeIn, onComplete) {
    const duration = 800; // ms
    const startTime = performance.now();
    const startAlpha = fadeIn ? 0 : 1;
    const endAlpha = fadeIn ? 1 : 0;

    const animate = () => {
      const elapsed = performance.now() - startTime;
      const t = Math.min(1, elapsed / duration);
      const alpha = startAlpha + (endAlpha - startAlpha) * t;

      rp.allMeshes.forEach((mesh) => {
        if (mesh.material) {
          mesh.material.opacity = alpha;
          mesh.material.transparent = alpha < 1.0;
        }
      });

      if (rp.nameLabel && rp.nameLabel.material) {
        rp.nameLabel.material.opacity = alpha;
      }

      if (t < 1) {
        requestAnimationFrame(animate);
      } else {
        if (onComplete) onComplete();
      }
    };
    requestAnimationFrame(animate);
  }

  // ----------------------------------------------------------
  // Accessors
  // ----------------------------------------------------------

  getRemotePlayer(id) {
    return this.remotePlayers.get(id);
  }

  hasPlayer(id) {
    return this.remotePlayers.has(id);
  }

  getAllPlayers() {
    return Array.from(this.remotePlayers.values());
  }

  updateNameLabel(id, name) {
    const rp = this.remotePlayers.get(id);
    if (!rp) return;
    // Re-create name label
    const color = rp.allMeshes.length > 0 && rp.allMeshes[0].material
      ? rp.allMeshes[0].material.color.getHex()
      : 0x4a90d9;
    rp.group.remove(rp.nameLabel);
    if (rp.nameLabel.material.map) rp.nameLabel.material.map.dispose();
    rp.nameLabel.material.dispose();
    const newLabel = this._createNameLabel(name, color);
    newLabel.position.y = 2.2;
    rp.group.add(newLabel);
    rp.nameLabel = newLabel;
  }

  dispose() {
    this.remotePlayers.forEach((rp, id) => {
      this.scene.remove(rp.group);
      rp.group.traverse((obj) => {
        if (obj.isMesh) {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach((m) => m.dispose());
            else obj.material.dispose();
          }
        }
      });
    });
    this.remotePlayers.clear();
  }
}

// ============================================================
// SECTION 3: ChatSystem
// ============================================================

class ChatSystem {
  constructor(multiplayerManager, hudManager) {
    this.mp = multiplayerManager;
    this.hud = hudManager;

    // Walkie-talkie config
    this.walkieRange = 20; // units
    this.walkieEquipped = false;

    // Chat state
    this._isOpen = false;
    this._messageHistory = [];
    this._maxHistory = 100;
    this._inputCallback = null;
    this._localPosition = { x: 0, y: 0, z: 0 };

    // Spam protection
    this._lastMessageTime = 0;
    this._messageCooldown = 500; // ms
    this._maxMessageLength = 150;

    // Quick messages
    this.quickMessages = [
      'Â¡Por aquÃ­!',
      'Â¡Cuidado!',
      'Necesito ayuda',
      'Escucho algo',
      'La puerta estÃ¡ cerrada',
      'Mi cordura baja',
      'Â¡Alisa estÃ¡ aquÃ­!',
      'Reagruparse'
    ];

    // DOM elements (created lazily)
    this._chatContainer = null;
    this._chatInput = null;
    this._chatMessages = null;
    this._quickMessagePanel = null;

    // Multiplayer callback wiring
    if (this.mp) {
      this.mp.onChatMessageCallback = (peerId, data) => {
        this._handleIncomingMessage(peerId, data);
      };
    }

    // Keyboard listener
    this._boundKeyDown = this._onKeyDown.bind(this);
    document.addEventListener('keydown', this._boundKeyDown);

    // Initialize UI
    this._initChatUI();
  }

  // ----------------------------------------------------------
  // UI Init
  // ----------------------------------------------------------

  _initChatUI() {
    // Create chat container
    this._chatContainer = document.createElement('div');
    this._chatContainer.id = 'chat-system-container';
    Object.assign(this._chatContainer.style, {
      position: 'fixed',
      bottom: '120px',
      left: '20px',
      width: '360px',
      zIndex: '1000',
      fontFamily: '\'Courier New\', monospace',
      pointerEvents: 'none',
      userSelect: 'none'
    });

    // Messages display
    this._chatMessages = document.createElement('div');
    this._chatMessages.id = 'chat-messages';
    Object.assign(this._chatMessages.style, {
      maxHeight: '200px',
      overflowY: 'auto',
      marginBottom: '8px',
      display: 'flex',
      flexDirection: 'column',
      gap: '3px'
    });
    this._chatContainer.appendChild(this._chatMessages);

    // Input area
    const inputWrapper = document.createElement('div');
    inputWrapper.id = 'chat-input-wrapper';
    Object.assign(inputWrapper.style, {
      display: 'none',
      background: 'rgba(0,0,0,0.75)',
      border: '1px solid rgba(255,255,255,0.3)',
      borderRadius: '4px',
      padding: '6px 8px',
      pointerEvents: 'all'
    });

    this._chatInput = document.createElement('input');
    this._chatInput.type = 'text';
    this._chatInput.placeholder = 'Escribe un mensaje...';
    this._chatInput.maxLength = this._maxMessageLength;
    Object.assign(this._chatInput.style, {
      width: '100%',
      background: 'transparent',
      border: 'none',
      outline: 'none',
      color: '#ffffff',
      fontSize: '13px',
      fontFamily: '\'Courier New\', monospace',
      boxSizing: 'border-box'
    });

    this._chatInput.addEventListener('keydown', (e) => {
      e.stopPropagation();
      if (e.key === 'Enter') {
        e.preventDefault();
        const text = this._chatInput.value.trim();
        if (text.length > 0) {
          this.sendMessage(text);
        }
        this.closeChat();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        this.closeChat();
      }
    });

    inputWrapper.appendChild(this._chatInput);
    this._chatInputWrapper = inputWrapper;
    this._chatContainer.appendChild(inputWrapper);

    // Quick messages panel
    this._quickMessagePanel = document.createElement('div');
    this._quickMessagePanel.id = 'chat-quick-messages';
    Object.assign(this._quickMessagePanel.style, {
      display: 'none',
      background: 'rgba(0,0,0,0.85)',
      border: '1px solid rgba(255,180,0,0.4)',
      borderRadius: '6px',
      padding: '8px',
      pointerEvents: 'all',
      marginTop: '4px'
    });

    const qmTitle = document.createElement('div');
    qmTitle.textContent = 'Mensajes RÃ¡pidos [Q]';
    Object.assign(qmTitle.style, {
      color: '#f1c40f',
      fontSize: '11px',
      marginBottom: '6px',
      textTransform: 'uppercase',
      letterSpacing: '1px'
    });
    this._quickMessagePanel.appendChild(qmTitle);

    const qmGrid = document.createElement('div');
    Object.assign(qmGrid.style, {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr',
      gap: '4px'
    });

    this.quickMessages.forEach((msg, index) => {
      const btn = document.createElement('button');
      btn.textContent = (index + 1 <= 9 ? (index + 1) + '. ' : '') + msg;
      Object.assign(btn.style, {
        background: 'rgba(255,255,255,0.07)',
        border: '1px solid rgba(255,255,255,0.2)',
        borderRadius: '3px',
        color: '#ddd',
        fontSize: '11px',
        padding: '4px 6px',
        cursor: 'pointer',
        textAlign: 'left',
        fontFamily: '\'Courier New\', monospace',
        transition: 'background 0.15s'
      });
      btn.addEventListener('mouseenter', () => {
        btn.style.background = 'rgba(255,255,255,0.15)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = 'rgba(255,255,255,0.07)';
      });
      btn.addEventListener('click', () => {
        this.sendMessage(msg);
        this.closeQuickMessages();
      });
      qmGrid.appendChild(btn);
    });
    this._quickMessagePanel.appendChild(qmGrid);
    this._chatContainer.appendChild(this._quickMessagePanel);

    document.body.appendChild(this._chatContainer);
  }

  // ----------------------------------------------------------
  // Send Message
  // ----------------------------------------------------------

  sendMessage(text) {
    if (!text || typeof text !== 'string') return;
    text = text.trim().substring(0, this._maxMessageLength);
    if (text.length === 0) return;

    // Spam protection
    const now = Date.now();
    if (now - this._lastMessageTime < this._messageCooldown) return;
    this._lastMessageTime = now;

    if (!this.mp) return;

    const senderName = this.mp.localPlayerData
      ? (this.mp.localPlayerData.name || 'Player')
      : 'Player';
    const senderId = this.mp.localPlayerId;

    const messageData = {
      sender: senderName,
      senderId: senderId,
      message: text,
      timestamp: now
    };

    // Range-based delivery check
    const isProximityMessage = !this.walkieEquipped;

    // Display locally immediately
    this.receiveMessage(senderName, text, senderId, true);

    // Broadcast to network
    if (this.mp.isHost) {
      // Host broadcasts to all clients with range data
      this.mp.broadcast({
        type: 'chat_message',
        data: Object.assign({}, messageData, {
          senderPosition: this.mp._localPosition,
          proximityOnly: isProximityMessage
        })
      });
    } else {
      this.mp.sendToHost({
        type: 'chat_message',
        data: Object.assign({}, messageData, {
          senderPosition: this.mp._localPosition,
          proximityOnly: isProximityMessage
        })
      });
    }
  }

  // ----------------------------------------------------------
  // Send Quick Message
  // ----------------------------------------------------------

  sendQuickMessage(index) {
    if (index >= 0 && index < this.quickMessages.length) {
      this.sendMessage(this.quickMessages[index]);
    }
  }

  // ----------------------------------------------------------
  // Receive Message (display)
  // ----------------------------------------------------------

  receiveMessage(sender, text, senderId, isLocal) {
    // Range check for non-local, proximity-only messages
    // (This would be called after host has already filtered)

    const timestamp = new Date();
    const timeStr = timestamp.getHours().toString().padStart(2, '0') + ':'
      + timestamp.getMinutes().toString().padStart(2, '0');

    const entry = {
      sender,
      text,
      senderId,
      isLocal,
      time: timeStr,
      id: Date.now() + '_' + Math.random()
    };

    this._messageHistory.push(entry);
    if (this._messageHistory.length > this._maxHistory) {
      this._messageHistory.shift();
    }

    this._renderMessage(entry);

    // Delegate to HUD if available
    if (this.hud && typeof this.hud.showChatMessage === 'function') {
      this.hud.showChatMessage(sender, text, isLocal);
    }
  }

  _handleIncomingMessage(peerId, data) {
    if (!data || !data.message || !data.sender) return;

    // Proximity check
    if (data.proximityOnly && !this.walkieEquipped) {
      if (data.senderPosition) {
        const dist = this._distanceTo(data.senderPosition);
        if (dist > this.walkieRange) return;
      }
    }

    this.receiveMessage(data.sender, data.message, data.senderId || peerId, false);
  }

  _renderMessage(entry) {
    const el = document.createElement('div');
    Object.assign(el.style, {
      background: entry.isLocal ? 'rgba(52, 152, 219, 0.25)' : 'rgba(0,0,0,0.6)',
      border: entry.isLocal
        ? '1px solid rgba(52, 152, 219, 0.5)'
        : '1px solid rgba(255,255,255,0.1)',
      borderRadius: '4px',
      padding: '4px 8px',
      fontSize: '12px',
      color: '#e0e0e0',
      lineHeight: '1.4',
      wordBreak: 'break-word',
      animation: 'chatMsgFadeIn 0.2s ease'
    });

    const senderSpan = document.createElement('span');
    senderSpan.textContent = entry.isLocal ? 'TÃº' : entry.sender;
    Object.assign(senderSpan.style, {
      color: entry.isLocal ? '#3498db' : '#f1c40f',
      fontWeight: 'bold',
      marginRight: '6px'
    });

    const timeSpan = document.createElement('span');
    timeSpan.textContent = entry.time;
    Object.assign(timeSpan.style, {
      color: '#666',
      fontSize: '10px',
      marginLeft: '4px'
    });

    const textSpan = document.createElement('span');
    textSpan.textContent = entry.text;

    el.appendChild(senderSpan);
    el.appendChild(textSpan);
    el.appendChild(timeSpan);

    this._chatMessages.appendChild(el);
    this._chatMessages.scrollTop = this._chatMessages.scrollHeight;

    // Auto-fade old messages
    setTimeout(() => {
      el.style.transition = 'opacity 1s ease';
      el.style.opacity = '0.4';
    }, 8000);
    setTimeout(() => {
      if (el.parentNode) el.parentNode.removeChild(el);
    }, 30000);
  }

  // ----------------------------------------------------------
  // Chat Input
  // ----------------------------------------------------------

  openChat() {
    if (this._isOpen) return;
    this._isOpen = true;
    this._chatInputWrapper.style.display = 'block';
    this._chatContainer.style.pointerEvents = 'all';
    this._chatInput.value = '';
    this._chatInput.focus();

    // Pause game input (dispatch event for game to handle)
    window.dispatchEvent(new CustomEvent('chatOpened'));
  }

  closeChat() {
    if (!this._isOpen) return;
    this._isOpen = false;
    this._chatInputWrapper.style.display = 'none';
    this._chatContainer.style.pointerEvents = 'none';
    this._chatInput.blur();
    this.closeQuickMessages();

    // Return focus to game
    window.dispatchEvent(new CustomEvent('chatClosed'));
  }

  openQuickMessages() {
    this._quickMessagePanel.style.display = 'block';
    this._chatContainer.style.pointerEvents = 'all';
    window.dispatchEvent(new CustomEvent('chatOpened'));
  }

  closeQuickMessages() {
    this._quickMessagePanel.style.display = 'none';
    if (!this._isOpen) {
      this._chatContainer.style.pointerEvents = 'none';
      window.dispatchEvent(new CustomEvent('chatClosed'));
    }
  }

  toggleQuickMessages() {
    if (this._quickMessagePanel.style.display === 'none') {
      this.openQuickMessages();
    } else {
      this.closeQuickMessages();
    }
  }

  isOpen() {
    return this._isOpen || this._quickMessagePanel.style.display !== 'none';
  }

  // ----------------------------------------------------------
  // Key Handling
  // ----------------------------------------------------------

  _onKeyDown(e) {
    // T: open text chat
    if (e.code === 'KeyT' && !this._isOpen) {
      e.preventDefault();
      this.openChat();
      return;
    }

    // Q: open quick messages
    if (e.code === 'KeyQ' && !this._isOpen) {
      e.preventDefault();
      this.toggleQuickMessages();
      return;
    }

    // Number keys 1-8 for quick messages when quick panel is open
    if (this._quickMessagePanel.style.display !== 'none') {
      const numKey = parseInt(e.key);
      if (!isNaN(numKey) && numKey >= 1 && numKey <= this.quickMessages.length) {
        e.preventDefault();
        this.sendQuickMessage(numKey - 1);
        this.closeQuickMessages();
        return;
      }
      if (e.key === 'Escape') {
        this.closeQuickMessages();
      }
    }
  }

  // ----------------------------------------------------------
  // Walkie-Talkie
  // ----------------------------------------------------------

  setWalkieEquipped(equipped) {
    this.walkieEquipped = equipped;
    if (equipped) {
      this._showSystemMessage('ð» Walkie-talkie equipado â Alcance ilimitado');
    } else {
      this._showSystemMessage('ð» Walkie-talkie guardado â Alcance: ' + this.walkieRange + ' unidades');
    }
  }

  setLocalPosition(x, y, z) {
    this._localPosition = { x, y, z };
    if (this.mp) this.mp.setLocalPosition(x, y, z);
  }

  _distanceTo(pos) {
    if (!pos) return 0;
    const dx = pos.x - this._localPosition.x;
    const dy = pos.y - this._localPosition.y;
    const dz = pos.z - this._localPosition.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  // ----------------------------------------------------------
  // System Messages
  // ----------------------------------------------------------

  showSystemMessage(text) {
    this._showSystemMessage(text);
  }

  _showSystemMessage(text) {
    const el = document.createElement('div');
    Object.assign(el.style, {
      background: 'rgba(0,0,0,0.7)',
      border: '1px solid rgba(255,200,0,0.3)',
      borderRadius: '4px',
      padding: '4px 8px',
      fontSize: '11px',
      color: '#aaa',
      fontStyle: 'italic',
      wordBreak: 'break-word'
    });
    el.textContent = 'â ' + text;
    this._chatMessages.appendChild(el);
    this._chatMessages.scrollTop = this._chatMessages.scrollHeight;
    setTimeout(() => {
      el.style.transition = 'opacity 1s ease';
      el.style.opacity = '0';
    }, 6000);
    setTimeout(() => {
      if (el.parentNode) el.parentNode.removeChild(el);
    }, 7000);
  }

  // ----------------------------------------------------------
  // Player join/leave notifications
  // ----------------------------------------------------------

  notifyPlayerJoined(playerName) {
    this._showSystemMessage(playerName + ' se ha unido a la partida.');
  }

  notifyPlayerLeft(playerName) {
    this._showSystemMessage(playerName + ' ha abandonado la partida.');
  }

  notifyHostMigration(newHostName) {
    this._showSystemMessage('El anfitriÃ³n ha cambiado a ' + newHostName + '.');
  }

  // ----------------------------------------------------------
  // Message History
  // ----------------------------------------------------------

  getHistory() {
    return this._messageHistory.slice();
  }

  clearHistory() {
    this._messageHistory = [];
    while (this._chatMessages.firstChild) {
      this._chatMessages.removeChild(this._chatMessages.firstChild);
    }
  }

  // ----------------------------------------------------------
  // Cleanup
  // ----------------------------------------------------------

  destroy() {
    document.removeEventListener('keydown', this._boundKeyDown);
    if (this._chatContainer && this._chatContainer.parentNode) {
      this._chatContainer.parentNode.removeChild(this._chatContainer);
    }
    this._chatContainer = null;
    this._chatInput = null;
    this._chatMessages = null;
    this._quickMessagePanel = null;
    this._messageHistory = [];
    if (this.mp) {
      this.mp.onChatMessageCallback = null;
    }
  }
}

// ============================================================
// CSS Injection for chat animations
// ============================================================

(function injectChatStyles() {
  if (document.getElementById('chat-system-styles')) return;
  const style = document.createElement('style');
  style.id = 'chat-system-styles';
  style.textContent = [
    '@keyframes chatMsgFadeIn {',
    '  from { opacity: 0; transform: translateY(4px); }',
    '  to   { opacity: 1; transform: translateY(0); }',
    '}',
    '#chat-messages::-webkit-scrollbar { width: 4px; }',
    '#chat-messages::-webkit-scrollbar-track { background: transparent; }',
    '#chat-messages::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }',
    '#chat-input-wrapper input::placeholder { color: rgba(255,255,255,0.35); }'
  ].join('\n');
  document.head.appendChild(style);
})();

// ============================================================
// Network Helper: ensure PeerJS is loaded from CDN
// ============================================================

function ensurePeerJS(callback) {
  if (typeof Peer !== 'undefined') {
    callback();
    return;
  }
  const script = document.createElement('script');
  script.src = 'https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js';
  script.onload = () => {
    console.log('[Network] PeerJS loaded from CDN.');
    callback();
  };
  script.onerror = () => {
    console.error('[Network] Failed to load PeerJS from CDN.');
    if (typeof callback === 'function') callback(new Error('PeerJS CDN load failed'));
  };
  document.head.appendChild(script);
}

// ============================================================
// NetworkingSystem: Facade / Top-level integration
// ============================================================

class NetworkingSystem {
  constructor() {
    this.mp = null;
    this.remotePlayerManager = null;
    this.chat = null;
    this._scene = null;
    this._hudManager = null;
    this._ready = false;
    this._loadCallbacks = [];
  }

  init(scene, hudManager) {
    this._scene = scene;
    this._hudManager = hudManager;

    ensurePeerJS(() => {
      this._ready = true;
      this.mp = new MultiplayerManager();
      this.remotePlayerManager = new RemotePlayerManager(scene);
      this.chat = new ChatSystem(this.mp, hudManager);

      // Wire up player join/leave to RemotePlayerManager and Chat
      this.mp.onPlayerJoinCallback = (peerId, playerData) => {
        if (peerId !== this.mp.localPlayerId) {
          this.remotePlayerManager.createRemotePlayer(playerData);
          this.chat.notifyPlayerJoined(playerData.name || 'Player');
        }
      };

      this.mp.onPlayerLeaveCallback = (peerId, playerData) => {
        this.remotePlayerManager.removeRemotePlayer(peerId);
        if (playerData) this.chat.notifyPlayerLeft(playerData.name || 'Player');
      };

      this.mp.onPlayerUpdateCallback = (peerId, data) => {
        this.remotePlayerManager.updateRemotePlayer(peerId, data);
      };

      this.mp.onHostMigratedCallback = (newHostId) => {
        const newHostData = this.mp.players.get(newHostId);
        const name = newHostData ? (newHostData.name || newHostId) : newHostId;
        this.chat.notifyHostMigration(name);
      };

      this._loadCallbacks.forEach((cb) => cb());
      this._loadCallbacks = [];
    });
  }

  onReady(callback) {
    if (this._ready) {
      callback();
    } else {
      this._loadCallbacks.push(callback);
    }
  }

  update(deltaTime) {
    if (this.remotePlayerManager) {
      this.remotePlayerManager.update(deltaTime);
    }
  }

  destroy() {
    if (this.mp) this.mp.destroy();
    if (this.remotePlayerManager) this.remotePlayerManager.dispose();
    if (this.chat) this.chat.destroy();
    this.mp = null;
    this.remotePlayerManager = null;
    this.chat = null;
    this._ready = false;
  }
}

// ============================================================
// Exports (global for browser use)
// ============================================================

if (typeof window !== 'undefined') {
  window.MultiplayerManager = MultiplayerManager;
  window.RemotePlayerManager = RemotePlayerManager;
  window.ChatSystem = ChatSystem;
  window.NetworkingSystem = NetworkingSystem;
  window.ensurePeerJS = ensurePeerJS;
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = { MultiplayerManager, RemotePlayerManager, ChatSystem, NetworkingSystem, ensurePeerJS };
}

// ========== MAIN GAME & INITIALIZATION ==========
// ============================================================
// El Susurro de la Inocente â Main Game Initialization
// Game Loop & Event Wiring
// ============================================================

class Game {
  constructor() {
    this.renderer    = null;
    this.audio       = null;
    this.player      = null;
    this.state       = null;
    this.alisa       = null;
    this.interaction = null;
    this.hud         = null;
    this.multiplayer = null;
    this.remotePlayers = null;
    this.chat        = null;
    this.clock       = (typeof THREE !== 'undefined') ? new THREE.Clock() : null;
    this.isRunning   = false;
    this.isPaused    = false;
    this.isMultiplayer = false;
    this.isHost      = false;
    this.currentChapter = 0;
    this.chapter1Objectives = [];
    this.currentObjectiveIndex = 0;
    this.sanity      = 100;
    this.flashlightBattery = 100;
    this.flashlightOn = false;
    this.nearAlisa   = false;
    this.inLitArea   = false;
    this.usingLibro  = false;
    this.settings    = {};
    this.keysDown    = {};
    this.animFrameId = null;
    this.menuCameraAngle = 0;
    this.paranormalCooldown = 0;
    this.nearPlayers = 0;
    this.inventoryOpen = false;
    this.loadingProgress = 0;
    this._audioStarted = false;
    this._boundGameLoop = this.gameLoop.bind(this);
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // INIT
  // âââââââââââââââââââââââââââââââââââââââââââââ
  async init() {
    try {
      this.showLoadingScreen();
      this.loadSettings();
      this.setLoadingProgress(5, 'Initializing audio engine...');

      // Audio
      try {
        if (typeof AudioEngine !== 'undefined') {
          this.audio = new AudioEngine();
          await this.audio.init();
        } else {
          this.audio = this._createFallbackAudio();
        }
      } catch (e) {
        console.warn('[Game] AudioEngine init failed, using fallback:', e);
        this.audio = this._createFallbackAudio();
      }
      this.setLoadingProgress(15, 'Building renderer...');

      // Renderer
      try {
        if (typeof GameRenderer !== 'undefined') {
          this.renderer = new GameRenderer();
          await this.renderer.init();
        } else {
          this.renderer = this._createFallbackRenderer();
        }
      } catch (e) {
        console.warn('[Game] GameRenderer init failed, using fallback:', e);
        this.renderer = this._createFallbackRenderer();
      }
      this.setLoadingProgress(30, 'Constructing orphanage...');

      // Level
      try {
        if (typeof createOrphanageLevel !== 'undefined' && this.renderer.scene) {
          await createOrphanageLevel(this.renderer.scene);
        }
      } catch (e) {
        console.warn('[Game] createOrphanageLevel failed:', e);
      }
      this.setLoadingProgress(50, 'Setting up post-processing...');

      // Post-processing
      try {
        if (this.renderer.setupPostProcessing) {
          this.renderer.setupPostProcessing();
        }
      } catch (e) {
        console.warn('[Game] Post-processing setup failed:', e);
      }
      this.setLoadingProgress(60, 'Initializing game state...');

      // Game State
      try {
        if (typeof GameStateManager !== 'undefined') {
          this.state = new GameStateManager();
          await this.state.init();
        } else {
          this.state = this._createFallbackState();
        }
      } catch (e) {
        console.warn('[Game] GameStateManager failed:', e);
        this.state = this._createFallbackState();
      }
      this.setLoadingProgress(65, 'Initializing player...');

      // Player
      try {
        if (typeof PlayerController !== 'undefined') {
          this.player = new PlayerController(this.renderer ? this.renderer.camera : null, this.renderer ? this.renderer.scene : null);
          if (this.player.init) await this.player.init();
        } else {
          this.player = this._createFallbackPlayer();
        }
      } catch (e) {
        console.warn('[Game] PlayerController failed:', e);
        this.player = this._createFallbackPlayer();
      }
      this.setLoadingProgress(72, 'Waking Alisa...');

      // Alisa AI
      try {
        if (typeof AlisaAI !== 'undefined') {
          this.alisa = new AlisaAI(this.renderer ? this.renderer.scene : null, this.player);
          if (this.alisa.init) await this.alisa.init();
        } else {
          this.alisa = this._createFallbackAlisa();
        }
      } catch (e) {
        console.warn('[Game] AlisaAI failed:', e);
        this.alisa = this._createFallbackAlisa();
      }
      this.setLoadingProgress(78, 'Setting up interactions...');

      // Interaction System
      try {
        if (typeof InteractionSystem !== 'undefined') {
          this.interaction = new InteractionSystem(this.player, this.renderer ? this.renderer.scene : null);
          if (this.interaction.init) await this.interaction.init();
        } else {
          this.interaction = this._createFallbackInteraction();
        }
      } catch (e) {
        console.warn('[Game] InteractionSystem failed:', e);
        this.interaction = this._createFallbackInteraction();
      }
      this.setLoadingProgress(84, 'Booting HUD...');

      // HUD
      try {
        if (typeof HUDManager !== 'undefined') {
          this.hud = new HUDManager();
          if (this.hud.init) await this.hud.init();
        } else {
          this.hud = this._createFallbackHUD();
        }
      } catch (e) {
        console.warn('[Game] HUDManager failed:', e);
        this.hud = this._createFallbackHUD();
      }
      this.setLoadingProgress(88, 'Connecting multiplayer...');

      // Multiplayer (optional)
      try {
        if (typeof MultiplayerManager !== 'undefined') {
          this.multiplayer = new MultiplayerManager();
          if (this.multiplayer.init) await this.multiplayer.init();
        } else {
          this.multiplayer = this._createFallbackMultiplayer();
        }
      } catch (e) {
        console.warn('[Game] MultiplayerManager failed:', e);
        this.multiplayer = this._createFallbackMultiplayer();
      }

      // Remote Players
      try {
        if (typeof RemotePlayerManager !== 'undefined') {
          this.remotePlayers = new RemotePlayerManager(this.renderer ? this.renderer.scene : null);
          if (this.remotePlayers.init) await this.remotePlayers.init();
        } else {
          this.remotePlayers = this._createFallbackRemotePlayers();
        }
      } catch (e) {
        this.remotePlayers = this._createFallbackRemotePlayers();
      }

      // Chat
      try {
        if (typeof ChatSystem !== 'undefined') {
          this.chat = new ChatSystem();
          if (this.chat.init) await this.chat.init();
        } else {
          this.chat = this._createFallbackChat();
        }
      } catch (e) {
        this.chat = this._createFallbackChat();
      }
      this.setLoadingProgress(95, 'Wiring events...');

      // Events
      this.setupEventListeners();
      this.setLoadingProgress(100, 'Ready.');

      // Small delay so user sees 100%
      await this._sleep(400);
      this.hideLoadingScreen();
      this.showMainMenu();

      // Start background render loop for menu
      this._startMenuLoop();

    } catch (fatalErr) {
      console.error('[Game] Fatal init error:', fatalErr);
      this._showFatalError(fatalErr);
    }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // LOADING SCREEN
  // âââââââââââââââââââââââââââââââââââââââââââââ
  showLoadingScreen() {
    const el = document.getElementById('loading-screen');
    if (el) {
      el.style.display = 'flex';
      el.style.opacity = '1';
    }
  }

  hideLoadingScreen() {
    const el = document.getElementById('loading-screen');
    if (el) {
      el.style.transition = 'opacity 0.6s ease';
      el.style.opacity = '0';
      setTimeout(() => { el.style.display = 'none'; }, 700);
    }
  }

  setLoadingProgress(pct, message) {
    this.loadingProgress = pct;
    const bar  = document.getElementById('loading-bar-fill');
    const text = document.getElementById('loading-text');
    if (bar)  bar.style.width  = pct + '%';
    if (text) text.textContent = message || '';
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // MAIN MENU
  // âââââââââââââââââââââââââââââââââââââââââââââ
  showMainMenu() {
    this._hideAllScreens();
    const el = document.getElementById('main-menu');
    if (el) { el.style.display = 'flex'; el.style.opacity = '1'; }

    // Menu ambient
    try {
      if (this.audio && this.audio.playMusic) {
        this.audio.playMusic('menu_ambient', { loop: true, volume: 0.4 });
      }
    } catch (e) { /* silent */ }
  }

  _startMenuLoop() {
    const loop = () => {
      if (this.isRunning) return; // Full game loop takes over
      this.menuCameraAngle += 0.0003;
      if (this.renderer) {
        try {
          if (this.renderer.camera && !this.isRunning) {
            const r = 8;
            this.renderer.camera.position.x = Math.sin(this.menuCameraAngle) * r;
            this.renderer.camera.position.z = Math.cos(this.menuCameraAngle) * r;
            this.renderer.camera.position.y = 2;
            if (this.renderer.camera.lookAt) {
              this.renderer.camera.lookAt(0, 1, 0);
            }
          }
          if (this.renderer.render) this.renderer.render();
          else if (this.renderer.renderFrame) this.renderer.renderFrame();
        } catch (e) { /* silent */ }
      }
      this._menuLoopId = requestAnimationFrame(loop);
    };
    this._menuLoopId = requestAnimationFrame(loop);
  }

  _stopMenuLoop() {
    if (this._menuLoopId) {
      cancelAnimationFrame(this._menuLoopId);
      this._menuLoopId = null;
    }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // SOLO GAME
  // âââââââââââââââââââââââââââââââââââââââââââââ
  async startSoloGame(character) {
    try {
      this.isMultiplayer = false;
      this.isHost = true;
      this._stopMenuLoop();
      this._hideAllScreens();

      // Show brief transition
      this._showTransition('CapÃ­tulo 1: El Orfanato', 2000);

      // Init/reset player
      if (this.player) {
        if (this.player.setCharacter) this.player.setCharacter(character || 'default');
        if (this.player.spawn)       this.player.spawn({ x: 0, y: 1, z: 5 });
        else if (this.player.setPosition) this.player.setPosition(0, 1, 5);
      }

      // Reset state
      this.sanity = 100;
      this.flashlightBattery = 100;
      this.flashlightOn = false;
      this.currentChapter = 1;
      this.currentObjectiveIndex = 0;

      // Setup chapter
      this.setupChapter1();

      // HUD
      if (this.hud) {
        if (this.hud.show) this.hud.show();
        if (this.hud.setSanity) this.hud.setSanity(100);
        if (this.hud.setBattery) this.hud.setBattery(100);
        if (this.hud.setObjective) this.hud.setObjective(this.chapter1Objectives[0]);
      }

      // Audio
      try {
        if (this.audio) {
          if (this.audio.stopMusic) this.audio.stopMusic();
          if (this.audio.playAmbient) this.audio.playAmbient('orphanage_ambient', { loop: true, volume: 0.3 });
        }
      } catch (e) { /* silent */ }

      // Pointer lock
      await this._sleep(2100);
      this._requestPointerLock();

      // Start loop
      this.isRunning = true;
      if (this.clock && this.clock.start) this.clock.start();
      this.animFrameId = requestAnimationFrame(this._boundGameLoop);

    } catch (e) {
      console.error('[Game] startSoloGame failed:', e);
    }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // MULTIPLAYER
  // âââââââââââââââââââââââââââââââââââââââââââââ
  startMultiplayer() {
    this._hideAllScreens();
    const lobby = document.getElementById('lobby-screen');
    if (lobby) lobby.style.display = 'flex';

    try {
      if (this.multiplayer && this.multiplayer.connect) {
        this.multiplayer.connect();
      }
    } catch (e) {
      console.warn('[Game] Multiplayer connect failed:', e);
    }
  }

  async createRoom() {
    try {
      if (!this.multiplayer || !this.multiplayer.createRoom) {
        this._showNotification('Multiplayer no disponible');
        return;
      }
      const code = await this.multiplayer.createRoom();
      this.isHost = true;
      const codeEl = document.getElementById('room-code-display');
      if (codeEl) codeEl.textContent = code || '----';
      this._showNotification('Sala creada: ' + (code || '----'));
    } catch (e) {
      console.error('[Game] createRoom failed:', e);
      this._showNotification('Error al crear sala');
    }
  }

  async joinRoom(code) {
    try {
      if (!code) {
        const inp = document.getElementById('room-code-input');
        code = inp ? inp.value.trim() : '';
      }
      if (!code) { this._showNotification('Ingresa un cÃ³digo de sala'); return; }

      if (!this.multiplayer || !this.multiplayer.joinRoom) {
        this._showNotification('Multiplayer no disponible');
        return;
      }
      await this.multiplayer.joinRoom(code);
      this.isHost = false;

      // Sync state from host
      if (this.multiplayer.syncFromHost) {
        const hostState = await this.multiplayer.syncFromHost();
        if (hostState && this.state && this.state.applySync) {
          this.state.applySync(hostState);
        }
      }
      this._showNotification('Conectado a sala: ' + code);
    } catch (e) {
      console.error('[Game] joinRoom failed:', e);
      this._showNotification('Error al unirse a sala');
    }
  }

  async startMultiplayerGame() {
    try {
      this.isMultiplayer = true;
      this._hideAllScreens();

      // Host broadcasts start
      if (this.isHost && this.multiplayer && this.multiplayer.broadcast) {
        this.multiplayer.broadcast({ type: 'GAME_START', chapter: 1 });
      }

      // Each player gets a spawn offset
      const spawnIndex = (this.multiplayer && this.multiplayer.getPlayerIndex)
        ? this.multiplayer.getPlayerIndex() : 0;
      const spawnPositions = [
        { x: 0, y: 1, z: 5 },
        { x: 2, y: 1, z: 5 },
        { x: -2, y: 1, z: 5 },
        { x: 1, y: 1, z: 7 }
      ];
      const spawnPos = spawnPositions[spawnIndex % spawnPositions.length];

      if (this.player) {
        if (this.player.spawn) this.player.spawn(spawnPos);
        else if (this.player.setPosition) this.player.setPosition(spawnPos.x, spawnPos.y, spawnPos.z);
      }

      this.sanity = 100;
      this.flashlightBattery = 100;
      this.currentChapter = 1;
      this.currentObjectiveIndex = 0;
      this.setupChapter1();

      if (this.hud) {
        if (this.hud.show) this.hud.show();
        if (this.hud.setSanity) this.hud.setSanity(100);
        if (this.hud.setObjective) this.hud.setObjective(this.chapter1Objectives[0]);
      }

      try {
        if (this.audio && this.audio.playAmbient) {
          this.audio.playAmbient('orphanage_ambient', { loop: true, volume: 0.3 });
        }
      } catch (e) { /* silent */ }

      this._stopMenuLoop();
      this._requestPointerLock();
      this.isRunning = true;
      if (this.clock && this.clock.start) this.clock.start();
      this.animFrameId = requestAnimationFrame(this._boundGameLoop);

    } catch (e) {
      console.error('[Game] startMultiplayerGame failed:', e);
    }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // GAME LOOP
  // âââââââââââââââââââââââââââââââââââââââââââââ
  gameLoop() {
    if (!this.isRunning) return;
    this.animFrameId = requestAnimationFrame(this._boundGameLoop);

    let delta = 0;
    try {
      delta = this.clock ? this.clock.getDelta() : 0.016;
      // Guard against huge deltas (tab was hidden)
      if (delta > 0.2) delta = 0.2;
    } catch (e) { delta = 0.016; }

    if (this.isPaused) {
      // Still render so scene is visible behind pause menu
      try {
        if (this.renderer && this.renderer.render) this.renderer.render();
        else if (this.renderer && this.renderer.renderFrame) this.renderer.renderFrame();
      } catch (e) { /* silent */ }
      return;
    }

    try {
      // 1. Player input / movement
      if (this.player && this.player.update) {
        this.player.update(delta, this.keysDown);
      }
    } catch (e) { console.warn('[GameLoop] player.update:', e); }

    try {
      // 2. Collision detection
      if (this.player && this.player.resolveCollisions) {
        this.player.resolveCollisions();
      } else if (this.renderer && this.renderer.checkCollisions && this.player) {
        this.renderer.checkCollisions(this.player);
      }
    } catch (e) { console.warn('[GameLoop] collision:', e); }

    try {
      // 3. Interaction checks
      if (this.interaction && this.interaction.update) {
        this.interaction.update(delta);
      }
    } catch (e) { console.warn('[GameLoop] interaction.update:', e); }

    try {
      // 4. Alisa AI â host only in multiplayer
      if (this.alisa && this.alisa.update && (this.isHost || !this.isMultiplayer)) {
        const playerPos = this._getPlayerPosition();
        this.alisa.update(delta, playerPos);
        this.nearAlisa = this.alisa.isNearPlayer
          ? this.alisa.isNearPlayer(playerPos, 4)
          : false;
      }
    } catch (e) { console.warn('[GameLoop] alisa.update:', e); }

    try {
      // 5. Paranormal events
      this._updateParanormalEvents(delta);
    } catch (e) { console.warn('[GameLoop] paranormal:', e); }

    try {
      // 6. Sanity
      this.updateSanity(delta);
    } catch (e) { console.warn('[GameLoop] sanity:', e); }

    try {
      // 7. Flashlight battery
      this._updateFlashlight(delta);
    } catch (e) { console.warn('[GameLoop] flashlight:', e); }

    try {
      // 8. Network updates
      if (this.isMultiplayer && this.multiplayer && this.multiplayer.sendUpdate) {
        const playerState = this._buildPlayerNetworkState();
        this.multiplayer.sendUpdate(playerState);
      }
    } catch (e) { console.warn('[GameLoop] network send:', e); }

    try {
      // 9. Remote players interpolation
      if (this.isMultiplayer && this.remotePlayers && this.remotePlayers.update) {
        this.remotePlayers.update(delta);
      }
    } catch (e) { console.warn('[GameLoop] remotePlayers.update:', e); }

    try {
      // 10. HUD update
      this._updateHUD(delta);
    } catch (e) { console.warn('[GameLoop] hud update:', e); }

    try {
      // 11. Audio spatial / sanity intensity
      this._updateAudio(delta);
    } catch (e) { console.warn('[GameLoop] audio update:', e); }

    try {
      // 12. Particles and effects
      if (this.renderer && this.renderer.updateParticles) {
        this.renderer.updateParticles(delta);
      }
      if (this.renderer && this.renderer.updateEffects) {
        this.renderer.updateEffects(delta, this.sanity);
      }
    } catch (e) { console.warn('[GameLoop] particles/effects:', e); }

    try {
      // 13. Post-processing based on sanity
      this._applyPostProcessing();
    } catch (e) { console.warn('[GameLoop] post-processing:', e); }

    try {
      // 14. Render frame
      if (this.renderer && this.renderer.render) this.renderer.render();
      else if (this.renderer && this.renderer.renderFrame) this.renderer.renderFrame();
    } catch (e) { console.warn('[GameLoop] render:', e); }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // SANITY
  // âââââââââââââââââââââââââââââââââââââââââââââ
  updateSanity(delta) {
    let change = 0;

    // Darkness decreases sanity
    if (!this.inLitArea && !this.flashlightOn) {
      change -= 2 * delta;
    } else if (this.inLitArea) {
      change += 0.2 * delta;
    }

    // Near Alisa
    if (this.nearAlisa) {
      change -= 5 * delta;
    }

    // Near other players (comfort bonus)
    if (this.nearPlayers > 0) {
      change += 0.5 * delta * Math.min(this.nearPlayers, 3);
    }

    // Libro de Rezos
    if (this.usingLibro) {
      change += 1 * delta;
    }

    this.sanity = Math.max(0, Math.min(100, this.sanity + change));

    // Threshold effects
    this._handleSanityThresholds();
  }

  _handleSanityThresholds() {
    const s = this.sanity;
    if (s <= 0) {
      this._triggerGameOver('sanity');
    } else if (s <= 10) {
      this._setSanityLevel('critical');
    } else if (s <= 25) {
      this._setSanityLevel('low');
    } else if (s <= 50) {
      this._setSanityLevel('medium');
    } else {
      this._setSanityLevel('high');
    }
  }

  _setSanityLevel(level) {
    if (this._lastSanityLevel === level) return;
    this._lastSanityLevel = level;

    const intensities = { critical: 1.0, low: 0.6, medium: 0.3, high: 0.0 };
    const intensity = intensities[level] || 0;

    if (this.renderer) {
      if (this.renderer.setSanityEffect) this.renderer.setSanityEffect(intensity);
      if (this.renderer.setVignetteIntensity) this.renderer.setVignetteIntensity(intensity);
      if (this.renderer.setChromAberration) this.renderer.setChromAberration(intensity * 0.015);
    }
    if (this.audio) {
      if (this.audio.setSanityIntensity) this.audio.setSanityIntensity(intensity);
      if (level === 'critical' && this.audio.playHallucination) {
        this.audio.playHallucination();
      }
    }
  }

  // Instant sanity hit from paranormal event
  _paranormalSanityHit(amount) {
    amount = amount || 3;
    this.sanity = Math.max(0, this.sanity - amount);
    if (this.hud && this.hud.flashSanity) this.hud.flashSanity();
    if (this.audio && this.audio.playStinger) this.audio.playStinger('paranormal_hit');
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // PARANORMAL EVENTS
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _updateParanormalEvents(delta) {
    if (this.paranormalCooldown > 0) {
      this.paranormalCooldown -= delta;
      return;
    }
    if (!this.isRunning || this.isPaused) return;

    // Random chance of paranormal event based on chapter / sanity
    const threshold = 0.0008 + (1 - this.sanity / 100) * 0.001;
    if (Math.random() < threshold) {
      this._triggerRandomParanormalEvent();
      this.paranormalCooldown = 15 + Math.random() * 20;
    }
  }

  _triggerRandomParanormalEvent() {
    const events = ['flicker', 'whisper', 'shadow', 'door_slam', 'writing'];
    const evt = events[Math.floor(Math.random() * events.length)];
    switch (evt) {
      case 'flicker':
        if (this.renderer && this.renderer.flickerLights) this.renderer.flickerLights(0.8);
        break;
      case 'whisper':
        if (this.audio && this.audio.playWhisper) this.audio.playWhisper();
        break;
      case 'shadow':
        if (this.renderer && this.renderer.spawnShadowFigure) this.renderer.spawnShadowFigure();
        break;
      case 'door_slam':
        if (this.audio && this.audio.playSFX) this.audio.playSFX('door_slam', { volume: 0.9 });
        break;
      case 'writing':
        if (this.renderer && this.renderer.showBloodWriting) this.renderer.showBloodWriting();
        break;
    }
    this._paranormalSanityHit(3);
    if (this.hud && this.hud.showParanormalAlert) this.hud.showParanormalAlert(evt);
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // FLASHLIGHT
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _updateFlashlight(delta) {
    if (this.flashlightOn) {
      this.flashlightBattery = Math.max(0, this.flashlightBattery - 1.5 * delta);
      if (this.flashlightBattery <= 0) {
        this.flashlightOn = false;
        if (this.player && this.player.setFlashlight) this.player.setFlashlight(false);
        if (this.renderer && this.renderer.setFlashlight) this.renderer.setFlashlight(false);
        if (this.audio && this.audio.playSFX) this.audio.playSFX('flashlight_off');
        if (this.hud && this.hud.showWarning) this.hud.showWarning('Â¡BaterÃ­a agotada!');
      } else if (this.flashlightBattery < 15) {
        if (this.renderer && this.renderer.flickerFlashlight) this.renderer.flickerFlashlight();
      }
    }
  }

  _toggleFlashlight() {
    if (this.flashlightBattery <= 0 && !this.flashlightOn) {
      if (this.hud && this.hud.showWarning) this.hud.showWarning('Sin baterÃ­a');
      if (this.audio && this.audio.playSFX) this.audio.playSFX('flashlight_click_dead');
      return;
    }
    this.flashlightOn = !this.flashlightOn;
    if (this.player && this.player.setFlashlight) this.player.setFlashlight(this.flashlightOn);
    if (this.renderer && this.renderer.setFlashlight) this.renderer.setFlashlight(this.flashlightOn);
    if (this.audio && this.audio.playSFX) {
      this.audio.playSFX(this.flashlightOn ? 'flashlight_on' : 'flashlight_off');
    }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // HUD UPDATE
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _updateHUD(delta) {
    if (!this.hud) return;
    if (this.hud.setSanity)  this.hud.setSanity(this.sanity);
    if (this.hud.setBattery) this.hud.setBattery(this.flashlightBattery);

    // EMF / Temperature from Alisa
    if (this.alisa) {
      if (this.hud.setEMF && this.alisa.getEMFLevel) {
        this.hud.setEMF(this.alisa.getEMFLevel());
      }
      if (this.hud.setTemperature && this.alisa.getTemperature) {
        this.hud.setTemperature(this.alisa.getTemperature());
      }
    }

    if (this.hud.update) this.hud.update(delta);
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // AUDIO SPATIAL UPDATE
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _updateAudio(delta) {
    if (!this.audio) return;
    const pos = this._getPlayerPosition();
    if (this.audio.setListenerPosition) {
      this.audio.setListenerPosition(pos);
    }
    const rot = this._getPlayerRotation();
    if (this.audio.setListenerRotation && rot) {
      this.audio.setListenerRotation(rot);
    }
    // Sanity-based music intensity
    const sanityNorm = this.sanity / 100;
    if (this.audio.setMusicIntensity) {
      this.audio.setMusicIntensity(1 - sanityNorm);
    }
    if (this.audio.update) this.audio.update(delta);
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // POST-PROCESSING
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _applyPostProcessing() {
    if (!this.renderer) return;
    const sanityNorm = this.sanity / 100;
    const distortionAmt = Math.max(0, (1 - sanityNorm) * 0.05);
    const grainAmt = Math.max(0, (1 - sanityNorm) * 0.4);
    const desatAmt = Math.max(0, (1 - sanityNorm) * 0.6);

    if (this.renderer.setPostProcessingParams) {
      this.renderer.setPostProcessingParams({
        distortion: distortionAmt,
        grain:      grainAmt,
        desaturation: desatAmt,
        sanity: this.sanity
      });
    }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // NETWORK STATE
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _buildPlayerNetworkState() {
    const pos = this._getPlayerPosition();
    const rot = this._getPlayerRotation();
    return {
      position:  pos,
      rotation:  rot,
      sanity:    this.sanity,
      flashlight: this.flashlightOn,
      timestamp:  Date.now()
    };
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // CHAPTER 1 SETUP
  // âââââââââââââââââââââââââââââââââââââââââââââ
  setupChapter1() {
    this.chapter1Objectives = [
      {
        id:   'explore_entrance',
        text: 'Explorar la entrada del orfanato',
        trigger: 'zone_entrance',
        completed: false
      },
      {
        id:   'find_flashlight',
        text: 'Encontrar la linterna',
        trigger: 'item_flashlight',
        completed: false
      },
      {
        id:   'investigate_noises',
        text: 'Investigar los ruidos del segundo piso',
        trigger: 'zone_second_floor',
        completed: false
      },
      {
        id:   'find_diary',
        text: 'Encontrar el diario de la Directora',
        trigger: 'item_diary',
        completed: false
      },
      {
        id:   'chapel_puzzle',
        text: 'Resolver el puzle de la capilla',
        trigger: 'puzzle_chapel',
        completed: false,
        hint: 'Enciende las velas en el orden del diario'
      },
      {
        id:   'descend_basement',
        text: 'Descender al sÃ³tano',
        trigger: 'zone_basement',
        completed: false
      },
      {
        id:   'confront_alisa',
        text: 'Confrontar la primera manifestaciÃ³n de Alisa',
        trigger: 'boss_encounter',
        completed: false,
        hint: 'Usa la Cruz de Sal y el Libro de Rezos'
      },
      {
        id:   'escape',
        text: 'Escapar del orfanato',
        trigger: 'zone_exit',
        completed: false
      }
    ];
    this.currentObjectiveIndex = 0;

    // Register triggers with interaction system
    if (this.interaction && this.interaction.registerObjectives) {
      this.interaction.registerObjectives(this.chapter1Objectives, (id) => {
        this._completeObjective(id);
      });
    }

    // Listen for state events
    if (this.state) {
      if (this.state.on) {
        this.state.on('objective_complete', (id) => this._completeObjective(id));
        this.state.on('item_collected',     (item) => this._onItemCollected(item));
        this.state.on('zone_entered',       (zone) => this._onZoneEntered(zone));
        this.state.on('puzzle_solved',      (id)   => this._onPuzzleSolved(id));
        this.state.on('boss_triggered',     ()     => this._onBossEncounter());
      }
    }
  }

  _completeObjective(id) {
    const obj = this.chapter1Objectives.find(o => o.id === id || o.trigger === id);
    if (!obj || obj.completed) return;
    obj.completed = true;
    this.currentObjectiveIndex = Math.min(
      this.chapter1Objectives.length - 1,
      this.currentObjectiveIndex + 1
    );
    const next = this.chapter1Objectives[this.currentObjectiveIndex];
    if (this.hud) {
      if (this.hud.setObjective) this.hud.setObjective(next ? next.text : 'Â¡CapÃ­tulo completado!');
      if (this.hud.showObjectiveComplete) this.hud.showObjectiveComplete(obj.text);
    }
    if (this.audio && this.audio.playSFX) this.audio.playSFX('objective_complete');

    // Special handling per objective
    if (id === 'escape' || id === 'zone_exit') {
      this._onChapter1Complete();
    }
    if (id === 'boss_encounter') {
      this._onBossEncounter();
    }
  }

  _onItemCollected(item) {
    if (item === 'flashlight' || item === 'item_flashlight') {
      this.flashlightBattery = 100;
      if (this.hud && this.hud.showNotification) {
        this.hud.showNotification('Linterna recogida');
      }
      this._completeObjective('find_flashlight');
    }
    if (item === 'diary' || item === 'item_diary') {
      if (this.hud && this.hud.showNotification) {
        this.hud.showNotification('Diario de la Directora recogido');
      }
      this._completeObjective('find_diary');
    }
    if (item === 'libro_rezos') {
      if (this.hud && this.hud.showNotification) {
        this.hud.showNotification('Libro de Rezos recogido');
      }
    }
  }

  _onZoneEntered(zone) {
    const zoneMap = {
      'entrance':     'explore_entrance',
      'second_floor': 'investigate_noises',
      'basement':     'descend_basement',
      'exit':         'escape'
    };
    if (zoneMap[zone]) {
      this._completeObjective(zoneMap[zone]);
    }
  }

  _onPuzzleSolved(puzzleId) {
    if (puzzleId === 'chapel') {
      this._completeObjective('chapel_puzzle');
      if (this.audio && this.audio.playSFX) this.audio.playSFX('puzzle_solved');
      if (this.renderer && this.renderer.openBasementDoor) this.renderer.openBasementDoor();
    }
  }

  _onBossEncounter() {
    if (this.audio && this.audio.playMusic) {
      this.audio.playMusic('boss_theme', { loop: false, volume: 0.8 });
    }
    if (this.alisa && this.alisa.triggerManifest) {
      this.alisa.triggerManifest('first_manifestation');
    }
    if (this.hud && this.hud.showBossIndicator) {
      this.hud.showBossIndicator('Â¡Alisa se ha manifestado! Usa la Cruz de Sal.');
    }
  }

  _onChapter1Complete() {
    this.isRunning = false;
    if (this.audio && this.audio.playMusic) {
      this.audio.playMusic('chapter_complete', { loop: false, volume: 0.6 });
    }
    setTimeout(() => {
      this._showChapterEndScreen(1);
    }, 2000);
  }

  _showChapterEndScreen(chapter) {
    this._exitPointerLock();
    const el = document.getElementById('chapter-end-screen');
    if (el) {
      el.style.display = 'flex';
      const title = el.querySelector('#chapter-end-title');
      if (title) title.textContent = 'CapÃ­tulo ' + chapter + ' Completado';
    } else {
      this._showTransition('CapÃ­tulo ' + chapter + ' Completado', 4000);
      setTimeout(() => this.showMainMenu(), 5000);
    }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // GAME OVER
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _triggerGameOver(reason) {
    if (this._gameOverTriggered) return;
    this._gameOverTriggered = true;
    this.isRunning = false;
    this._exitPointerLock();

    if (this.audio && this.audio.playMusic) {
      this.audio.playMusic('game_over', { loop: false, volume: 0.7 });
    }

    setTimeout(() => {
      const el = document.getElementById('game-over-screen');
      if (el) {
        el.style.display = 'flex';
        const reason_el = el.querySelector('#game-over-reason');
        const reasons = {
          sanity:  'Tu mente sucumbiÃ³ a la oscuridad.',
          death:   'Alisa te ha encontrado.',
          timeout: 'No lograste escapar a tiempo.'
        };
        if (reason_el) reason_el.textContent = reasons[reason] || reasons.death;
      } else {
        alert('GAME OVER: ' + (reason || 'Has sido derrotado'));
        this.showMainMenu();
      }
      this._gameOverTriggered = false;
    }, 1500);
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // PAUSE
  // âââââââââââââââââââââââââââââââââââââââââââââ
  pauseGame() {
    if (!this.isRunning) return;
    this.isPaused = true;
    this._exitPointerLock();
    const el = document.getElementById('pause-menu');
    if (el) el.style.display = 'flex';
    if (this.audio && this.audio.pause) this.audio.pause();
  }

  resumeGame() {
    this.isPaused = false;
    const el = document.getElementById('pause-menu');
    if (el) el.style.display = 'none';
    if (this.audio && this.audio.resume) this.audio.resume();
    this._requestPointerLock();
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // EVENT LISTENERS
  // âââââââââââââââââââââââââââââââââââââââââââââ
  setupEventListeners() {
    // ââ Keyboard ââ
    document.addEventListener('keydown', (e) => this._onKeyDown(e), false);
    document.addEventListener('keyup',   (e) => this._onKeyUp(e),   false);

    // ââ Mouse ââ
    document.addEventListener('mousemove', (e) => this._onMouseMove(e), false);
    document.addEventListener('mousedown', (e) => this._onMouseDown(e), false);
    document.addEventListener('mouseup',   (e) => this._onMouseUp(e),   false);
    document.addEventListener('contextmenu', (e) => { if (this.isRunning) e.preventDefault(); }, false);

    // ââ Touch ââ
    document.addEventListener('touchstart', (e) => this._onTouchStart(e), { passive: false });
    document.addEventListener('touchmove',  (e) => this._onTouchMove(e),  { passive: false });
    document.addEventListener('touchend',   (e) => this._onTouchEnd(e),   { passive: false });

    // ââ Window ââ
    window.addEventListener('resize',           ()  => this._onResize(),            false);
    window.addEventListener('visibilitychange', ()  => this._onVisibilityChange(),  false);
    window.addEventListener('beforeunload',     (e) => this._onBeforeUnload(e),     false);

    // ââ Pointer Lock ââ
    document.addEventListener('pointerlockchange', () => this._onPointerLockChange(), false);
    document.addEventListener('pointerlockerror',  () => this._onPointerLockError(),  false);

    // ââ UI Buttons ââ
    this._wireUIButtons();

    // ââ Chat ââ
    document.addEventListener('keydown', (e) => {
      if (!this.isRunning || !this.isMultiplayer) return;
      if (e.key === 'Enter') {
        if (this.chat && this.chat.isOpen && this.chat.isOpen()) {
          if (this.chat.sendMessage) this.chat.sendMessage();
          if (this.chat.close) this.chat.close();
          this._requestPointerLock();
        } else {
          this._exitPointerLock();
          if (this.chat && this.chat.open) this.chat.open();
        }
      }
      if (e.key === 'Escape' && this.chat && this.chat.isOpen && this.chat.isOpen()) {
        if (this.chat.close) this.chat.close();
        this._requestPointerLock();
      }
    }, false);
  }

  _onKeyDown(e) {
    this.keysDown[e.code] = true;
    if (!this.isRunning) return;

    switch (e.code) {
      case 'Escape':
        if (this.isPaused) this.resumeGame();
        else this.pauseGame();
        break;
      case 'KeyF':
        this._toggleFlashlight();
        break;
      case 'KeyE':
      case 'KeyF':  // handled above
        if (e.code === 'KeyE') this._onInteract();
        break;
      case 'Tab':
        e.preventDefault();
        this._toggleInventory();
        break;
      case 'KeyR':
        this._useLibroRezos(true);
        break;
      case 'F11':
        e.preventDefault();
        this._toggleFullscreen();
        break;
      case 'KeyM':
        if (this.audio && this.audio.toggleMute) this.audio.toggleMute();
        break;
    }

    if (this.player && this.player.onKeyDown) this.player.onKeyDown(e);
  }

  _onKeyUp(e) {
    this.keysDown[e.code] = false;
    if (e.code === 'KeyR') this._useLibroRezos(false);
    if (this.player && this.player.onKeyUp) this.player.onKeyUp(e);
  }

  _onMouseMove(e) {
    if (!this.isRunning || this.isPaused) return;
    const pl = document.pointerLockElement || document.mozPointerLockElement;
    if (!pl) return;
    const dx = e.movementX || e.mozMovementX || 0;
    const dy = e.movementY || e.mozMovementY || 0;
    if (this.player && this.player.onMouseMove) {
      this.player.onMouseMove(dx * this.settings.mouseSensitivity,
                               dy * this.settings.mouseSensitivity * (this.settings.invertY ? -1 : 1));
    } else if (this.renderer && this.renderer.rotateCamera) {
      this.renderer.rotateCamera(dx * this.settings.mouseSensitivity,
                                  dy * this.settings.mouseSensitivity * (this.settings.invertY ? -1 : 1));
    }
  }

  _onMouseDown(e) {
    if (!this.isRunning || this.isPaused) return;
    const pl = document.pointerLockElement || document.mozPointerLockElement;
    if (!pl) {
      this._requestPointerLock();
      return;
    }
    if (e.button === 0) this._onInteract();
    if (e.button === 2) { e.preventDefault(); this._toggleFlashlight(); }
    if (this.player && this.player.onMouseDown) this.player.onMouseDown(e);
  }

  _onMouseUp(e) {
    if (this.player && this.player.onMouseUp) this.player.onMouseUp(e);
  }

  _onTouchStart(e) {
    e.preventDefault();
    if (this.player && this.player.onTouchStart) this.player.onTouchStart(e);
  }

  _onTouchMove(e) {
    e.preventDefault();
    if (this.player && this.player.onTouchMove) this.player.onTouchMove(e);
  }

  _onTouchEnd(e) {
    e.preventDefault();
    if (this.player && this.player.onTouchEnd) this.player.onTouchEnd(e);
  }

  _onResize() {
    if (this.renderer && this.renderer.onResize) {
      this.renderer.onResize(window.innerWidth, window.innerHeight);
    } else if (this.renderer) {
      if (this.renderer.renderer && this.renderer.renderer.setSize) {
        this.renderer.renderer.setSize(window.innerWidth, window.innerHeight);
      }
      if (this.renderer.camera) {
        this.renderer.camera.aspect = window.innerWidth / window.innerHeight;
        if (this.renderer.camera.updateProjectionMatrix) {
          this.renderer.camera.updateProjectionMatrix();
        }
      }
    }
  }

  _onVisibilityChange() {
    if (document.hidden) {
      if (this.isRunning && !this.isPaused) this.pauseGame();
      if (this.audio && this.audio.pause) this.audio.pause();
    } else {
      if (this.audio && this.audio.resume) this.audio.resume();
    }
  }

  _onBeforeUnload(e) {
    if (this.isRunning) {
      e.preventDefault();
      e.returnValue = '';
    }
    if (this.multiplayer && this.multiplayer.disconnect) {
      this.multiplayer.disconnect();
    }
    this.saveSettings();
  }

  _onPointerLockChange() {
    const locked = !!(document.pointerLockElement || document.mozPointerLockElement);
    if (!locked && this.isRunning && !this.isPaused) {
      // Only auto-pause if chat isn't open
      const chatOpen = this.chat && this.chat.isOpen && this.chat.isOpen();
      const inventoryOpen = this.inventoryOpen;
      if (!chatOpen && !inventoryOpen) {
        // Don't force pause on accidental unlock during gameplay, just show cursor hint
      }
    }
  }

  _onPointerLockError() {
    console.warn('[Game] Pointer lock error â continuing without it');
  }

  _onInteract() {
    if (!this.isRunning || this.isPaused) return;
    if (this.interaction && this.interaction.tryInteract) {
      const result = this.interaction.tryInteract();
      if (result) this._handleInteractionResult(result);
    } else if (this.player && this.player.interact) {
      this.player.interact();
    }
  }

  _handleInteractionResult(result) {
    if (!result) return;
    if (result.type === 'item') {
      this._onItemCollected(result.id);
    } else if (result.type === 'zone') {
      this._onZoneEntered(result.id);
    } else if (result.type === 'puzzle') {
      this._onPuzzleSolved(result.id);
    } else if (result.type === 'boss') {
      this._onBossEncounter();
      this._completeObjective('boss_encounter');
    }
  }

  _toggleInventory() {
    this.inventoryOpen = !this.inventoryOpen;
    const el = document.getElementById('inventory-screen');
    if (el) el.style.display = this.inventoryOpen ? 'flex' : 'none';
    if (this.inventoryOpen) this._exitPointerLock();
    else this._requestPointerLock();
  }

  _useLibroRezos(active) {
    this.usingLibro = active;
    if (this.player && this.player.setUsingItem) this.player.setUsingItem(active ? 'libro' : null);
    if (active && this.audio && this.audio.playSFX) {
      this.audio.playSFX('libro_rezos', { loop: true, id: 'libro_rezos_loop' });
    } else if (!active && this.audio && this.audio.stopSFX) {
      this.audio.stopSFX('libro_rezos_loop');
    }
    if (this.nearAlisa && active && this.alisa && this.alisa.repel) {
      this.alisa.repel();
    }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // UI BUTTON WIRING
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _wireUIButtons() {
    const btn = (id, fn) => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('click', fn, false);
    };

    // Main menu
    btn('btn-solo-game',         () => this._showCharacterSelect());
    btn('btn-multiplayer-menu',  () => this.startMultiplayer());
    btn('btn-settings-menu',     () => this._showSettings());
    btn('btn-credits-menu',      () => this._showCredits());
    btn('btn-quit',              () => this._confirmQuit());

    // Character select
    btn('btn-character-confirm', () => {
      const sel = document.getElementById('character-select');
      const char = sel ? sel.value : 'default';
      this.startSoloGame(char);
    });
    btn('btn-character-back',    () => this.showMainMenu());

    // Lobby
    btn('btn-create-room',       () => this.createRoom());
    btn('btn-join-room',         () => {
      const inp = document.getElementById('room-code-input');
      this.joinRoom(inp ? inp.value.trim() : '');
    });
    btn('btn-start-mp-game',     () => this.startMultiplayerGame());
    btn('btn-lobby-back',        () => this.showMainMenu());

    // Pause menu
    btn('btn-resume',            () => this.resumeGame());
    btn('btn-pause-settings',    () => this._showSettings());
    btn('btn-pause-quit-menu',   () => {
      this.isRunning = false;
      this._exitPointerLock();
      const pm = document.getElementById('pause-menu');
      if (pm) pm.style.display = 'none';
      this.showMainMenu();
    });
    btn('btn-pause-quit-desktop',() => window.close());

    // Game over
    btn('btn-retry',             () => {
      const el = document.getElementById('game-over-screen');
      if (el) el.style.display = 'none';
      this.startSoloGame();
    });
    btn('btn-gameover-menu',     () => {
      const el = document.getElementById('game-over-screen');
      if (el) el.style.display = 'none';
      this.showMainMenu();
    });

    // Chapter end
    btn('btn-next-chapter',      () => {
      const el = document.getElementById('chapter-end-screen');
      if (el) el.style.display = 'none';
      this.showMainMenu();
    });

    // Settings
    btn('btn-settings-apply',    () => this._applySettingsFromUI());
    btn('btn-settings-back',     () => this._hideSettings());

    // Credits
    btn('btn-credits-back',      () => this._hideCredits());

    // Fullscreen
    btn('btn-fullscreen',        () => this._toggleFullscreen());

    // HUD action buttons (mobile / in-game)
    btn('btn-interact',          () => this._onInteract());
    btn('btn-flashlight-toggle', () => this._toggleFlashlight());
    btn('btn-libro-toggle',      () => {
      this.usingLibro = !this.usingLibro;
      this._useLibroRezos(this.usingLibro);
    });
    btn('btn-inventory-toggle',  () => this._toggleInventory());

    // Settings sliders / selects realtime preview
    ['volume-master','volume-music','volume-sfx','volume-ambient'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('input', () => this._applyVolumeFromSlider(id, el.value));
    });

    const sensEl = document.getElementById('mouse-sensitivity');
    if (sensEl) sensEl.addEventListener('input', () => {
      this.settings.mouseSensitivity = parseFloat(sensEl.value) || 0.002;
    });

    const invertEl = document.getElementById('invert-y');
    if (invertEl) invertEl.addEventListener('change', () => {
      this.settings.invertY = invertEl.checked;
    });
  }

  _applyVolumeFromSlider(id, val) {
    const v = parseFloat(val) || 0;
    if (!this.audio) return;
    switch (id) {
      case 'volume-master':  if (this.audio.setMasterVolume)  this.audio.setMasterVolume(v);  break;
      case 'volume-music':   if (this.audio.setMusicVolume)   this.audio.setMusicVolume(v);   break;
      case 'volume-sfx':     if (this.audio.setSFXVolume)     this.audio.setSFXVolume(v);     break;
      case 'volume-ambient': if (this.audio.setAmbientVolume) this.audio.setAmbientVolume(v); break;
    }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // SETTINGS
  // âââââââââââââââââââââââââââââââââââââââââââââ
  applySettings(settings) {
    this.settings = Object.assign(this.settings, settings);

    if (this.audio) {
      if (settings.volumeMaster  !== undefined && this.audio.setMasterVolume)  this.audio.setMasterVolume(settings.volumeMaster);
      if (settings.volumeMusic   !== undefined && this.audio.setMusicVolume)   this.audio.setMusicVolume(settings.volumeMusic);
      if (settings.volumeSFX     !== undefined && this.audio.setSFXVolume)     this.audio.setSFXVolume(settings.volumeSFX);
      if (settings.volumeAmbient !== undefined && this.audio.setAmbientVolume) this.audio.setAmbientVolume(settings.volumeAmbient);
    }

    if (this.renderer) {
      if (settings.shadowQuality !== undefined && this.renderer.setShadowQuality) this.renderer.setShadowQuality(settings.shadowQuality);
      if (settings.particleCount !== undefined && this.renderer.setParticleCount) this.renderer.setParticleCount(settings.particleCount);
      if (settings.postProcessing !== undefined && this.renderer.setPostProcessingEnabled) this.renderer.setPostProcessingEnabled(settings.postProcessing);
    }

    this.saveSettings();
  }

  loadSettings() {
    const defaults = {
      volumeMaster:    0.8,
      volumeMusic:     0.6,
      volumeSFX:       0.8,
      volumeAmbient:   0.7,
      mouseSensitivity:0.002,
      invertY:         false,
      shadowQuality:   'medium',
      particleCount:   500,
      postProcessing:  true,
      fullscreen:      false
    };
    try {
      const saved = localStorage.getItem('elSusurro_settings');
      if (saved) {
        const parsed = JSON.parse(saved);
        this.settings = Object.assign({}, defaults, parsed);
      } else {
        this.settings = Object.assign({}, defaults);
      }
    } catch (e) {
      this.settings = Object.assign({}, defaults);
    }
  }

  saveSettings() {
    try {
      localStorage.setItem('elSusurro_settings', JSON.stringify(this.settings));
    } catch (e) { /* quota or private mode */ }
  }

  _applySettingsFromUI() {
    const g = (id) => { const el = document.getElementById(id); return el ? el.value : null; };
    const gb = (id) => { const el = document.getElementById(id); return el ? el.checked : null; };

    const s = {};
    const vm = parseFloat(g('volume-master')); if (!isNaN(vm)) s.volumeMaster = vm;
    const vmu = parseFloat(g('volume-music')); if (!isNaN(vmu)) s.volumeMusic = vmu;
    const vs = parseFloat(g('volume-sfx')); if (!isNaN(vs)) s.volumeSFX = vs;
    const va = parseFloat(g('volume-ambient')); if (!isNaN(va)) s.volumeAmbient = va;
    const ms = parseFloat(g('mouse-sensitivity')); if (!isNaN(ms)) s.mouseSensitivity = ms;
    const iy = gb('invert-y'); if (iy !== null) s.invertY = iy;
    const sq = g('shadow-quality'); if (sq) s.shadowQuality = sq;
    const pp = gb('post-processing'); if (pp !== null) s.postProcessing = pp;

    this.applySettings(s);
    if (this.hud && this.hud.showNotification) this.hud.showNotification('Ajustes guardados');
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // SCREEN HELPERS
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _hideAllScreens() {
    const screens = [
      'loading-screen', 'main-menu', 'lobby-screen', 'settings-screen',
      'credits-screen', 'pause-menu', 'game-over-screen', 'chapter-end-screen',
      'inventory-screen', 'character-select-screen'
    ];
    screens.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'none';
    });
    if (this.hud && this.hud.hide) this.hud.hide();
  }

  _showCharacterSelect() {
    const el = document.getElementById('character-select-screen');
    if (el) {
      this._hideAllScreens();
      el.style.display = 'flex';
    } else {
      // Fallback: skip character select
      this.startSoloGame('default');
    }
  }

  _showSettings() {
    const el = document.getElementById('settings-screen');
    if (el) {
      el.style.display = 'flex';
      // Populate current values
      const populate = (id, val) => { const e = document.getElementById(id); if (e) e.value = val; };
      const populateChk = (id, val) => { const e = document.getElementById(id); if (e) e.checked = val; };
      populate('volume-master',    this.settings.volumeMaster);
      populate('volume-music',     this.settings.volumeMusic);
      populate('volume-sfx',       this.settings.volumeSFX);
      populate('volume-ambient',   this.settings.volumeAmbient);
      populate('mouse-sensitivity',this.settings.mouseSensitivity);
      populate('shadow-quality',   this.settings.shadowQuality);
      populateChk('invert-y',      this.settings.invertY);
      populateChk('post-processing',this.settings.postProcessing);
    }
  }

  _hideSettings() {
    const el = document.getElementById('settings-screen');
    if (el) el.style.display = 'none';
  }

  _showCredits() {
    const el = document.getElementById('credits-screen');
    if (el) el.style.display = 'flex';
  }

  _hideCredits() {
    const el = document.getElementById('credits-screen');
    if (el) el.style.display = 'none';
  }

  _showTransition(text, duration) {
    let el = document.getElementById('transition-overlay');
    if (!el) {
      el = document.createElement('div');
      el.id = 'transition-overlay';
      el.style.cssText = [
        'position:fixed','top:0','left:0','width:100%','height:100%',
        'background:rgba(0,0,0,0.9)','display:flex','align-items:center',
        'justify-content:center','z-index:9999',
        'font-family:"Cinzel",serif','font-size:2rem',
        'color:#c8a96e','text-align:center','pointer-events:none'
      ].join(';');
      document.body.appendChild(el);
    }
    el.textContent = text;
    el.style.display = 'flex';
    el.style.opacity = '1';
    if (duration) {
      setTimeout(() => {
        el.style.transition = 'opacity 0.5s';
        el.style.opacity = '0';
        setTimeout(() => { el.style.display = 'none'; }, 600);
      }, duration);
    }
  }

  _showNotification(msg) {
    if (this.hud && this.hud.showNotification) {
      this.hud.showNotification(msg);
      return;
    }
    let el = document.getElementById('notification-toast');
    if (!el) {
      el = document.createElement('div');
      el.id = 'notification-toast';
      el.style.cssText = [
        'position:fixed','bottom:80px','left:50%','transform:translateX(-50%)',
        'background:rgba(0,0,0,0.8)','color:#fff','padding:10px 20px',
        'border-radius:6px','font-size:1rem','z-index:5000','pointer-events:none',
        'transition:opacity 0.4s'
      ].join(';');
      document.body.appendChild(el);
    }
    el.textContent = msg;
    el.style.opacity = '1';
    if (el._timeout) clearTimeout(el._timeout);
    el._timeout = setTimeout(() => { el.style.opacity = '0'; }, 3000);
  }

  _showFatalError(err) {
    const el = document.getElementById('loading-screen') || document.body;
    const msg = document.createElement('div');
    msg.style.cssText = 'color:#ff4444;font-size:1.2rem;padding:20px;text-align:center;font-family:monospace;';
    msg.innerHTML = '<b>Error crÃ­tico al inicializar el juego.</b><br>' +
      '<small>' + (err ? err.message || String(err) : 'Unknown error') + '</small><br><br>' +
      '<button onclick="location.reload()" style="padding:8px 20px;cursor:pointer;">Recargar</button>';
    el.appendChild(msg);
  }

  _confirmQuit() {
    if (confirm('Â¿Salir del juego?')) window.close();
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // POINTER LOCK HELPERS
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _requestPointerLock() {
    try {
      const canvas = this.renderer ? this.renderer.canvas || this.renderer.domElement : null;
      const target = canvas || document.body;
      if (target.requestPointerLock) target.requestPointerLock();
      else if (target.mozRequestPointerLock) target.mozRequestPointerLock();
    } catch (e) { /* browser may deny */ }
  }

  _exitPointerLock() {
    try {
      if (document.exitPointerLock) document.exitPointerLock();
      else if (document.mozExitPointerLock) document.mozExitPointerLock();
    } catch (e) { /* silent */ }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // FULLSCREEN
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _toggleFullscreen() {
    try {
      if (!document.fullscreenElement && !document.mozFullScreenElement) {
        const el = document.documentElement;
        if (el.requestFullscreen) el.requestFullscreen();
        else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      } else {
        if (document.exitFullscreen) document.exitFullscreen();
        else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
      }
    } catch (e) { console.warn('[Game] Fullscreen toggle failed:', e); }
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // PLAYER STATE HELPERS
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _getPlayerPosition() {
    if (!this.player) return { x: 0, y: 1, z: 0 };
    if (this.player.position) return this.player.position;
    if (this.player.getPosition) return this.player.getPosition();
    if (this.renderer && this.renderer.camera) {
      const c = this.renderer.camera;
      return { x: c.position.x, y: c.position.y, z: c.position.z };
    }
    return { x: 0, y: 1, z: 0 };
  }

  _getPlayerRotation() {
    if (!this.player) return null;
    if (this.player.rotation) return this.player.rotation;
    if (this.player.getRotation) return this.player.getRotation();
    if (this.renderer && this.renderer.camera) {
      const c = this.renderer.camera;
      return { x: c.rotation.x, y: c.rotation.y, z: c.rotation.z };
    }
    return null;
  }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // UTILITY
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  // âââââââââââââââââââââââââââââââââââââââââââââ
  // FALLBACK STUBS (ensure game runs even if
  // external classes aren't defined)
  // âââââââââââââââââââââââââââââââââââââââââââââ
  _createFallbackAudio() {
    return {
      init() {},
      playMusic() {},
      stopMusic() {},
      playAmbient() {},
      playSFX() {},
      stopSFX() {},
      setMasterVolume() {},
      setMusicVolume() {},
      setSFXVolume() {},
      setAmbientVolume() {},
      setSanityIntensity() {},
      setMusicIntensity() {},
      setListenerPosition() {},
      setListenerRotation() {},
      pause() {},
      resume() {},
      toggleMute() {},
      update() {},
      playWhisper() {},
      playStinger() {},
      playHallucination() {},
      context: { resume() {} }
    };
  }

  _createFallbackRenderer() {
    const stub = {
      camera: null, scene: null, canvas: null, domElement: null,
      init() {
        // Minimal Three.js setup if available
        if (typeof THREE === 'undefined') return;
        try {
          const w = window.innerWidth, h = window.innerHeight;
          this.scene    = new THREE.Scene();
          this.camera   = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
          this.camera.position.set(0, 1.7, 5);
          this.renderer = new THREE.WebGLRenderer({ antialias: true });
          this.renderer.setSize(w, h);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.shadowMap.enabled = true;
          this.canvas = this.renderer.domElement;
          this.domElement = this.canvas;
          document.body.appendChild(this.canvas);
          // Basic lighting
          const ambient = new THREE.AmbientLight(0x111111, 0.5);
          this.scene.add(ambient);
          const pt = new THREE.PointLight(0x4466aa, 1, 20);
          pt.position.set(0, 3, 0);
          this.scene.add(pt);
          // Floor
          const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 40),
            new THREE.MeshStandardMaterial({ color: 0x222222 })
          );
          floor.rotation.x = -Math.PI / 2;
          this.scene.add(floor);
        } catch (e) { console.warn('Fallback renderer init error:', e); }
      },
      render() {
        if (this.renderer && this.scene && this.camera) {
          this.renderer.render(this.scene, this.camera);
        }
      },
      renderFrame() { this.render(); },
      onResize(w, h) {
        if (!this.renderer) return;
        this.renderer.setSize(w, h);
        if (this.camera) { this.camera.aspect = w / h; this.camera.updateProjectionMatrix(); }
      },
      setFlashlight() {},
      flickerLights() {},
      flickerFlashlight() {},
      setSanityEffect() {},
      setVignetteIntensity() {},
      setChromAberration() {},
      updateParticles() {},
      updateEffects() {},
      setPostProcessingParams() {},
      setupPostProcessing() {},
      checkCollisions() {},
      rotateCamera(dx, dy) {
        if (!this.camera) return;
        this.camera.rotation.y -= dx;
        this.camera.rotation.x -= dy;
        this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));
      },
      openBasementDoor() {},
      spawnShadowFigure() {},
      showBloodWriting() {}
    };
    return stub;
  }

  _createFallbackState() {
    const handlers = {};
    return {
      init() {},
      on(evt, fn) { handlers[evt] = handlers[evt] || []; handlers[evt].push(fn); },
      emit(evt, data) { (handlers[evt] || []).forEach(fn => fn(data)); },
      applySync() {}
    };
  }

  _createFallbackPlayer() {
    const pos = { x: 0, y: 1.7, z: 5 };
    const rot = { x: 0, y: 0, z: 0 };
    return {
      position: pos,
      rotation: rot,
      init() {},
      spawn(p) { Object.assign(pos, p); },
      setPosition(x, y, z) { pos.x = x; pos.y = y; pos.z = z; },
      getPosition() { return Object.assign({}, pos); },
      getRotation() { return Object.assign({}, rot); },
      update(delta, keys) {
        const speed = 5 * delta;
        if (keys['KeyW'] || keys['ArrowUp'])    { pos.z -= speed * Math.cos(rot.y); pos.x -= speed * Math.sin(rot.y); }
        if (keys['KeyS'] || keys['ArrowDown'])  { pos.z += speed * Math.cos(rot.y); pos.x += speed * Math.sin(rot.y); }
        if (keys['KeyA'] || keys['ArrowLeft'])  { pos.x -= speed * Math.cos(rot.y); pos.z += speed * Math.sin(rot.y); }
        if (keys['KeyD'] || keys['ArrowRight']) { pos.x += speed * Math.cos(rot.y); pos.z -= speed * Math.sin(rot.y); }
        // Sync camera if renderer exists
        try {
          const cam = window.game && window.game.renderer && window.game.renderer.camera;
          if (cam) { cam.position.x = pos.x; cam.position.y = pos.y; cam.position.z = pos.z; }
        } catch(e) {}
      },
      onMouseMove(dx, dy) {
        rot.y -= dx;
        rot.x -= dy;
        rot.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rot.x));
        try {
          const cam = window.game && window.game.renderer && window.game.renderer.camera;
          if (cam) { cam.rotation.y = rot.y; cam.rotation.x = rot.x; }
        } catch(e) {}
      },
      onKeyDown() {},
      onKeyUp() {},
      resolveCollisions() {},
      interact() {},
      setCharacter() {},
      setFlashlight() {},
      setUsingItem() {}
    };
  }

  _createFallbackAlisa() {
    return {
      init() {},
      update() {},
      isNearPlayer() { return false; },
      getEMFLevel() { return 0; },
      getTemperature() { return 18; },
      triggerManifest() {},
      repel() {}
    };
  }

  _createFallbackInteraction() {
    return {
      init() {},
      update() {},
      tryInteract() { return null; },
      registerObjectives() {}
    };
  }

  _createFallbackHUD() {
    // Minimal DOM-based HUD fallback
    const mkEl = (id, styles) => {
      let el = document.getElementById(id);
      if (!el) {
        el = document.createElement('div');
        el.id = id;
        el.style.cssText = styles;
        document.body.appendChild(el);
      }
      return el;
    };
    const hudBase = 'position:fixed;z-index:1000;font-family:monospace;font-size:14px;color:#ddd;background:rgba(0,0,0,0.5);padding:6px 10px;border-radius:4px;pointer-events:none;';
    const sanityEl    = mkEl('hud-sanity',    hudBase + 'top:10px;left:10px;');
    const batteryEl   = mkEl('hud-battery',   hudBase + 'top:40px;left:10px;');
    const objectiveEl = mkEl('hud-objective', hudBase + 'bottom:60px;left:10px;max-width:320px;');
    const notifyEl    = mkEl('hud-notify',    hudBase + 'bottom:100px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.75);');
    let notifyTimer;
    return {
      init() {},
      show() { [sanityEl, batteryEl, objectiveEl].forEach(e => e.style.display = 'block'); },
      hide() { [sanityEl, batteryEl, objectiveEl, notifyEl].forEach(e => e.style.display = 'none'); },
      setSanity(v) { sanityEl.textContent = 'Cordura: ' + Math.round(v) + '%'; },
      setBattery(v) { batteryEl.textContent = 'BaterÃ­a: ' + Math.round(v) + '%'; },
      setObjective(text) { objectiveEl.textContent = 'â¶ ' + (text || ''); },
      setEMF() {},
      setTemperature() {},
      showNotification(msg) {
        notifyEl.textContent = msg;
        notifyEl.style.display = 'block';
        if (notifyTimer) clearTimeout(notifyTimer);
        notifyTimer = setTimeout(() => { notifyEl.style.display = 'none'; }, 3000);
      },
      showWarning(msg) { this.showNotification('â  ' + msg); },
      showObjectiveComplete(text) { this.showNotification('â ' + text); },
      showParanormalAlert(type) { this.showNotification('Â¡Actividad paranormal: ' + type + '!'); },
      showBossIndicator(msg) { this.showNotification('ð ' + msg); },
      flashSanity() { sanityEl.style.color = '#ff4444'; setTimeout(() => { sanityEl.style.color = '#ddd'; }, 500); },
      update() {}
    };
  }

  _createFallbackMultiplayer() {
    return {
      init() {},
      connect() {},
      disconnect() {},
      async createRoom() { return Math.random().toString(36).substr(2,4).toUpperCase(); },
      async joinRoom() {},
      async syncFromHost() { return null; },
      sendUpdate() {},
      broadcast() {},
      getPlayerIndex() { return 0; },
      isConnected() { return false; }
    };
  }

  _createFallbackRemotePlayers() {
    return { init() {}, update() {} };
  }

  _createFallbackChat() {
    return {
      init() {},
      open() {},
      close() {},
      isOpen() { return false; },
      sendMessage() {}
    };
  }
}

// ============================================================
// DOM READY â Bootstrap
// ============================================================

document.addEventListener('DOMContentLoaded', () => {
  try {
    window.game = new Game();
    window.game.init().catch(err => {
      console.error('[Bootstrap] game.init() rejected:', err);
    });
  } catch (e) {
    console.error('[Bootstrap] Failed to create Game:', e);
  }
});

// ââ First user-interaction AudioContext unlock ââ
let _audioStarted = false;
function _tryStartAudio() {
  if (_audioStarted) return;
  if (!window.game || !window.game.audio) return;
  try {
    const ctx = window.game.audio.context;
    if (ctx && ctx.state === 'suspended') {
      ctx.resume().then(() => {
        _audioStarted = true;
      }).catch(() => {});
    } else {
      _audioStarted = true;
    }
  } catch (e) { /* silent */ }
}

['click', 'touchstart', 'keydown'].forEach(evt => {
  document.addEventListener(evt, _tryStartAudio, { passive: true });
});

// ââ Global keyboard guard for pointer lock re-acquisition ââ
document.addEventListener('keydown', (e) => {
  if (!window.game) return;
  if (e.code === 'Escape' && window.game.isRunning && window.game.isPaused) {
    window.game.resumeGame();
  }
}, false);

// ââ Expose debug helpers in development ââ
if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
  window._debugGame = {
    setSanity(v) { if (window.game) window.game.sanity = v; },
    toggleFlashlight() { if (window.game) window.game._toggleFlashlight(); },
    paranoidEvent() { if (window.game) window.game._triggerRandomParanormalEvent(); },
    completeObjective(id) { if (window.game) window.game._completeObjective(id); },
    gameOver(r) { if (window.game) window.game._triggerGameOver(r || 'death'); },
    skipToEnd() {
      if (window.game) {
        window.game.chapter1Objectives.forEach(o => { o.completed = false; });
        window.game._completeObjective('escape');
      }
    }
  };
  console.info('[El Susurro] Debug helpers: window._debugGame');
}
</script>
</body>
</html>